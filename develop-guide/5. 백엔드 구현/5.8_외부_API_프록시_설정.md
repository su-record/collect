# ğŸŒ 5.9 ì™¸ë¶€ API í”„ë¡ì‹œ ì„¤ì •

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [í”„ë¡ì‹œ ì„œë¹„ìŠ¤ êµ¬í˜„](#2-í”„ë¡ì‹œ-ì„œë¹„ìŠ¤-êµ¬í˜„)
3. [API ë¼ìš°íŠ¸ êµ¬í˜„](#3-api-ë¼ìš°íŠ¸-êµ¬í˜„)
4. [ê²€ì¦](#4-ê²€ì¦)

## 1. ê°œìš”
Open-Meteo, Google Maps, Cloud Vision, Google Translate APIì— ëŒ€í•œ í”„ë¡ì‹œë¥¼ êµ¬í˜„í•˜ì—¬ API í‚¤ ë³´í˜¸ì™€ ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… API í‚¤ ë³´í˜¸
- âœ… ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…
- âœ… ì—ëŸ¬ ì²˜ë¦¬ ë° í´ë°±
- âœ… ë²ˆì—­ ìºì‹±

## 2. í”„ë¡ì‹œ ì„œë¹„ìŠ¤ êµ¬í˜„

### [í•„ìˆ˜] ì™¸ë¶€ API ì„œë¹„ìŠ¤
```python
# íŒŒì¼: app/services/external_api_service.py
import requests
from typing import Dict, Optional, Any, Tuple, List
from datetime import datetime, timedelta
from collections import defaultdict
import time
import hashlib
import json

class RateLimiter:
    """ë ˆì´íŠ¸ ë¦¬ë¯¸í„°"""
    def __init__(self, max_requests: int, time_window: int):
        self.max_requests = max_requests
        self.time_window = time_window  # seconds
        self.requests = defaultdict(list)
    
    def is_allowed(self, key: str) -> bool:
        """ìš”ì²­ í—ˆìš© ì—¬ë¶€"""
        now = time.time()
        cutoff = now - self.time_window
        
        # ì˜¤ë˜ëœ ìš”ì²­ ì œê±°
        self.requests[key] = [
            req_time for req_time in self.requests[key]
            if req_time > cutoff
        ]
        
        # í•œë„ í™•ì¸
        if len(self.requests[key]) >= self.max_requests:
            return False
        
        # ìš”ì²­ ê¸°ë¡
        self.requests[key].append(now)
        return True
    
    def get_reset_time(self, key: str) -> int:
        """ë¦¬ì…‹ ì‹œê°„ (ì´ˆ)"""
        if not self.requests[key]:
            return 0
        
        oldest_request = min(self.requests[key])
        reset_time = oldest_request + self.time_window - time.time()
        return max(0, int(reset_time))

class TranslationCache:
    """ë²ˆì—­ ìºì‹œ"""
    def __init__(self, max_size: int = 10000):
        self.cache = {}
        self.max_size = max_size
        self.access_count = defaultdict(int)
    
    def get_key(self, text: str, source: str, target: str) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        return hashlib.md5(f"{text}:{source}:{target}".encode()).hexdigest()
    
    def get(self, text: str, source: str, target: str) -> Optional[str]:
        """ìºì‹œì—ì„œ ë²ˆì—­ ì¡°íšŒ"""
        key = self.get_key(text, source, target)
        if key in self.cache:
            self.access_count[key] += 1
            return self.cache[key]
        return None
    
    def set(self, text: str, source: str, target: str, translation: str):
        """ë²ˆì—­ ìºì‹œ ì €ì¥"""
        # ìºì‹œ í¬ê¸° ì œí•œ
        if len(self.cache) >= self.max_size:
            # LRU: ê°€ì¥ ì ê²Œ ì‚¬ìš©ëœ í•­ëª© ì œê±°
            least_used = min(self.cache.keys(), key=lambda k: self.access_count.get(k, 0))
            del self.cache[least_used]
            if least_used in self.access_count:
                del self.access_count[least_used]
        
        key = self.get_key(text, source, target)
        self.cache[key] = translation
        self.access_count[key] = 1

class ExternalAPIService:
    """ì™¸ë¶€ API í”„ë¡ì‹œ ì„œë¹„ìŠ¤"""
    
    # ë ˆì´íŠ¸ ë¦¬ë¯¸í„°
    weather_limiter = RateLimiter(max_requests=100, time_window=3600)  # ì‹œê°„ë‹¹ 100íšŒ
    maps_limiter = RateLimiter(max_requests=50, time_window=60)  # ë¶„ë‹¹ 50íšŒ
    vision_limiter = RateLimiter(max_requests=20, time_window=60)  # ë¶„ë‹¹ 20íšŒ
    translate_limiter = RateLimiter(max_requests=100, time_window=60)  # ë¶„ë‹¹ 100íšŒ
    
    # ë²ˆì—­ ìºì‹œ
    translation_cache = TranslationCache()
    
    # API ì—”ë“œí¬ì¸íŠ¸
    WEATHER_API_URL = "https://api.open-meteo.com/v1/forecast"
    GEOCODING_API_URL = "https://maps.googleapis.com/maps/api/geocode/json"
    PLACES_API_URL = "https://maps.googleapis.com/maps/api/place/nearbysearch/json"
    TRANSLATE_API_URL = "https://translation.googleapis.com/language/translate/v2"
    
    @classmethod
    def get_weather(cls, lat: float, lng: float, user_id: str = None) -> Tuple[Optional[Dict], Optional[str]]:
        """ë‚ ì”¨ ì •ë³´ ì¡°íšŒ"""
        # ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…
        rate_key = user_id or 'anonymous'
        if not cls.weather_limiter.is_allowed(rate_key):
            reset_time = cls.weather_limiter.get_reset_time(rate_key)
            return None, f"ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. {reset_time}ì´ˆ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        
        try:
            # Open-Meteo API í˜¸ì¶œ
            params = {
                'latitude': lat,
                'longitude': lng,
                'current_weather': 'true',
                'hourly': 'temperature_2m,precipitation,weathercode',
                'timezone': 'Asia/Seoul'
            }
            
            response = requests.get(
                cls.WEATHER_API_URL,
                params=params,
                timeout=5
            )
            
            if response.status_code != 200:
                return None, f"ë‚ ì”¨ API ì˜¤ë¥˜: {response.status_code}"
            
            data = response.json()
            
            # ë‚ ì”¨ ìƒíƒœ í•´ì„
            weather_code = data['current_weather']['weathercode']
            weather_status = cls._interpret_weather_code(weather_code)
            
            # ì‘ë‹µ í¬ë§·
            result = {
                'location': cls._get_location_name(lat, lng),
                'temperature': data['current_weather']['temperature'],
                'weatherCode': weather_code,
                'description': weather_status['description'],
                'emoji': weather_status['emoji'],
                'windSpeed': data['current_weather']['windspeed'],
                'humidity': None,  # Open-Meteo ë¬´ë£Œ ë²„ì „ì—ëŠ” ì—†ìŒ
                'timestamp': datetime.now().isoformat()
            }
            
            return result, None
            
        except requests.exceptions.Timeout:
            return None, "ë‚ ì”¨ API ì‘ë‹µ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤."
        except Exception as e:
            return None, f"ë‚ ì”¨ ì •ë³´ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}"
    
    @classmethod
    def translate_text(cls, 
                      texts: List[str], 
                      target_language: str,
                      source_language: str = None,
                      user_id: str = None) -> Tuple[Optional[Dict], Optional[str]]:
        """í…ìŠ¤íŠ¸ ë²ˆì—­ (Google Translate API)"""
        # ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…
        rate_key = user_id or 'anonymous'
        if not cls.translate_limiter.is_allowed(rate_key):
            reset_time = cls.translate_limiter.get_reset_time(rate_key)
            return None, f"ë²ˆì—­ ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. {reset_time}ì´ˆ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        
        # ìºì‹œ í™•ì¸ ë° ë²ˆì—­ í•„ìš”í•œ í…ìŠ¤íŠ¸ ë¶„ë¦¬
        translations = []
        texts_to_translate = []
        cache_hits = []
        
        for text in texts:
            cached = cls.translation_cache.get(text, source_language or 'auto', target_language)
            if cached:
                translations.append(cached)
                cache_hits.append(True)
            else:
                texts_to_translate.append(text)
                translations.append(None)
                cache_hits.append(False)
        
        # Mock ë²ˆì—­ (ì‹¤ì œë¡œëŠ” Google Translate API ì‚¬ìš©)
        if texts_to_translate:
            # Mock ë²ˆì—­ ë¡œì§
            translate_idx = 0
            for i, cached in enumerate(cache_hits):
                if not cached:
                    original = texts[i]
                    
                    # ê°„ë‹¨í•œ Mock ë²ˆì—­
                    if target_language == 'en':
                        if 'ê¹€ì¹˜ì°Œê°œ' in original:
                            translation = 'Kimchi Stew'
                        elif 'ë§›ìˆ' in original:
                            translation = 'Delicious'
                        elif 'ì¶”ì²œ' in original:
                            translation = 'Recommend'
                        else:
                            translation = f'[EN] {original}'
                    elif target_language == 'ja':
                        if 'ê¹€ì¹˜ì°Œê°œ' in original:
                            translation = 'ã‚­ãƒ ãƒãƒã‚²'
                        elif 'ë§›ìˆ' in original:
                            translation = 'ç¾å‘³ã—ã„'
                        elif 'ì¶”ì²œ' in original:
                            translation = 'ãŠã™ã™ã‚'
                        else:
                            translation = f'[JA] {original}'
                    elif target_language == 'zh':
                        if 'ê¹€ì¹˜ì°Œê°œ' in original:
                            translation = 'æ³¡èœæ±¤'
                        elif 'ë§›ìˆ' in original:
                            translation = 'å¥½åƒ'
                        elif 'ì¶”ì²œ' in original:
                            translation = 'æ¨è'
                        else:
                            translation = f'[ZH] {original}'
                    else:
                        translation = original
                    
                    # ìºì‹œì— ì €ì¥
                    cls.translation_cache.set(
                        original, 
                        source_language or 'auto', 
                        target_language, 
                        translation
                    )
                    translations[i] = translation
        
        # ì–¸ì–´ ê°ì§€ (Mock)
        detected_language = source_language
        if not detected_language:
            # ê°„ë‹¨í•œ ì–¸ì–´ ê°ì§€
            sample_text = texts[0] if texts else ''
            if any(ord('ê°€') <= ord(c) <= ord('í£') for c in sample_text):
                detected_language = 'ko'
            elif any(ord('ã‚') <= ord(c) <= ord('ã‚“') for c in sample_text):
                detected_language = 'ja'
            elif any(0x4e00 <= ord(c) <= 0x9fff for c in sample_text):
                detected_language = 'zh'
            else:
                detected_language = 'en'
        
        return {
            'translations': translations,
            'detectedLanguage': detected_language,
            'targetLanguage': target_language,
            'cacheHits': sum(cache_hits),
            'totalRequests': len(texts)
        }, None
    
    @classmethod
    def search_places(cls, 
                     lat: float, 
                     lng: float, 
                     radius: int = 1000,
                     keyword: str = None,
                     place_type: str = 'restaurant',
                     user_id: str = None) -> Tuple[Optional[Dict], Optional[str]]:
        """ì£¼ë³€ ì¥ì†Œ ê²€ìƒ‰"""
        # ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…
        rate_key = user_id or 'anonymous'
        if not cls.maps_limiter.is_allowed(rate_key):
            reset_time = cls.maps_limiter.get_reset_time(rate_key)
            return None, f"ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. {reset_time}ì´ˆ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        
        # Mock ì‘ë‹µ (ì‹¤ì œë¡œëŠ” Google Maps API ì‚¬ìš©)
        from app.services.mock_data import MockDataService
        import random
        
        places = []
        for i in range(min(20, radius // 100)):
            restaurant_name = MockDataService.RESTAURANT_NAMES[i % len(MockDataService.RESTAURANT_NAMES)]
            
            # ëœë¤ ìœ„ì¹˜ ìƒì„± (ìš”ì²­ ìœ„ì¹˜ ê·¼ì²˜)
            place_lat = lat + random.uniform(-0.01, 0.01)
            place_lng = lng + random.uniform(-0.01, 0.01)
            
            places.append({
                'placeId': f"place_{i}",
                'name': restaurant_name,
                'vicinity': f"ì„œìš¸ì‹œ ê°•ë‚¨êµ¬ {i+1}ê¸¸",
                'location': {
                    'lat': place_lat,
                    'lng': place_lng
                },
                'rating': round(random.uniform(3.5, 5.0), 1),
                'userRatingsTotal': random.randint(10, 500),
                'priceLevel': random.randint(1, 4),
                'types': ['restaurant', 'food']
            })
        
        # í‚¤ì›Œë“œ í•„í„°ë§
        if keyword:
            places = [p for p in places if keyword.lower() in p['name'].lower()]
        
        return {
            'places': places,
            'total': len(places)
        }, None
    
    @classmethod
    def geocode_address(cls, address: str, user_id: str = None) -> Tuple[Optional[Dict], Optional[str]]:
        """ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜"""
        # ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…
        rate_key = user_id or 'anonymous'
        if not cls.maps_limiter.is_allowed(rate_key):
            reset_time = cls.maps_limiter.get_reset_time(rate_key)
            return None, f"ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. {reset_time}ì´ˆ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        
        # Mock ì‘ë‹µ
        import random
        
        if 'ì„œìš¸' in address:
            lat = 37.5665 + random.uniform(-0.1, 0.1)
            lng = 126.9780 + random.uniform(-0.1, 0.1)
        else:
            lat = 37.5665
            lng = 126.9780
        
        return {
            'formatted_address': address,
            'location': {
                'lat': lat,
                'lng': lng
            },
            'place_id': f"place_{hash(address) % 1000}"
        }, None
    
    @classmethod
    def analyze_image_vision(cls, image_url: str, user_id: str = None) -> Tuple[Optional[Dict], Optional[str]]:
        """Cloud Vision API ì´ë¯¸ì§€ ë¶„ì„ (Mock)"""
        # ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…
        rate_key = user_id or 'anonymous'
        if not cls.vision_limiter.is_allowed(rate_key):
            reset_time = cls.vision_limiter.get_reset_time(rate_key)
            return None, f"ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. {reset_time}ì´ˆ í›„ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”."
        
        # Mock ì‘ë‹µ
        import random
        
        labels = [
            {'description': 'ìŒì‹', 'score': 0.95},
            {'description': 'í•œì‹', 'score': 0.89},
            {'description': 'ê¹€ì¹˜ì°Œê°œ', 'score': 0.87},
            {'description': 'ì°Œê°œ', 'score': 0.85},
            {'description': 'ë§¤ìš´ ìŒì‹', 'score': 0.82}
        ]
        
        return {
            'labels': labels[:3],
            'foodConfidence': random.uniform(0.85, 0.95),
            'dominantColors': [
                {'color': '#D2691E', 'score': 0.45},
                {'color': '#FF6347', 'score': 0.30},
                {'color': '#FFFFFF', 'score': 0.25}
            ]
        }, None
    
    @classmethod
    def _interpret_weather_code(cls, code: int) -> Dict[str, str]:
        """ë‚ ì”¨ ì½”ë“œ í•´ì„"""
        weather_codes = {
            0: {'description': 'ë§‘ìŒ', 'emoji': 'â˜€ï¸'},
            1: {'description': 'ëŒ€ì²´ë¡œ ë§‘ìŒ', 'emoji': 'ğŸŒ¤ï¸'},
            2: {'description': 'ë¶€ë¶„ì ìœ¼ë¡œ íë¦¼', 'emoji': 'â›…'},
            3: {'description': 'íë¦¼', 'emoji': 'â˜ï¸'},
            45: {'description': 'ì•ˆê°œ', 'emoji': 'ğŸŒ«ï¸'},
            48: {'description': 'ì„œë¦¬ ì•ˆê°œ', 'emoji': 'ğŸŒ«ï¸'},
            51: {'description': 'ê°€ë²¼ìš´ ì´ìŠ¬ë¹„', 'emoji': 'ğŸŒ¦ï¸'},
            53: {'description': 'ë³´í†µ ì´ìŠ¬ë¹„', 'emoji': 'ğŸŒ¦ï¸'},
            55: {'description': 'ê°•í•œ ì´ìŠ¬ë¹„', 'emoji': 'ğŸŒ§ï¸'},
            61: {'description': 'ì•½í•œ ë¹„', 'emoji': 'ğŸŒ§ï¸'},
            63: {'description': 'ë³´í†µ ë¹„', 'emoji': 'ğŸŒ§ï¸'},
            65: {'description': 'ê°•í•œ ë¹„', 'emoji': 'ğŸŒ§ï¸'},
            71: {'description': 'ì•½í•œ ëˆˆ', 'emoji': 'ğŸŒ¨ï¸'},
            73: {'description': 'ë³´í†µ ëˆˆ', 'emoji': 'ğŸŒ¨ï¸'},
            75: {'description': 'ê°•í•œ ëˆˆ', 'emoji': 'â„ï¸'},
            77: {'description': 'ì§„ëˆˆê¹¨ë¹„', 'emoji': 'ğŸŒ¨ï¸'},
            80: {'description': 'ì•½í•œ ì†Œë‚˜ê¸°', 'emoji': 'ğŸŒ¦ï¸'},
            81: {'description': 'ë³´í†µ ì†Œë‚˜ê¸°', 'emoji': 'ğŸŒ§ï¸'},
            82: {'description': 'ê°•í•œ ì†Œë‚˜ê¸°', 'emoji': 'â›ˆï¸'},
            85: {'description': 'ì•½í•œ ëˆˆë³´ë¼', 'emoji': 'ğŸŒ¨ï¸'},
            86: {'description': 'ê°•í•œ ëˆˆë³´ë¼', 'emoji': 'â„ï¸'},
            95: {'description': 'ë‡Œìš°', 'emoji': 'â›ˆï¸'},
            96: {'description': 'ìš°ë°•ì„ ë™ë°˜í•œ ë‡Œìš°', 'emoji': 'â›ˆï¸'},
            99: {'description': 'ê°•í•œ ìš°ë°•ì„ ë™ë°˜í•œ ë‡Œìš°', 'emoji': 'â›ˆï¸'}
        }
        
        return weather_codes.get(code, {'description': 'ì•Œ ìˆ˜ ì—†ìŒ', 'emoji': 'â“'})
    
    @classmethod
    def _get_location_name(cls, lat: float, lng: float) -> str:
        """ì¢Œí‘œë¥¼ ì§€ì—­ëª…ìœ¼ë¡œ ë³€í™˜ (Mock)"""
        if 37.4 < lat < 37.7 and 126.8 < lng < 127.2:
            return "ì„œìš¸íŠ¹ë³„ì‹œ"
        else:
            return "ëŒ€í•œë¯¼êµ­"
```

## 3. API ë¼ìš°íŠ¸ êµ¬í˜„

### [í•„ìˆ˜] í”„ë¡ì‹œ API ë¼ìš°íŠ¸
```python
# íŒŒì¼: app/api/proxy/routes.py
from flask import Blueprint, request, g
from app.services.external_api_service import ExternalAPIService
from app.api.common.mock_utils import mock_delay, success_response, error_response

proxy_bp = Blueprint('proxy', __name__)

@proxy_bp.route('/weather', methods=['GET'])
@mock_delay()
def get_weather():
    """ë‚ ì”¨ ì •ë³´ ì¡°íšŒ"""
    # íŒŒë¼ë¯¸í„°
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    
    if lat is None or lng is None:
        return error_response("ìœ„ë„ì™€ ê²½ë„ê°€ í•„ìš”í•©ë‹ˆë‹¤.", "MISSING_PARAMS", 400)
    
    # ì‚¬ìš©ì ID (ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…ìš©)
    user_id = g.get('current_user_id', request.remote_addr)
    
    # ë‚ ì”¨ ì¡°íšŒ
    result, error = ExternalAPIService.get_weather(lat, lng, user_id)
    
    if error:
        return error_response(error, "WEATHER_API_ERROR", 503)
    
    return success_response(result)

@proxy_bp.route('/translate', methods=['POST'])
@mock_delay()
def translate_text():
    """í…ìŠ¤íŠ¸ ë²ˆì—­"""
    data = request.get_json()
    texts = data.get('texts', [])
    target_language = data.get('targetLanguage')
    source_language = data.get('sourceLanguage')
    
    if not texts:
        return error_response("ë²ˆì—­í•  í…ìŠ¤íŠ¸ê°€ í•„ìš”í•©ë‹ˆë‹¤.", "MISSING_TEXTS", 400)
    
    if not target_language:
        return error_response("ëŒ€ìƒ ì–¸ì–´ê°€ í•„ìš”í•©ë‹ˆë‹¤.", "MISSING_TARGET_LANGUAGE", 400)
    
    # ì§€ì› ì–¸ì–´ í™•ì¸
    supported_languages = ['ko', 'en', 'ja', 'zh']
    if target_language not in supported_languages:
        return error_response(
            f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì–¸ì–´ì…ë‹ˆë‹¤. ì§€ì› ì–¸ì–´: {', '.join(supported_languages)}", 
            "UNSUPPORTED_LANGUAGE", 
            400
        )
    
    # í…ìŠ¤íŠ¸ ìˆ˜ ì œí•œ
    if len(texts) > 100:
        return error_response("í•œ ë²ˆì— ìµœëŒ€ 100ê°œì˜ í…ìŠ¤íŠ¸ë§Œ ë²ˆì—­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", "TOO_MANY_TEXTS", 400)
    
    # ì‚¬ìš©ì ID
    user_id = g.get('current_user_id', request.remote_addr)
    
    # ë²ˆì—­ ì‹¤í–‰
    result, error = ExternalAPIService.translate_text(
        texts, target_language, source_language, user_id
    )
    
    if error:
        return error_response(error, "TRANSLATION_ERROR", 503)
    
    return success_response(result)

@proxy_bp.route('/places/search', methods=['GET'])
@mock_delay()
def search_places():
    """ì£¼ë³€ ì¥ì†Œ ê²€ìƒ‰"""
    # íŒŒë¼ë¯¸í„°
    lat = request.args.get('lat', type=float)
    lng = request.args.get('lng', type=float)
    radius = int(request.args.get('radius', 1000))
    keyword = request.args.get('keyword')
    place_type = request.args.get('type', 'restaurant')
    
    if lat is None or lng is None:
        return error_response("ìœ„ë„ì™€ ê²½ë„ê°€ í•„ìš”í•©ë‹ˆë‹¤.", "MISSING_PARAMS", 400)
    
    if radius < 100 or radius > 50000:
        return error_response("ë°˜ê²½ì€ 100m-50km ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤.", "INVALID_RADIUS", 400)
    
    # ì‚¬ìš©ì ID
    user_id = g.get('current_user_id', request.remote_addr)
    
    # ì¥ì†Œ ê²€ìƒ‰
    result, error = ExternalAPIService.search_places(
        lat, lng, radius, keyword, place_type, user_id
    )
    
    if error:
        return error_response(error, "PLACES_API_ERROR", 503)
    
    return success_response(result)

@proxy_bp.route('/geocode', methods=['GET'])
@mock_delay()
def geocode_address():
    """ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜"""
    # íŒŒë¼ë¯¸í„°
    address = request.args.get('address', '').strip()
    
    if not address:
        return error_response("ì£¼ì†Œê°€ í•„ìš”í•©ë‹ˆë‹¤.", "MISSING_ADDRESS", 400)
    
    # ì‚¬ìš©ì ID
    user_id = g.get('current_user_id', request.remote_addr)
    
    # ì§€ì˜¤ì½”ë”©
    result, error = ExternalAPIService.geocode_address(address, user_id)
    
    if error:
        return error_response(error, "GEOCODING_ERROR", 503)
    
    return success_response(result)

@proxy_bp.route('/vision/analyze', methods=['POST'])
@mock_delay(min_ms=1000, max_ms=2000)
def analyze_image():
    """ì´ë¯¸ì§€ ë¶„ì„ (Cloud Vision API)"""
    data = request.get_json()
    image_url = data.get('imageUrl')
    
    if not image_url:
        return error_response("ì´ë¯¸ì§€ URLì´ í•„ìš”í•©ë‹ˆë‹¤.", "MISSING_IMAGE_URL", 400)
    
    # ì‚¬ìš©ì ID
    user_id = g.get('current_user_id', request.remote_addr)
    
    # ì´ë¯¸ì§€ ë¶„ì„
    result, error = ExternalAPIService.analyze_image_vision(image_url, user_id)
    
    if error:
        return error_response(error, "VISION_API_ERROR", 503)
    
    return success_response(result)

@proxy_bp.route('/rate-limits', methods=['GET'])
def get_rate_limits():
    """í˜„ì¬ ì‚¬ìš©ìì˜ ë ˆì´íŠ¸ ë¦¬ë°‹ ìƒíƒœ"""
    user_id = g.get('current_user_id', request.remote_addr)
    
    # ê° APIì˜ ë‚¨ì€ ìš”ì²­ ìˆ˜ ê³„ì‚°
    weather_remaining = ExternalAPIService.weather_limiter.max_requests - \
                       len(ExternalAPIService.weather_limiter.requests.get(user_id, []))
    maps_remaining = ExternalAPIService.maps_limiter.max_requests - \
                    len(ExternalAPIService.maps_limiter.requests.get(user_id, []))
    vision_remaining = ExternalAPIService.vision_limiter.max_requests - \
                      len(ExternalAPIService.vision_limiter.requests.get(user_id, []))
    translate_remaining = ExternalAPIService.translate_limiter.max_requests - \
                         len(ExternalAPIService.translate_limiter.requests.get(user_id, []))
    
    return success_response({
        'weather': {
            'remaining': max(0, weather_remaining),
            'limit': ExternalAPIService.weather_limiter.max_requests,
            'resetIn': ExternalAPIService.weather_limiter.get_reset_time(user_id)
        },
        'maps': {
            'remaining': max(0, maps_remaining),
            'limit': ExternalAPIService.maps_limiter.max_requests,
            'resetIn': ExternalAPIService.maps_limiter.get_reset_time(user_id)
        },
        'vision': {
            'remaining': max(0, vision_remaining),
            'limit': ExternalAPIService.vision_limiter.max_requests,
            'resetIn': ExternalAPIService.vision_limiter.get_reset_time(user_id)
        },
        'translate': {
            'remaining': max(0, translate_remaining),
            'limit': ExternalAPIService.translate_limiter.max_requests,
            'resetIn': ExternalAPIService.translate_limiter.get_reset_time(user_id)
        }
    })
```

### [í•„ìˆ˜] ë¸”ë£¨í”„ë¦°íŠ¸ ë“±ë¡
```python
# íŒŒì¼: app/api/__init__.py ìˆ˜ì •
def register_blueprints(app):
    """ë¸”ë£¨í”„ë¦°íŠ¸ ë“±ë¡"""
    from .auth.routes import auth_bp
    from .users.routes import users_bp
    from .feeds.routes import feeds_bp
    from .ranking.routes import ranking_bp
    from .notifications.routes import notifications_bp
    from .search.routes import search_bp
    from .upload.routes import upload_bp
    from .proxy.routes import proxy_bp  # ì¶”ê°€
    
    # API v1 prefixë¡œ ë“±ë¡
    api_prefix = f"/api/{app.config['API_VERSION']}"
    
    app.register_blueprint(auth_bp, url_prefix=f"{api_prefix}/auth")
    app.register_blueprint(users_bp, url_prefix=f"{api_prefix}/users")
    app.register_blueprint(feeds_bp, url_prefix=f"{api_prefix}/feeds")
    app.register_blueprint(ranking_bp, url_prefix=f"{api_prefix}/ranking")
    app.register_blueprint(notifications_bp, url_prefix=f"{api_prefix}/notifications")
    app.register_blueprint(search_bp, url_prefix=f"{api_prefix}/search")
    app.register_blueprint(upload_bp, url_prefix=f"{api_prefix}/upload")
    app.register_blueprint(proxy_bp, url_prefix=f"{api_prefix}/proxy")  # ì¶”ê°€
```

## 4. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ë‚ ì”¨ APIê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ì¥ì†Œ ê²€ìƒ‰ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ì§€ì˜¤ì½”ë”©ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ì´ë¯¸ì§€ ë¶„ì„ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ë²ˆì—­ APIê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ë²ˆì—­ ìºì‹±ì´ ì‘ë™í•˜ëŠ”ê°€?
- [ ] ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ…ì´ ì‘ë™í•˜ëŠ”ê°€?
- [ ] í•œë„ ì´ˆê³¼ ì‹œ ì—ëŸ¬ê°€ ë°˜í™˜ë˜ëŠ”ê°€?
- [ ] ë ˆì´íŠ¸ ë¦¬ë°‹ ìƒíƒœë¥¼ í™•ì¸í•  ìˆ˜ ìˆëŠ”ê°€?

### API í…ŒìŠ¤íŠ¸
```bash
# ë‚ ì”¨ ì •ë³´
curl "http://localhost:5000/api/v1/proxy/weather?lat=37.5665&lng=126.9780"

# ë²ˆì—­ (ë‹¨ì¼)
curl -X POST http://localhost:5000/api/v1/proxy/translate \
  -H "Content-Type: application/json" \
  -d '{
    "texts": ["ê¹€ì¹˜ì°Œê°œ ì •ë§ ë§›ìˆì–´ìš”!"],
    "targetLanguage": "en"
  }'

# ë²ˆì—­ (ë‹¤ì¤‘)
curl -X POST http://localhost:5000/api/v1/proxy/translate \
  -H "Content-Type: application/json" \
  -d '{
    "texts": ["ê¹€ì¹˜ì°Œê°œ", "ëœì¥ì°Œê°œ", "ìˆœë‘ë¶€ì°Œê°œ"],
    "targetLanguage": "ja",
    "sourceLanguage": "ko"
  }'

# ì£¼ë³€ ì¥ì†Œ ê²€ìƒ‰
curl "http://localhost:5000/api/v1/proxy/places/search?lat=37.5665&lng=126.9780&radius=1000&keyword=ê¹€ì¹˜"

# ì£¼ì†Œë¥¼ ì¢Œí‘œë¡œ ë³€í™˜
curl "http://localhost:5000/api/v1/proxy/geocode?address=ì„œìš¸ì‹œ+ê°•ë‚¨êµ¬+í…Œí—¤ë€ë¡œ"

# ì´ë¯¸ì§€ ë¶„ì„
curl -X POST http://localhost:5000/api/v1/proxy/vision/analyze \
  -H "Content-Type: application/json" \
  -d '{"imageUrl": "https://example.com/food.jpg"}'

# ë ˆì´íŠ¸ ë¦¬ë°‹ ìƒíƒœ í™•ì¸
curl "http://localhost:5000/api/v1/proxy/rate-limits"
```

### ë²ˆì—­ ìºì‹± í…ŒìŠ¤íŠ¸
```bash
# ê°™ì€ í…ìŠ¤íŠ¸ ë°˜ë³µ ë²ˆì—­ (ìºì‹œ íš¨ê³¼ í™•ì¸)
for i in {1..5}; do
  echo "Request $i:"
  time curl -X POST http://localhost:5000/api/v1/proxy/translate \
    -H "Content-Type: application/json" \
    -d '{
      "texts": ["ê¹€ì¹˜ì°Œê°œ ì •ë§ ë§›ìˆì–´ìš”!"],
      "targetLanguage": "en"
    }'
  echo ""
done
```