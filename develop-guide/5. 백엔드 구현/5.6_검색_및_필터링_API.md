# ğŸ” 5.6 ê²€ìƒ‰ ë° í•„í„°ë§ API

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ê²€ìƒ‰ API](#2-ê²€ìƒ‰-api)
3. [í•„í„°ë§ ì˜µì…˜](#3-í•„í„°ë§-ì˜µì…˜)
4. [PostgreSQL ê²€ìƒ‰](#4-postgresql-ê²€ìƒ‰)
5. [ê²€ì¦](#5-ê²€ì¦)

## 1. ê°œìš”

PostgreSQLì˜ ê°•ë ¥í•œ ê²€ìƒ‰ ê¸°ëŠ¥ì„ í™œìš©í•œ ê²€ìƒ‰ ë° í•„í„°ë§ APIë¥¼ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ì „ë¬¸ ê²€ìƒ‰ (Full-Text Search)
- âœ… PostGIS ìœ„ì¹˜ ê¸°ë°˜ í•„í„°
- âœ… ë‹¤ì¤‘ ì¡°ê±´ í•„í„°ë§

## 2. ê²€ìƒ‰ API

### [í•„ìˆ˜] ê²€ìƒ‰ ë¼ìš°íŠ¸
```python
# íŒŒì¼: backend/routes/search_routes.py
from flask import Blueprint, request, jsonify
from ..services.search_service import SearchService
from ..middleware.auth import optional_auth

search_bp = Blueprint('search', __name__, url_prefix='/api/search')
search_service = SearchService()

# GET /api/search/feeds - í”¼ë“œ í†µí•© ê²€ìƒ‰
@search_bp.route('/feeds', methods=['GET'])
@optional_auth
def search_feeds():
    """í”¼ë“œ í†µí•© ê²€ìƒ‰"""
    try:
        # ê²€ìƒ‰ íŒŒë¼ë¯¸í„°
        params = {
            'query': request.args.get('q', ''),
            'category': request.args.get('category'),
            'tags': request.args.getlist('tags'),
            'min_price': request.args.get('min_price', type=int),
            'max_price': request.args.get('max_price', type=int),
            'lat': request.args.get('lat', type=float),
            'lng': request.args.get('lng', type=float),
            'radius_km': request.args.get('radius', 5.0, type=float),
            'verified_only': request.args.get('verified_only', 'false').lower() == 'true',
            'sort_by': request.args.get('sort_by', 'relevance'),
            'page': request.args.get('page', 1, type=int),
            'limit': request.args.get('limit', 20, type=int)
        }
        
        results = search_service.search_feeds(
            **params,
            user_id=request.user_id
        )
        
        return jsonify(results), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# GET /api/search/stores - ì í¬ ê²€ìƒ‰
@search_bp.route('/stores', methods=['GET'])
def search_stores():
    """ì í¬ ê²€ìƒ‰"""
    try:
        params = {
            'query': request.args.get('q', ''),
            'lat': request.args.get('lat', type=float),
            'lng': request.args.get('lng', type=float),
            'radius_km': request.args.get('radius', 5.0, type=float),
            'verified_only': request.args.get('verified_only', 'false').lower() == 'true',
            'page': request.args.get('page', 1, type=int),
            'limit': request.args.get('limit', 20, type=int)
        }
        
        results = search_service.search_stores(**params)
        
        return jsonify(results), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# GET /api/search/menus - ë©”ë‰´ ê²€ìƒ‰
@search_bp.route('/menus', methods=['GET'])
def search_menus():
    """ë©”ë‰´ ê²€ìƒ‰"""
    try:
        params = {
            'query': request.args.get('q', ''),
            'category': request.args.get('category'),
            'min_price': request.args.get('min_price', type=int),
            'max_price': request.args.get('max_price', type=int),
            'store_id': request.args.get('store_id'),
            'page': request.args.get('page', 1, type=int),
            'limit': request.args.get('limit', 20, type=int)
        }
        
        results = search_service.search_menus(**params)
        
        return jsonify(results), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# GET /api/search/suggest - ê²€ìƒ‰ì–´ ìë™ì™„ì„±
@search_bp.route('/suggest', methods=['GET'])
def search_suggest():
    """ê²€ìƒ‰ì–´ ìë™ì™„ì„±"""
    try:
        query = request.args.get('q', '')
        type = request.args.get('type', 'all')  # all, menu, store, tag
        
        suggestions = search_service.get_suggestions(query, type)
        
        return jsonify(suggestions), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

## 3. í•„í„°ë§ ì˜µì…˜

### [í•„ìˆ˜] ê²€ìƒ‰ ì„œë¹„ìŠ¤ êµ¬í˜„
```python
# íŒŒì¼: backend/services/search_service.py
from supabase import create_client
from typing import Dict, List, Optional
import os

class SearchService:
    def __init__(self):
        self.supabase = create_client(
            os.getenv('SUPABASE_URL'),
            os.getenv('SUPABASE_ANON_KEY')
        )
    
    def search_feeds(self, **kwargs) -> Dict:
        """í”¼ë“œ í†µí•© ê²€ìƒ‰"""
        query = kwargs.get('query', '')
        category = kwargs.get('category')
        tags = kwargs.get('tags', [])
        min_price = kwargs.get('min_price')
        max_price = kwargs.get('max_price')
        lat = kwargs.get('lat')
        lng = kwargs.get('lng')
        radius_km = kwargs.get('radius_km', 5.0)
        verified_only = kwargs.get('verified_only', False)
        sort_by = kwargs.get('sort_by', 'relevance')
        page = kwargs.get('page', 1)
        limit = kwargs.get('limit', 20)
        user_id = kwargs.get('user_id')
        
        # ê¸°ë³¸ ì¿¼ë¦¬
        query_builder = self.supabase.table('feeds').select(
            '*, store:stores!inner(*), user:users!inner(*)'
        )
        
        # ì „ë¬¸ ê²€ìƒ‰
        if query:
            query_builder = query_builder.text_search(
                'search_vector',
                query,
                config='korean'
            )
        
        # ì¹´í…Œê³ ë¦¬ í•„í„°
        if category:
            query_builder = query_builder.eq('category', category)
        
        # íƒœê·¸ í•„í„° (ë°°ì—´ í¬í•¨ ê²€ìƒ‰)
        if tags:
            query_builder = query_builder.contains('tags', tags)
        
        # ê°€ê²© ë²”ìœ„
        if min_price is not None:
            query_builder = query_builder.gte('price', min_price)
        if max_price is not None:
            query_builder = query_builder.lte('price', max_price)
        
        # ì¸ì¦ ë§›ì§‘ë§Œ
        if verified_only:
            query_builder = query_builder.eq('store.is_verified', True)
        
        # ìœ„ì¹˜ ê¸°ë°˜ í•„í„° (RPC í•¨ìˆ˜ ì‚¬ìš©)
        if lat and lng:
            # PostGIS í•¨ìˆ˜ í˜¸ì¶œ
            response = self.supabase.rpc('search_feeds_nearby', {
                'search_query': query,
                'user_lat': lat,
                'user_lng': lng,
                'radius_km': radius_km,
                'filters': {
                    'category': category,
                    'tags': tags,
                    'min_price': min_price,
                    'max_price': max_price,
                    'verified_only': verified_only
                },
                'sort_by': sort_by,
                'page': page,
                'limit': limit
            }).execute()
            
            return {
                'feeds': response.data.get('feeds', []),
                'total': response.data.get('total', 0),
                'page': page,
                'limit': limit
            }
        
        # ì •ë ¬
        if sort_by == 'latest':
            query_builder = query_builder.order('created_at', desc=True)
        elif sort_by == 'popular':
            query_builder = query_builder.order('like_count', desc=True)
        elif sort_by == 'price_low':
            query_builder = query_builder.order('price')
        elif sort_by == 'price_high':
            query_builder = query_builder.order('price', desc=True)
        
        # í˜ì´ì§•
        offset = (page - 1) * limit
        query_builder = query_builder.range(offset, offset + limit - 1)
        
        # ì‹¤í–‰
        response = query_builder.execute()
        
        # ì „ì²´ ê°œìˆ˜ ì¡°íšŒ
        count_response = self.supabase.table('feeds').select(
            'id', count='exact'
        ).execute()
        
        return {
            'feeds': response.data,
            'total': count_response.count,
            'page': page,
            'limit': limit
        }
    
    def search_stores(self, **kwargs) -> Dict:
        """ì í¬ ê²€ìƒ‰"""
        query = kwargs.get('query', '')
        lat = kwargs.get('lat')
        lng = kwargs.get('lng')
        radius_km = kwargs.get('radius_km', 5.0)
        verified_only = kwargs.get('verified_only', False)
        page = kwargs.get('page', 1)
        limit = kwargs.get('limit', 20)
        
        if lat and lng:
            # ìœ„ì¹˜ ê¸°ë°˜ ê²€ìƒ‰ (RPC)
            response = self.supabase.rpc('search_stores_nearby', {
                'search_query': query,
                'user_lat': lat,
                'user_lng': lng,
                'radius_km': radius_km,
                'verified_only': verified_only,
                'page': page,
                'limit': limit
            }).execute()
            
            return response.data
        else:
            # ì¼ë°˜ ê²€ìƒ‰
            query_builder = self.supabase.table('stores').select('*')
            
            if query:
                query_builder = query_builder.ilike('name', f'%{query}%')
            
            if verified_only:
                query_builder = query_builder.eq('is_verified', True)
            
            offset = (page - 1) * limit
            query_builder = query_builder.range(offset, offset + limit - 1)
            
            response = query_builder.execute()
            
            return {
                'stores': response.data,
                'page': page,
                'limit': limit
            }
    
    def search_menus(self, **kwargs) -> Dict:
        """ë©”ë‰´ ê²€ìƒ‰"""
        query = kwargs.get('query', '')
        category = kwargs.get('category')
        min_price = kwargs.get('min_price')
        max_price = kwargs.get('max_price')
        store_id = kwargs.get('store_id')
        page = kwargs.get('page', 1)
        limit = kwargs.get('limit', 20)
        
        query_builder = self.supabase.table('menus').select('*')
        
        if query:
            query_builder = query_builder.ilike('name', f'%{query}%')
        
        if category:
            query_builder = query_builder.eq('category', category)
        
        if min_price is not None:
            query_builder = query_builder.gte('price', min_price)
        if max_price is not None:
            query_builder = query_builder.lte('price', max_price)
        
        if store_id:
            query_builder = query_builder.eq('store_id', store_id)
        
        offset = (page - 1) * limit
        query_builder = query_builder.range(offset, offset + limit - 1)
        
        response = query_builder.execute()
        
        return {
            'menus': response.data,
            'page': page,
            'limit': limit
        }
    
    def get_suggestions(self, query: str, type: str = 'all') -> Dict:
        """ê²€ìƒ‰ì–´ ìë™ì™„ì„±"""
        if len(query) < 2:
            return {'suggestions': []}
        
        suggestions = []
        
        # ë©”ë‰´ ì œì•ˆ
        if type in ['all', 'menu']:
            menu_response = self.supabase.table('menus').select(
                'name'
            ).ilike('name', f'{query}%').limit(5).execute()
            
            for item in menu_response.data:
                suggestions.append({
                    'type': 'menu',
                    'text': item['name'],
                    'value': item['name']
                })
        
        # ì í¬ ì œì•ˆ
        if type in ['all', 'store']:
            store_response = self.supabase.table('stores').select(
                'name'
            ).ilike('name', f'{query}%').limit(5).execute()
            
            for item in store_response.data:
                suggestions.append({
                    'type': 'store',
                    'text': item['name'],
                    'value': item['name']
                })
        
        # íƒœê·¸ ì œì•ˆ
        if type in ['all', 'tag']:
            tag_response = self.supabase.table('tags').select(
                'name'
            ).ilike('name', f'{query}%').limit(5).execute()
            
            for item in tag_response.data:
                suggestions.append({
                    'type': 'tag',
                    'text': f"#{item['name']}",
                    'value': item['name']
                })
        
        return {'suggestions': suggestions[:10]}
```

## 4. PostgreSQL ê²€ìƒ‰

### [í•„ìˆ˜] ë°ì´í„°ë² ì´ìŠ¤ í•¨ìˆ˜
```sql
-- íŒŒì¼: supabase/migrations/search_functions.sql

-- ì „ë¬¸ ê²€ìƒ‰ì„ ìœ„í•œ tsvector ì»¬ëŸ¼ ì¶”ê°€
ALTER TABLE feeds ADD COLUMN IF NOT EXISTS search_vector tsvector;
CREATE INDEX IF NOT EXISTS feeds_search_idx ON feeds USING gin(search_vector);

-- ê²€ìƒ‰ ë²¡í„° ì—…ë°ì´íŠ¸ íŠ¸ë¦¬ê±°
CREATE OR REPLACE FUNCTION update_feeds_search_vector()
RETURNS trigger AS $$
BEGIN
  NEW.search_vector := 
    setweight(to_tsvector('korean', coalesce(NEW.menu_name, '')), 'A') ||
    setweight(to_tsvector('korean', coalesce(NEW.content, '')), 'B') ||
    setweight(to_tsvector('korean', array_to_string(NEW.tags, ' ')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_feeds_search_vector_trigger
BEFORE INSERT OR UPDATE ON feeds
FOR EACH ROW
EXECUTE FUNCTION update_feeds_search_vector();

-- ìœ„ì¹˜ ê¸°ë°˜ í”¼ë“œ ê²€ìƒ‰ í•¨ìˆ˜
CREATE OR REPLACE FUNCTION search_feeds_nearby(
  search_query TEXT,
  user_lat DOUBLE PRECISION,
  user_lng DOUBLE PRECISION,
  radius_km DOUBLE PRECISION,
  filters JSONB,
  sort_by TEXT,
  page INTEGER,
  limit INTEGER
)
RETURNS JSONB AS $$
DECLARE
  offset_val INTEGER;
  total_count INTEGER;
  result_feeds JSONB;
BEGIN
  offset_val := (page - 1) * limit;
  
  -- ê²€ìƒ‰ ì‹¤í–‰
  WITH filtered_feeds AS (
    SELECT 
      f.*,
      s.name as store_name,
      s.address as store_address,
      s.is_verified as store_verified,
      ST_Distance(
        ST_MakePoint(s.lng, s.lat)::geography,
        ST_MakePoint(user_lng, user_lat)::geography
      ) / 1000 as distance_km,
      u.nickname as user_nickname,
      u.user_level as user_level
    FROM feeds f
    JOIN stores s ON f.store_id = s.id
    JOIN users u ON f.user_id = u.id
    WHERE 
      -- ê±°ë¦¬ í•„í„°
      ST_DWithin(
        ST_MakePoint(s.lng, s.lat)::geography,
        ST_MakePoint(user_lng, user_lat)::geography,
        radius_km * 1000
      )
      -- ì „ë¬¸ ê²€ìƒ‰
      AND (search_query = '' OR 
           f.search_vector @@ plainto_tsquery('korean', search_query))
      -- ì¹´í…Œê³ ë¦¬ í•„í„°
      AND (filters->>'category' IS NULL OR 
           f.category = filters->>'category')
      -- ê°€ê²© í•„í„°
      AND (filters->>'min_price' IS NULL OR 
           f.price >= (filters->>'min_price')::INTEGER)
      AND (filters->>'max_price' IS NULL OR 
           f.price <= (filters->>'max_price')::INTEGER)
      -- ì¸ì¦ ë§›ì§‘ í•„í„°
      AND (filters->>'verified_only' = 'false' OR 
           s.is_verified = true)
  )
  SELECT 
    COUNT(*) INTO total_count
  FROM filtered_feeds;
  
  -- ì •ë ¬ ë° í˜ì´ì§•
  SELECT jsonb_agg(
    jsonb_build_object(
      'id', id,
      'menu_name', menu_name,
      'content', content,
      'price', price,
      'category', category,
      'tags', tags,
      'image_urls', image_urls,
      'like_count', like_count,
      'created_at', created_at,
      'distance_km', distance_km,
      'store', jsonb_build_object(
        'id', store_id,
        'name', store_name,
        'address', store_address,
        'is_verified', store_verified
      ),
      'user', jsonb_build_object(
        'id', user_id,
        'nickname', user_nickname,
        'level', user_level
      )
    )
    ORDER BY
      CASE 
        WHEN sort_by = 'distance' THEN distance_km
        WHEN sort_by = 'price_low' THEN price
        ELSE NULL
      END ASC,
      CASE
        WHEN sort_by = 'latest' THEN created_at
        WHEN sort_by = 'popular' THEN like_count
        WHEN sort_by = 'price_high' THEN price
        ELSE NULL
      END DESC
    LIMIT limit
    OFFSET offset_val
  ) INTO result_feeds
  FROM filtered_feeds;
  
  RETURN jsonb_build_object(
    'feeds', COALESCE(result_feeds, '[]'::jsonb),
    'total', total_count,
    'page', page,
    'limit', limit
  );
END;
$$ LANGUAGE plpgsql;

-- ìœ„ì¹˜ ê¸°ë°˜ ì í¬ ê²€ìƒ‰ í•¨ìˆ˜
CREATE OR REPLACE FUNCTION search_stores_nearby(
  search_query TEXT,
  user_lat DOUBLE PRECISION,
  user_lng DOUBLE PRECISION,
  radius_km DOUBLE PRECISION,
  verified_only BOOLEAN,
  page INTEGER,
  limit INTEGER
)
RETURNS JSONB AS $$
DECLARE
  offset_val INTEGER;
BEGIN
  offset_val := (page - 1) * limit;
  
  RETURN (
    SELECT jsonb_build_object(
      'stores', jsonb_agg(
        jsonb_build_object(
          'id', id,
          'name', name,
          'address', address,
          'category', category,
          'is_verified', is_verified,
          'distance_km', distance_km,
          'feed_count', feed_count
        )
        ORDER BY distance_km ASC
        LIMIT limit
        OFFSET offset_val
      ),
      'page', page,
      'limit', limit
    )
    FROM (
      SELECT 
        s.id,
        s.name,
        s.address,
        s.category,
        s.is_verified,
        ST_Distance(
          ST_MakePoint(s.lng, s.lat)::geography,
          ST_MakePoint(user_lng, user_lat)::geography
        ) / 1000 as distance_km,
        COUNT(f.id) as feed_count
      FROM stores s
      LEFT JOIN feeds f ON s.id = f.store_id
      WHERE 
        ST_DWithin(
          ST_MakePoint(s.lng, s.lat)::geography,
          ST_MakePoint(user_lng, user_lat)::geography,
          radius_km * 1000
        )
        AND (search_query = '' OR s.name ILIKE '%' || search_query || '%')
        AND (verified_only = false OR s.is_verified = true)
      GROUP BY s.id
    ) as filtered_stores
  );
END;
$$ LANGUAGE plpgsql;
```

## 5. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì „ë¬¸ ê²€ìƒ‰ ì¸ë±ìŠ¤ ìƒì„± í™•ì¸
- [ ] PostGIS í™•ì¥ ì„¤ì¹˜ ë° ê³µê°„ ì¸ë±ìŠ¤ ìƒì„±
- [ ] ê²€ìƒ‰ API ì‘ë‹µ ì‹œê°„ < 200ms
- [ ] ìë™ì™„ì„± ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] í˜ì´ì§• ë° ì •ë ¬ ë™ì‘ í™•ì¸