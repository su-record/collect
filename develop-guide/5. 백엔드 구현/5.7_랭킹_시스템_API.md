# ğŸ“Š 5.7 ë­í‚¹ ì‹œìŠ¤í…œ API

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ë­í‚¹ API](#2-ë­í‚¹-api)
3. [ë­í‚¹ ê³„ì‚°](#3-ë­í‚¹-ê³„ì‚°)
4. [ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸](#4-ì‹¤ì‹œê°„-ì—…ë°ì´íŠ¸)
5. [ê²€ì¦](#5-ê²€ì¦)

## 1. ê°œìš”

PostgreSQLì˜ ì§‘ê³„ í•¨ìˆ˜ë¥¼ í™œìš©í•œ íš¨ìœ¨ì ì¸ ë­í‚¹ ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… Materialized View í™œìš©
- âœ… ì¹´í…Œê³ ë¦¬ë³„/ì§€ì—­ë³„ ë­í‚¹
- âœ… ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ë°˜ì˜

## 2. ë­í‚¹ API

### [í•„ìˆ˜] ë­í‚¹ ë¼ìš°íŠ¸
```python
# íŒŒì¼: backend/routes/ranking_routes.py
from flask import Blueprint, request, jsonify
from ..services.ranking_service import RankingService

ranking_bp = Blueprint('rankings', __name__, url_prefix='/api/rankings')
ranking_service = RankingService()

# GET /api/rankings/menus - ë©”ë‰´ ë­í‚¹
@ranking_bp.route('/menus', methods=['GET'])
def get_menu_rankings():
    """ë©”ë‰´ ë­í‚¹ ì¡°íšŒ"""
    try:
        params = {
            'category': request.args.get('category'),
            'lat': request.args.get('lat', type=float),
            'lng': request.args.get('lng', type=float),
            'radius_km': request.args.get('radius', 5.0, type=float),
            'period': request.args.get('period', 'weekly'),  # daily, weekly, monthly
            'limit': request.args.get('limit', 10, type=int)
        }
        
        rankings = ranking_service.get_menu_rankings(**params)
        
        return jsonify(rankings), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# GET /api/rankings/stores - ì í¬ ë­í‚¹
@ranking_bp.route('/stores', methods=['GET'])
def get_store_rankings():
    """ì í¬ ë­í‚¹ ì¡°íšŒ"""
    try:
        params = {
            'lat': request.args.get('lat', type=float),
            'lng': request.args.get('lng', type=float),
            'radius_km': request.args.get('radius', 5.0, type=float),
            'limit': request.args.get('limit', 10, type=int)
        }
        
        rankings = ranking_service.get_store_rankings(**params)
        
        return jsonify(rankings), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# GET /api/rankings/trending - íŠ¸ë Œë”©
@ranking_bp.route('/trending', methods=['GET'])
def get_trending():
    """ê¸‰ìƒìŠ¹ íŠ¸ë Œë“œ"""
    try:
        params = {
            'type': request.args.get('type', 'menus'),  # menus, stores, tags
            'lat': request.args.get('lat', type=float),
            'lng': request.args.get('lng', type=float),
            'radius_km': request.args.get('radius', 5.0, type=float),
            'hours': request.args.get('hours', 24, type=int),
            'limit': request.args.get('limit', 10, type=int)
        }
        
        trending = ranking_service.get_trending(**params)
        
        return jsonify(trending), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# GET /api/rankings/categories - ì¹´í…Œê³ ë¦¬ë³„ ë­í‚¹
@ranking_bp.route('/categories', methods=['GET'])
def get_category_rankings():
    """ì¹´í…Œê³ ë¦¬ë³„ ë©”ë‰´ ë­í‚¹"""
    try:
        categories = ['í•œì‹', 'ì¤‘ì‹', 'ì¼ì‹', 'ì–‘ì‹', 'ë¶„ì‹', 'ì¹´í˜/ë””ì €íŠ¸']
        lat = request.args.get('lat', type=float)
        lng = request.args.get('lng', type=float)
        radius_km = request.args.get('radius', 5.0, type=float)
        
        results = {}
        for category in categories:
            rankings = ranking_service.get_menu_rankings(
                category=category,
                lat=lat,
                lng=lng,
                radius_km=radius_km,
                limit=5
            )
            results[category] = rankings['rankings']
        
        return jsonify(results), 200
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

## 3. ë­í‚¹ ê³„ì‚°

### [í•„ìˆ˜] RankingService êµ¬í˜„
```python
# íŒŒì¼: backend/services/ranking_service.py
from supabase import create_client
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import os

class RankingService:
    def __init__(self):
        self.supabase = create_client(
            os.getenv('SUPABASE_URL'),
            os.getenv('SUPABASE_SERVICE_ROLE_KEY')
        )
    
    def get_menu_rankings(
        self,
        category: Optional[str] = None,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        radius_km: float = 5.0,
        period: str = 'weekly',
        limit: int = 10
    ) -> Dict:
        """ë©”ë‰´ ë­í‚¹ ì¡°íšŒ"""
        # ê¸°ê°„ ì„¤ì •
        period_days = {
            'daily': 1,
            'weekly': 7,
            'monthly': 30
        }
        days = period_days.get(period, 7)
        since_date = datetime.now() - timedelta(days=days)
        
        # ìœ„ì¹˜ í•„í„°ê°€ ìˆëŠ” ê²½ìš°
        if lat and lng:
            response = self.supabase.rpc(
                'get_menu_rankings_by_location',
                {
                    'user_lat': lat,
                    'user_lng': lng,
                    'radius_km': radius_km,
                    'category_filter': category,
                    'since_date': since_date.isoformat(),
                    'limit_count': limit
                }
            ).execute()
        else:
            # ì „ì²´ ë­í‚¹
            query = self.supabase.table('menu_rankings') \
                .select('*')
            
            if category:
                query = query.eq('category', category)
            
            response = query \
                .order('ranking_score', desc=True) \
                .limit(limit) \
                .execute()
        
        rankings = []
        for idx, item in enumerate(response.data):
            rankings.append({
                'rank': idx + 1,
                'menu_id': item['menu_id'],
                'menu_name': item['menu_name'],
                'category': item['category'],
                'price': item['price'],
                'store_name': item['store_name'],
                'store_id': item['store_id'],
                'feed_count': item['feed_count'],
                'total_recommendations': item['total_recommendations'],
                'score': item['ranking_score']
            })
        
        return {
            'rankings': rankings,
            'period': period,
            'category': category
        }
    
    def get_store_rankings(
        self,
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        radius_km: float = 5.0,
        limit: int = 10
    ) -> Dict:
        """ì í¬ ë­í‚¹ ì¡°íšŒ"""
        # ì í¬ë³„ í†µê³„ ê³„ì‚°
        response = self.supabase.rpc(
            'get_store_rankings',
            {
                'user_lat': lat,
                'user_lng': lng,
                'radius_km': radius_km if lat and lng else None,
                'limit_count': limit
            }
        ).execute()
        
        rankings = []
        for idx, store in enumerate(response.data):
            rankings.append({
                'rank': idx + 1,
                'store_id': store['store_id'],
                'store_name': store['store_name'],
                'address': store['address'],
                'is_verified': store['is_verified'],
                'menu_count': store['menu_count'],
                'total_feeds': store['total_feeds'],
                'total_recommendations': store['total_recommendations'],
                'score': store['ranking_score']
            })
        
        return {'rankings': rankings}
    
    def get_trending(
        self,
        type: str = 'menus',
        lat: Optional[float] = None,
        lng: Optional[float] = None,
        radius_km: float = 5.0,
        hours: int = 24,
        limit: int = 10
    ) -> List[Dict]:
        """ê¸‰ìƒìŠ¹ íŠ¸ë Œë“œ"""
        since_time = datetime.now() - timedelta(hours=hours)
        
        if type == 'menus':
            return self._get_trending_menus(
                lat, lng, radius_km, since_time, limit
            )
        elif type == 'stores':
            return self._get_trending_stores(
                lat, lng, radius_km, since_time, limit
            )
        elif type == 'tags':
            return self._get_trending_tags(
                since_time, limit
            )
        else:
            return []
    
    def _get_trending_menus(
        self,
        lat: Optional[float],
        lng: Optional[float],
        radius_km: float,
        since_time: datetime,
        limit: int
    ) -> List[Dict]:
        """ê¸‰ìƒìŠ¹ ë©”ë‰´"""
        response = self.supabase.rpc(
            'get_trending_menus',
            {
                'since_time': since_time.isoformat(),
                'user_lat': lat,
                'user_lng': lng,
                'radius_km': radius_km if lat and lng else None,
                'limit_count': limit
            }
        ).execute()
        
        trending = []
        for item in response.data:
            trending.append({
                'menu_id': item['menu_id'],
                'menu_name': item['menu_name'],
                'store_name': item['store_name'],
                'recent_feeds': item['recent_feeds'],
                'growth_rate': item['growth_rate'],
                'trend_score': item['trend_score']
            })
        
        return trending
    
    def _get_trending_stores(
        self,
        lat: Optional[float],
        lng: Optional[float],
        radius_km: float,
        since_time: datetime,
        limit: int
    ) -> List[Dict]:
        """ê¸‰ìƒìŠ¹ ì í¬"""
        response = self.supabase.rpc(
            'get_trending_stores',
            {
                'since_time': since_time.isoformat(),
                'user_lat': lat,
                'user_lng': lng,
                'radius_km': radius_km if lat and lng else None,
                'limit_count': limit
            }
        ).execute()
        
        return response.data
    
    def _get_trending_tags(
        self,
        since_time: datetime,
        limit: int
    ) -> List[Dict]:
        """ì¸ê¸° íƒœê·¸"""
        response = self.supabase.rpc(
            'get_trending_tags',
            {
                'since_time': since_time.isoformat(),
                'limit_count': limit
            }
        ).execute()
        
        return response.data
```

## 4. ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸

### [í•„ìˆ˜] ë­í‚¹ ê³„ì‚° í•¨ìˆ˜
```sql
-- íŒŒì¼: functions/ranking_functions.sql

-- ì í¬ ë­í‚¹ ê³„ì‚°
CREATE OR REPLACE FUNCTION get_store_rankings(
    user_lat FLOAT DEFAULT NULL,
    user_lng FLOAT DEFAULT NULL,
    radius_km FLOAT DEFAULT NULL,
    limit_count INT DEFAULT 10
)
RETURNS TABLE (
    store_id UUID,
    store_name TEXT,
    address TEXT,
    is_verified BOOLEAN,
    menu_count BIGINT,
    total_feeds BIGINT,
    total_recommendations BIGINT,
    ranking_score FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH store_stats AS (
        SELECT 
            s.id,
            s.name,
            s.address,
            s.is_verified,
            s.location,
            COUNT(DISTINCT m.id) AS menu_count,
            COUNT(DISTINCT f.id) AS total_feeds,
            SUM(f.recommendation_count) AS total_recommendations
        FROM stores s
        LEFT JOIN menus m ON m.store_id = s.id
        LEFT JOIN feeds f ON f.store_id = s.id
        WHERE f.created_at > NOW() - INTERVAL '30 days'
        GROUP BY s.id, s.name, s.address, s.is_verified, s.location
    )
    SELECT 
        ss.id AS store_id,
        ss.name AS store_name,
        ss.address,
        ss.is_verified,
        ss.menu_count,
        ss.total_feeds,
        ss.total_recommendations,
        (
            COALESCE(ss.total_feeds, 0) * 0.3 +
            COALESCE(ss.total_recommendations, 0) * 0.5 +
            COALESCE(ss.menu_count, 0) * 0.2 +
            CASE WHEN ss.is_verified THEN 100 ELSE 0 END
        ) AS ranking_score
    FROM store_stats ss
    WHERE (user_lat IS NULL OR user_lng IS NULL OR radius_km IS NULL) OR
          ST_DWithin(
              ss.location,
              ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography,
              radius_km * 1000
          )
    ORDER BY ranking_score DESC
    LIMIT limit_count;
END;
$$;

-- ê¸‰ìƒìŠ¹ ë©”ë‰´ ê³„ì‚°
CREATE OR REPLACE FUNCTION get_trending_menus(
    since_time TIMESTAMPTZ,
    user_lat FLOAT DEFAULT NULL,
    user_lng FLOAT DEFAULT NULL,
    radius_km FLOAT DEFAULT NULL,
    limit_count INT DEFAULT 10
)
RETURNS TABLE (
    menu_id UUID,
    menu_name TEXT,
    store_name TEXT,
    recent_feeds BIGINT,
    growth_rate FLOAT,
    trend_score FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    WITH recent_stats AS (
        SELECT 
            m.id AS menu_id,
            m.name AS menu_name,
            s.name AS store_name,
            COUNT(f.id) AS recent_feeds,
            SUM(f.recommendation_count) AS recent_recommendations
        FROM feeds f
        JOIN menus m ON m.id = f.menu_id
        JOIN stores s ON s.id = f.store_id
        WHERE f.created_at > since_time
        GROUP BY m.id, m.name, s.name
    ),
    previous_stats AS (
        SELECT 
            m.id AS menu_id,
            COUNT(f.id) AS previous_feeds
        FROM feeds f
        JOIN menus m ON m.id = f.menu_id
        WHERE f.created_at BETWEEN since_time - INTERVAL '7 days' AND since_time
        GROUP BY m.id
    )
    SELECT 
        rs.menu_id,
        rs.menu_name,
        rs.store_name,
        rs.recent_feeds,
        CASE 
            WHEN COALESCE(ps.previous_feeds, 0) = 0 THEN 100.0
            ELSE (rs.recent_feeds::FLOAT / ps.previous_feeds - 1) * 100
        END AS growth_rate,
        rs.recent_feeds * 0.6 + rs.recent_recommendations * 0.4 AS trend_score
    FROM recent_stats rs
    LEFT JOIN previous_stats ps ON ps.menu_id = rs.menu_id
    ORDER BY trend_score DESC
    LIMIT limit_count;
END;
$$;
```

### [ì„ íƒ] ë­í‚¹ ìºì‹±
```python
# íŒŒì¼: backend/services/ranking_service.py (ì¶”ê°€)

def refresh_rankings(self):
    """ë­í‚¹ Materialized View ê°±ì‹ """
    try:
        # Materialized View ê°±ì‹ 
        self.supabase.rpc('refresh_menu_rankings').execute()
        
        # ìºì‹œ ë¬´íš¨í™”
        self._invalidate_ranking_cache()
        
        return {'message': 'ë­í‚¹ì´ ê°±ì‹ ë˜ì—ˆìŠµë‹ˆë‹¤'}
        
    except Exception as e:
        raise Exception(f'ë­í‚¹ ê°±ì‹  ì‹¤íŒ¨: {str(e)}')

def _invalidate_ranking_cache(self):
    """ë­í‚¹ ìºì‹œ ë¬´íš¨í™”"""
    # Redis ë˜ëŠ” ë©”ëª¨ë¦¬ ìºì‹œ ì‚¬ìš© ì‹œ
    # cache.delete_pattern('rankings:*')
    pass

def get_cached_rankings(self, cache_key: str) -> Optional[Dict]:
    """ìºì‹œëœ ë­í‚¹ ì¡°íšŒ"""
    # ìºì‹œ êµ¬í˜„
    # return cache.get(cache_key)
    return None

def set_cached_rankings(self, cache_key: str, data: Dict, ttl: int = 300):
    """ë­í‚¹ ìºì‹œ ì €ì¥ (5ë¶„)"""
    # cache.set(cache_key, data, ttl)
    pass
```

## 5. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ë©”ë‰´ ë­í‚¹ ì¡°íšŒ
- [ ] ì í¬ ë­í‚¹ ì¡°íšŒ
- [ ] íŠ¸ë Œë”© ê³„ì‚°
- [ ] ìœ„ì¹˜ ê¸°ë°˜ í•„í„°
- [ ] ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸

### ğŸ§ª API í…ŒìŠ¤íŠ¸
```python
# íŒŒì¼: tests/test_ranking_api.py
import pytest

def test_menu_rankings(client):
    """ë©”ë‰´ ë­í‚¹ í…ŒìŠ¤íŠ¸"""
    response = client.get('/api/rankings/menus?category=í•œì‹')
    
    assert response.status_code == 200
    data = response.get_json()
    assert 'rankings' in data
    assert len(data['rankings']) <= 10
    
    # ë­í‚¹ ìˆœì„œ í™•ì¸
    for i in range(1, len(data['rankings'])):
        assert data['rankings'][i-1]['score'] >= data['rankings'][i]['score']

def test_location_based_rankings(client):
    """ìœ„ì¹˜ ê¸°ë°˜ ë­í‚¹ í…ŒìŠ¤íŠ¸"""
    response = client.get(
        '/api/rankings/menus?lat=37.5665&lng=126.9780&radius=3'
    )
    
    assert response.status_code == 200
    data = response.get_json()
    assert 'rankings' in data

def test_trending_menus(client):
    """íŠ¸ë Œë”© ë©”ë‰´ í…ŒìŠ¤íŠ¸"""
    response = client.get('/api/rankings/trending?type=menus&hours=24')
    
    assert response.status_code == 200
    trending = response.get_json()
    assert isinstance(trending, list)
    
    # íŠ¸ë Œë“œ ìŠ¤ì½”ì–´ í™•ì¸
    for item in trending:
        assert 'trend_score' in item
        assert 'growth_rate' in item

def test_category_rankings(client):
    """ì¹´í…Œê³ ë¦¬ë³„ ë­í‚¹ í…ŒìŠ¤íŠ¸"""
    response = client.get('/api/rankings/categories')
    
    assert response.status_code == 200
    data = response.get_json()
    
    # ê° ì¹´í…Œê³ ë¦¬ë³„ ë­í‚¹ í™•ì¸
    for category in ['í•œì‹', 'ì¤‘ì‹', 'ì¼ì‹']:
        assert category in data
        assert isinstance(data[category], list)
```