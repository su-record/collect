# ğŸ–¼ï¸ 5.8 ì´ë¯¸ì§€ ì—…ë¡œë“œ ì²˜ë¦¬

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ì´ë¯¸ì§€ ì••ì¶•](#2-ì´ë¯¸ì§€-ì••ì¶•)
3. [ì—…ë¡œë“œ API](#3-ì—…ë¡œë“œ-api)
4. [Supabase Storage](#4-supabase-storage)
5. [ê²€ì¦](#5-ê²€ì¦)

## 1. ê°œìš”

Supabase Storageë¥¼ í™œìš©í•œ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… í´ë¼ì´ì–¸íŠ¸ ì´ë¯¸ì§€ ì••ì¶•
- âœ… Supabase Storage ì§ì ‘ ì—…ë¡œë“œ
- âœ… CDN URL ìë™ ìƒì„±

## 2. ì´ë¯¸ì§€ ì••ì¶•

### [í•„ìˆ˜] Flutter ì´ë¯¸ì§€ ì••ì¶•
```dart
// íŒŒì¼: lib/services/image_service.dart
import 'dart:io';
import 'dart:typed_data';
import 'package:image/image.dart' as img;
import 'package:image_picker/image_picker.dart';
import 'package:path/path.dart' as path;

class ImageService {
  static const int maxWidth = 1280;
  static const int maxHeight = 1280;
  static const int quality = 85;
  
  final ImagePicker _picker = ImagePicker();
  
  // ì¹´ë©”ë¼ ì´¬ì˜
  Future<File?> captureFromCamera() async {
    final XFile? photo = await _picker.pickImage(
      source: ImageSource.camera,
      maxWidth: maxWidth.toDouble(),
      maxHeight: maxHeight.toDouble(),
      imageQuality: quality,
    );
    
    if (photo == null) return null;
    
    return File(photo.path);
  }
  
  // ê°¤ëŸ¬ë¦¬ ì„ íƒ
  Future<List<File>> pickFromGallery({int maxImages = 5}) async {
    final List<XFile> images = await _picker.pickMultiImage(
      maxWidth: maxWidth.toDouble(),
      maxHeight: maxHeight.toDouble(),
      imageQuality: quality,
    );
    
    if (images.isEmpty) return [];
    
    // ìµœëŒ€ ê°œìˆ˜ ì œí•œ
    final selectedImages = images.take(maxImages).toList();
    
    return selectedImages.map((image) => File(image.path)).toList();
  }
  
  // ì´ë¯¸ì§€ ì••ì¶•
  Future<File> compressImage(File imageFile) async {
    final bytes = await imageFile.readAsBytes();
    final image = img.decodeImage(bytes);
    
    if (image == null) throw Exception('ì´ë¯¸ì§€ ë””ì½”ë”© ì‹¤íŒ¨');
    
    // ë¦¬ì‚¬ì´ì¦ˆ
    img.Image resized;
    if (image.width > maxWidth || image.height > maxHeight) {
      resized = img.copyResize(
        image,
        width: image.width > image.height ? maxWidth : null,
        height: image.height > image.width ? maxHeight : null,
      );
    } else {
      resized = image;
    }
    
    // ì••ì¶•
    final compressedBytes = img.encodeJpg(resized, quality: quality);
    
    // ì„ì‹œ íŒŒì¼ë¡œ ì €ì¥
    final tempDir = await Directory.systemTemp.createTemp('compressed_');
    final compressedFile = File(
      path.join(tempDir.path, 'compressed_${DateTime.now().millisecondsSinceEpoch}.jpg')
    );
    
    await compressedFile.writeAsBytes(compressedBytes);
    
    return compressedFile;
  }
  
  // ì´ë¯¸ì§€ ì •ë³´ ì¶”ì¶œ
  Map<String, dynamic> getImageInfo(File imageFile) {
    final bytes = imageFile.readAsBytesSync();
    final image = img.decodeImage(bytes);
    
    if (image == null) throw Exception('ì´ë¯¸ì§€ ì •ë³´ ì¶”ì¶œ ì‹¤íŒ¨');
    
    return {
      'width': image.width,
      'height': image.height,
      'size': bytes.length,
      'format': path.extension(imageFile.path),
    };
  }
}
```

### [í•„ìˆ˜] ì—…ë¡œë“œ ì§„í–‰ ìƒíƒœ ê´€ë¦¬
```dart
// íŒŒì¼: lib/providers/upload_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

// ì—…ë¡œë“œ ìƒíƒœ
class UploadState {
  final bool isUploading;
  final double progress;
  final String? error;
  final List<String> uploadedUrls;
  
  const UploadState({
    this.isUploading = false,
    this.progress = 0.0,
    this.error,
    this.uploadedUrls = const [],
  });
  
  UploadState copyWith({
    bool? isUploading,
    double? progress,
    String? error,
    List<String>? uploadedUrls,
  }) {
    return UploadState(
      isUploading: isUploading ?? this.isUploading,
      progress: progress ?? this.progress,
      error: error ?? this.error,
      uploadedUrls: uploadedUrls ?? this.uploadedUrls,
    );
  }
}

// ì—…ë¡œë“œ ìƒíƒœ í”„ë¡œë°”ì´ë”
class UploadNotifier extends StateNotifier<UploadState> {
  UploadNotifier() : super(const UploadState());
  
  void setProgress(double progress) {
    state = state.copyWith(progress: progress);
  }
  
  void setUploading(bool isUploading) {
    state = state.copyWith(isUploading: isUploading);
  }
  
  void setError(String? error) {
    state = state.copyWith(error: error);
  }
  
  void addUploadedUrl(String url) {
    state = state.copyWith(
      uploadedUrls: [...state.uploadedUrls, url],
    );
  }
  
  void reset() {
    state = const UploadState();
  }
}

final uploadProvider = StateNotifierProvider<UploadNotifier, UploadState>((ref) {
  return UploadNotifier();
});
```

## 3. ì—…ë¡œë“œ API

### [í•„ìˆ˜] Supabase Storage ì—…ë¡œë“œ
```dart
// íŒŒì¼: lib/services/storage_service.dart
import 'dart:io';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:uuid/uuid.dart';
import 'package:path/path.dart' as path;

class StorageService {
  final SupabaseClient _supabase = Supabase.instance.client;
  final _uuid = const Uuid();
  
  static const String feedBucket = 'feed-images';
  static const String profileBucket = 'profile-images';
  
  // í”¼ë“œ ì´ë¯¸ì§€ ì—…ë¡œë“œ
  Future<String> uploadFeedImage(File imageFile) async {
    try {
      // ê³ ìœ  íŒŒì¼ëª… ìƒì„±
      final fileName = _generateFileName(imageFile);
      final filePath = 'feeds/${DateTime.now().year}/${DateTime.now().month}/$fileName';
      
      // Supabase Storage ì—…ë¡œë“œ
      final response = await _supabase.storage
          .from(feedBucket)
          .upload(filePath, imageFile);
      
      if (response.isEmpty) {
        throw Exception('ì—…ë¡œë“œ ì‹¤íŒ¨');
      }
      
      // Public URL ìƒì„±
      final publicUrl = _supabase.storage
          .from(feedBucket)
          .getPublicUrl(filePath);
      
      return publicUrl;
      
    } catch (e) {
      throw Exception('ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨: $e');
    }
  }
  
  // ì—¬ëŸ¬ ì´ë¯¸ì§€ ì—…ë¡œë“œ
  Future<List<String>> uploadMultipleFeedImages(
    List<File> imageFiles,
    {Function(double)? onProgress}
  ) async {
    final urls = <String>[];
    final total = imageFiles.length;
    
    for (int i = 0; i < total; i++) {
      try {
        final url = await uploadFeedImage(imageFiles[i]);
        urls.add(url);
        
        // ì§„í–‰ë¥  ì½œë°±
        if (onProgress != null) {
          onProgress((i + 1) / total);
        }
      } catch (e) {
        // ì‹¤íŒ¨í•œ ì´ë¯¸ì§€ëŠ” ê±´ë„ˆë›°ê³  ê³„ì†
        print('ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨: $e');
      }
    }
    
    if (urls.isEmpty) {
      throw Exception('ëª¨ë“  ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨');
    }
    
    return urls;
  }
  
  // í”„ë¡œí•„ ì´ë¯¸ì§€ ì—…ë¡œë“œ
  Future<String> uploadProfileImage(File imageFile, String userId) async {
    try {
      final fileName = _generateFileName(imageFile);
      final filePath = 'profiles/$userId/$fileName';
      
      // ê¸°ì¡´ í”„ë¡œí•„ ì´ë¯¸ì§€ ì‚­ì œ
      await _deleteOldProfileImages(userId);
      
      // ìƒˆ ì´ë¯¸ì§€ ì—…ë¡œë“œ
      await _supabase.storage
          .from(profileBucket)
          .upload(filePath, imageFile);
      
      // Public URL ìƒì„±
      final publicUrl = _supabase.storage
          .from(profileBucket)
          .getPublicUrl(filePath);
      
      return publicUrl;
      
    } catch (e) {
      throw Exception('í”„ë¡œí•„ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹¤íŒ¨: $e');
    }
  }
  
  // ì´ë¯¸ì§€ ì‚­ì œ
  Future<void> deleteImage(String imageUrl) async {
    try {
      // URLì—ì„œ íŒŒì¼ ê²½ë¡œ ì¶”ì¶œ
      final uri = Uri.parse(imageUrl);
      final pathSegments = uri.pathSegments;
      
      // storage/v1/object/public/bucket-name/file-path í˜•ì‹
      if (pathSegments.length < 6) return;
      
      final bucket = pathSegments[4];
      final filePath = pathSegments.sublist(5).join('/');
      
      await _supabase.storage
          .from(bucket)
          .remove([filePath]);
          
    } catch (e) {
      print('ì´ë¯¸ì§€ ì‚­ì œ ì‹¤íŒ¨: $e');
    }
  }
  
  // íŒŒì¼ëª… ìƒì„±
  String _generateFileName(File file) {
    final ext = path.extension(file.path);
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final uuid = _uuid.v4().substring(0, 8);
    return '${timestamp}_$uuid$ext';
  }
  
  // ê¸°ì¡´ í”„ë¡œí•„ ì´ë¯¸ì§€ ì‚­ì œ
  Future<void> _deleteOldProfileImages(String userId) async {
    try {
      final files = await _supabase.storage
          .from(profileBucket)
          .list(path: 'profiles/$userId');
          
      if (files.isNotEmpty) {
        final filePaths = files
            .map((file) => 'profiles/$userId/${file.name}')
            .toList();
            
        await _supabase.storage
            .from(profileBucket)
            .remove(filePaths);
      }
    } catch (e) {
      print('ê¸°ì¡´ ì´ë¯¸ì§€ ì‚­ì œ ì‹¤íŒ¨: $e');
    }
  }
}
```

## 4. Supabase Storage

### [í•„ìˆ˜] Storage ì„¤ì • ë° ì •ì±…
```sql
-- íŒŒì¼: supabase/storage_policies.sql

-- feed-images ë²„í‚· ìƒì„±
INSERT INTO storage.buckets (id, name, public)
VALUES ('feed-images', 'feed-images', true);

-- profile-images ë²„í‚· ìƒì„±
INSERT INTO storage.buckets (id, name, public)
VALUES ('profile-images', 'profile-images', true);

-- feed-images ì •ì±…
CREATE POLICY "ëˆ„êµ¬ë‚˜ í”¼ë“œ ì´ë¯¸ì§€ ì¡°íšŒ ê°€ëŠ¥" 
ON storage.objects FOR SELECT 
USING (bucket_id = 'feed-images');

CREATE POLICY "ì¸ì¦ëœ ì‚¬ìš©ìë§Œ í”¼ë“œ ì´ë¯¸ì§€ ì—…ë¡œë“œ" 
ON storage.objects FOR INSERT 
WITH CHECK (
  bucket_id = 'feed-images' 
  AND auth.role() = 'authenticated'
);

CREATE POLICY "ë³¸ì¸ì´ ì—…ë¡œë“œí•œ í”¼ë“œ ì´ë¯¸ì§€ë§Œ ì‚­ì œ" 
ON storage.objects FOR DELETE 
USING (
  bucket_id = 'feed-images' 
  AND auth.uid()::text = (storage.foldername(name))[1]
);

-- profile-images ì •ì±…
CREATE POLICY "ëˆ„êµ¬ë‚˜ í”„ë¡œí•„ ì´ë¯¸ì§€ ì¡°íšŒ ê°€ëŠ¥" 
ON storage.objects FOR SELECT 
USING (bucket_id = 'profile-images');

CREATE POLICY "ë³¸ì¸ í”„ë¡œí•„ ì´ë¯¸ì§€ë§Œ ì—…ë¡œë“œ" 
ON storage.objects FOR INSERT 
WITH CHECK (
  bucket_id = 'profile-images' 
  AND auth.uid()::text = (storage.foldername(name))[2]
);

CREATE POLICY "ë³¸ì¸ í”„ë¡œí•„ ì´ë¯¸ì§€ë§Œ ì‚­ì œ" 
ON storage.objects FOR DELETE 
USING (
  bucket_id = 'profile-images' 
  AND auth.uid()::text = (storage.foldername(name))[2]
);
```

### [í•„ìˆ˜] ì´ë¯¸ì§€ ì—…ë¡œë“œ UI
```dart
// íŒŒì¼: lib/widgets/image_upload_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:io';

class ImageUploadWidget extends ConsumerStatefulWidget {
  final Function(List<String>) onUploadComplete;
  final int maxImages;
  
  const ImageUploadWidget({
    Key? key,
    required this.onUploadComplete,
    this.maxImages = 5,
  }) : super(key: key);
  
  @override
  ConsumerState<ImageUploadWidget> createState() => _ImageUploadWidgetState();
}

class _ImageUploadWidgetState extends ConsumerState<ImageUploadWidget> {
  final List<File> _selectedImages = [];
  
  @override
  Widget build(BuildContext context) {
    final uploadState = ref.watch(uploadProvider);
    
    return Column(
      children: [
        // ì´ë¯¸ì§€ ë¯¸ë¦¬ë³´ê¸°
        if (_selectedImages.isNotEmpty)
          SizedBox(
            height: 100,
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: _selectedImages.length + 1,
              itemBuilder: (context, index) {
                if (index == _selectedImages.length) {
                  // ì¶”ê°€ ë²„íŠ¼
                  return _buildAddButton();
                }
                return _buildImagePreview(index);
              },
            ),
          )
        else
          _buildAddButton(),
          
        const SizedBox(height: 16),
        
        // ì—…ë¡œë“œ ë²„íŠ¼
        if (_selectedImages.isNotEmpty && !uploadState.isUploading)
          ElevatedButton.icon(
            onPressed: _uploadImages,
            icon: const Icon(Icons.cloud_upload),
            label: const Text('ì—…ë¡œë“œ'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.orange,
              minimumSize: const Size(double.infinity, 48),
            ),
          ),
          
        // ì—…ë¡œë“œ ì§„í–‰ ìƒíƒœ
        if (uploadState.isUploading)
          Column(
            children: [
              LinearProgressIndicator(
                value: uploadState.progress,
                backgroundColor: Colors.grey[300],
                valueColor: const AlwaysStoppedAnimation<Color>(Colors.orange),
              ),
              const SizedBox(height: 8),
              Text('ì—…ë¡œë“œ ì¤‘... ${(uploadState.progress * 100).toInt()}%'),
            ],
          ),
          
        // ì—ëŸ¬ ë©”ì‹œì§€
        if (uploadState.error != null)
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              uploadState.error!,
              style: const TextStyle(color: Colors.red),
            ),
          ),
      ],
    );
  }
  
  Widget _buildAddButton() {
    return GestureDetector(
      onTap: _selectedImages.length < widget.maxImages ? _selectImages : null,
      child: Container(
        width: 100,
        height: 100,
        margin: const EdgeInsets.only(right: 8),
        decoration: BoxDecoration(
          color: Colors.grey[200],
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: Colors.grey[400]!),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.add_photo_alternate, 
              size: 40, 
              color: Colors.grey[600]
            ),
            Text(
              '${_selectedImages.length}/${widget.maxImages}',
              style: TextStyle(color: Colors.grey[600]),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildImagePreview(int index) {
    return Stack(
      children: [
        Container(
          width: 100,
          height: 100,
          margin: const EdgeInsets.only(right: 8),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            image: DecorationImage(
              image: FileImage(_selectedImages[index]),
              fit: BoxFit.cover,
            ),
          ),
        ),
        Positioned(
          top: 4,
          right: 12,
          child: GestureDetector(
            onTap: () => _removeImage(index),
            child: Container(
              padding: const EdgeInsets.all(4),
              decoration: const BoxDecoration(
                color: Colors.red,
                shape: BoxShape.circle,
              ),
              child: const Icon(
                Icons.close,
                size: 16,
                color: Colors.white,
              ),
            ),
          ),
        ),
      ],
    );
  }
  
  Future<void> _selectImages() async {
    final imageService = ref.read(imageServiceProvider);
    final images = await imageService.pickFromGallery(
      maxImages: widget.maxImages - _selectedImages.length,
    );
    
    if (images.isNotEmpty) {
      setState(() {
        _selectedImages.addAll(images);
      });
    }
  }
  
  void _removeImage(int index) {
    setState(() {
      _selectedImages.removeAt(index);
    });
  }
  
  Future<void> _uploadImages() async {
    final uploadNotifier = ref.read(uploadProvider.notifier);
    final storageService = ref.read(storageServiceProvider);
    final imageService = ref.read(imageServiceProvider);
    
    uploadNotifier.reset();
    uploadNotifier.setUploading(true);
    
    try {
      // ì´ë¯¸ì§€ ì••ì¶•
      final compressedImages = <File>[];
      for (final image in _selectedImages) {
        final compressed = await imageService.compressImage(image);
        compressedImages.add(compressed);
      }
      
      // ì—…ë¡œë“œ
      final urls = await storageService.uploadMultipleFeedImages(
        compressedImages,
        onProgress: (progress) {
          uploadNotifier.setProgress(progress);
        },
      );
      
      // ì™„ë£Œ ì½œë°±
      widget.onUploadComplete(urls);
      
      // ìƒíƒœ ì´ˆê¸°í™”
      setState(() {
        _selectedImages.clear();
      });
      
    } catch (e) {
      uploadNotifier.setError(e.toString());
    } finally {
      uploadNotifier.setUploading(false);
    }
  }
}

// ì„œë¹„ìŠ¤ í”„ë¡œë°”ì´ë”
final imageServiceProvider = Provider((ref) => ImageService());
final storageServiceProvider = Provider((ref) => StorageService());
```

## 5. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì´ë¯¸ì§€ ì••ì¶•ì´ ì •ìƒ ì‘ë™í•˜ëŠ”ê°€?
- [ ] Supabase Storage ì—…ë¡œë“œê°€ ì„±ê³µí•˜ëŠ”ê°€?
- [ ] ì—…ë¡œë“œ ì§„í–‰ë¥ ì´ í‘œì‹œë˜ëŠ”ê°€?
- [ ] ì—ëŸ¬ ì²˜ë¦¬ê°€ ì ì ˆí•œê°€?
- [ ] ì´ë¯¸ì§€ ì‚­ì œê°€ ì‘ë™í•˜ëŠ”ê°€?

### [ì„ íƒ] í…ŒìŠ¤íŠ¸ ì½”ë“œ
```dart
// íŒŒì¼: test/services/storage_service_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

void main() {
  group('StorageService í…ŒìŠ¤íŠ¸', () {
    test('ì´ë¯¸ì§€ ì—…ë¡œë“œ ì„±ê³µ', () async {
      // TODO: Supabase mock ì„¤ì • í•„ìš”
    });
    
    test('ë‹¤ì¤‘ ì´ë¯¸ì§€ ì—…ë¡œë“œ', () async {
      // TODO: êµ¬í˜„
    });
  });
}
```