# âš¡ 10.4 PostgreSQL ì¿¼ë¦¬ ìµœì í™”

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ì¸ë±ìŠ¤ ìƒì„±](#2-ì¸ë±ìŠ¤-ìƒì„±)
3. [ìµœì í™” í•¨ìˆ˜](#3-ìµœì í™”-í•¨ìˆ˜)
4. [ì§€ë„ ë§ˆì»¤ ì¿¼ë¦¬ ìµœì í™”](#4-ì§€ë„-ë§ˆì»¤-ì¿¼ë¦¬-ìµœì í™”)
5. [ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ë¶€í•˜ ê´€ë¦¬](#5-ì‹¤ì‹œê°„-ì—…ë°ì´íŠ¸-ë¶€í•˜-ê´€ë¦¬)
6. [ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§](#6-ì„±ëŠ¥-ëª¨ë‹ˆí„°ë§)

## 1. ê°œìš”

Fallingo ì„œë¹„ìŠ¤ì˜ í•µì‹¬ ì¿¼ë¦¬ë“¤ì„ ìµœì í™”í•˜ì—¬ ë¹ ë¥¸ ì‘ë‹µ ì†ë„ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ìœ„ì¹˜ ê¸°ë°˜ ê²€ìƒ‰ < 100ms
- âœ… í”¼ë“œ ëª©ë¡ ì¡°íšŒ < 50ms
- âœ… ì§€ë„ ë§ˆì»¤ ë¡œë”© < 150ms
- âœ… ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ì§€ì—° < 1ì´ˆ

## 2. ì¸ë±ìŠ¤ ìƒì„±

### [í•„ìˆ˜] í•µì‹¬ ì¸ë±ìŠ¤
```sql
-- íŒŒì¼: optimization/01_indexes.sql

-- ìœ„ì¹˜ ê¸°ë°˜ ê²€ìƒ‰ (PostGIS)
CREATE INDEX idx_feeds_location_created 
ON feeds USING GIST(location)
INCLUDE (created_at, user_id, menu_id);

CREATE INDEX idx_stores_location_verified
ON stores USING GIST(location)
WHERE is_verified = TRUE;

-- ì§€ë„ ë§ˆì»¤ìš© ë³µí•© ì¸ë±ìŠ¤
CREATE INDEX idx_stores_marker_data
ON stores USING GIST(location)
INCLUDE (name, is_verified, marker_type)
WHERE is_active = TRUE;

-- ì¸í”Œë£¨ì–¸ì„œ ìœ„ì¹˜ ì¶”ì 
CREATE INDEX idx_influencer_locations
ON influencer_locations USING GIST(location)
INCLUDE (user_id, updated_at)
WHERE is_sharing = TRUE;

-- ì´ë²¤íŠ¸ ë§ˆì»¤ ì¸ë±ìŠ¤
CREATE INDEX idx_event_markers_active
ON event_markers USING GIST(location)
INCLUDE (event_type, start_date, end_date)
WHERE start_date <= NOW() AND end_date >= NOW();

-- ì‹œê°„ ê¸°ë°˜ ì •ë ¬
CREATE INDEX idx_feeds_created_desc 
ON feeds(created_at DESC)
INCLUDE (id, user_id, recommendation_count);

-- ì¹´í…Œê³ ë¦¬ ê²€ìƒ‰
CREATE INDEX idx_menus_category_store 
ON menus(category, store_id)
INCLUDE (name, price);

-- íƒœê·¸ ê²€ìƒ‰ (GIN)
CREATE INDEX idx_feeds_tags 
ON feeds USING GIN(tags);
```

### [í•„ìˆ˜] ìœ„ì¹˜ ê¸°ë°˜ íŒŒí‹°ì…”ë‹
```sql
-- íŒŒì¼: optimization/02_partitioning.sql

-- ì§€ì—­ë³„ í…Œì´ë¸” íŒŒí‹°ì…”ë‹ (ëŒ€ë„ì‹œ ê¸°ì¤€)
CREATE TABLE feeds_partitioned (
  LIKE feeds INCLUDING ALL
) PARTITION BY LIST (city_code);

-- ì„œìš¸
CREATE TABLE feeds_seoul PARTITION OF feeds_partitioned
FOR VALUES IN ('SEL');

-- ë¶€ì‚°
CREATE TABLE feeds_busan PARTITION OF feeds_partitioned
FOR VALUES IN ('PUS');

-- ê¸°íƒ€ ì§€ì—­
CREATE TABLE feeds_others PARTITION OF feeds_partitioned
DEFAULT;

-- íŒŒí‹°ì…˜ë³„ ì¸ë±ìŠ¤
CREATE INDEX idx_feeds_seoul_location 
ON feeds_seoul USING GIST(location);

CREATE INDEX idx_feeds_busan_location 
ON feeds_busan USING GIST(location);
```

## 3. ìµœì í™” í•¨ìˆ˜

### [í•„ìˆ˜] ìœ„ì¹˜ ê¸°ë°˜ ê²€ìƒ‰
```sql
-- íŒŒì¼: functions/01_location_search.sql

-- ê·¼ê±°ë¦¬ í”¼ë“œ ê²€ìƒ‰ (ìµœì í™”)
CREATE OR REPLACE FUNCTION get_nearby_feeds_optimized(
  user_lat FLOAT,
  user_lng FLOAT,
  radius_km FLOAT DEFAULT 1.0,
  limit_count INT DEFAULT 20
)
RETURNS TABLE (
  feed_id UUID,
  distance_km FLOAT,
  feed_data JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
  user_location geography;
  search_box geometry;
BEGIN
  -- ì‚¬ìš©ì ìœ„ì¹˜
  user_location := ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography;
  
  -- ë°”ìš´ë”© ë°•ìŠ¤ë¡œ ì´ˆê¸° í•„í„°ë§ (ì„±ëŠ¥ ìµœì í™”)
  search_box := ST_Expand(
    user_location::geometry, 
    radius_km * 0.01  -- degrees approximation
  );
  
  RETURN QUERY
  WITH filtered_feeds AS (
    SELECT 
      f.id,
      f.location,
      f.content,
      f.image_urls,
      f.tags,
      f.recommendation_count,
      f.created_at,
      f.user_id,
      f.menu_id,
      f.store_id
    FROM feeds f
    WHERE f.location && search_box  -- ë°”ìš´ë”© ë°•ìŠ¤ í•„í„°
      AND f.created_at > NOW() - INTERVAL '7 days'
    ORDER BY f.created_at DESC
    LIMIT limit_count * 2  -- ì—¬ìœ ë¶„ í™•ë³´
  )
  SELECT 
    ff.id AS feed_id,
    ST_Distance(ff.location, user_location) / 1000.0 AS distance_km,
    jsonb_build_object(
      'id', ff.id,
      'content', ff.content,
      'image_urls', ff.image_urls,
      'tags', ff.tags,
      'recommendation_count', ff.recommendation_count,
      'created_at', ff.created_at,
      'user', u.nickname,
      'menu', m.name,
      'store', s.name
    ) AS feed_data
  FROM filtered_feeds ff
  JOIN users u ON u.id = ff.user_id
  JOIN menus m ON m.id = ff.menu_id
  JOIN stores s ON s.id = ff.store_id
  WHERE ST_DWithin(ff.location, user_location, radius_km * 1000)
  ORDER BY ff.created_at DESC
  LIMIT limit_count;
END;
$$;
```

## 4. ì§€ë„ ë§ˆì»¤ ì¿¼ë¦¬ ìµœì í™”

### [í•„ìˆ˜] í†µí•© ë§ˆì»¤ ì¡°íšŒ
```sql
-- íŒŒì¼: functions/03_map_markers.sql

-- ì§€ë„ ë§ˆì»¤ í†µí•© ì¡°íšŒ í•¨ìˆ˜
CREATE OR REPLACE FUNCTION get_map_markers(
  user_lat FLOAT,
  user_lng FLOAT,
  radius_km FLOAT DEFAULT 5.0,
  marker_types TEXT[] DEFAULT ARRAY['store', 'influencer', 'event']
)
RETURNS TABLE (
  marker_id UUID,
  marker_type TEXT,
  location geography,
  data JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
  user_location geography;
  search_area geometry;
BEGIN
  user_location := ST_SetSRID(ST_MakePoint(user_lng, user_lat), 4326)::geography;
  search_area := ST_Buffer(user_location::geometry, radius_km * 0.01);
  
  RETURN QUERY
  -- ì¸ì¦ ë§›ì§‘ ë§ˆì»¤ (ìµœëŒ€ 5ê°œ)
  SELECT 
    s.id AS marker_id,
    'store'::TEXT AS marker_type,
    s.location,
    jsonb_build_object(
      'name', s.name,
      'is_verified', s.is_verified,
      'popular_menu', m.name,
      'rating', s.avg_rating
    ) AS data
  FROM stores s
  JOIN menus m ON m.store_id = s.id
  WHERE 'store' = ANY(marker_types)
    AND s.is_verified = TRUE
    AND s.location && search_area
    AND ST_DWithin(s.location, user_location, radius_km * 1000)
  ORDER BY s.verification_date DESC
  LIMIT 5
  
  UNION ALL
  
  -- ì¸í”Œë£¨ì–¸ì„œ ìœ„ì¹˜ (ìµœëŒ€ 3ëª…)
  SELECT 
    il.user_id AS marker_id,
    'influencer'::TEXT AS marker_type,
    il.location,
    jsonb_build_object(
      'nickname', u.nickname,
      'grade', u.grade,
      'grade_stars', CASE 
        WHEN u.grade = 8 THEN 1
        WHEN u.grade = 9 THEN 2
        WHEN u.grade = 10 THEN 3
      END,
      'updated_at', il.updated_at
    ) AS data
  FROM influencer_locations il
  JOIN users u ON u.id = il.user_id
  WHERE 'influencer' = ANY(marker_types)
    AND il.is_sharing = TRUE
    AND il.location && search_area
    AND ST_DWithin(il.location, user_location, radius_km * 1000)
    AND il.updated_at > NOW() - INTERVAL '30 minutes'
  ORDER BY u.grade DESC, il.updated_at DESC
  LIMIT 3
  
  UNION ALL
  
  -- ì´ë²¤íŠ¸ ë§ˆì»¤ (ìµœëŒ€ 5ê°œ)
  SELECT 
    em.id AS marker_id,
    'event'::TEXT AS marker_type,
    em.location,
    jsonb_build_object(
      'title', em.title,
      'event_type', em.event_type,
      'start_date', em.start_date,
      'end_date', em.end_date,
      'description', em.description
    ) AS data
  FROM event_markers em
  WHERE 'event' = ANY(marker_types)
    AND em.location && search_area
    AND ST_DWithin(em.location, user_location, radius_km * 1000)
    AND em.start_date <= NOW()
    AND em.end_date >= NOW()
  ORDER BY em.priority DESC, em.created_at DESC
  LIMIT 5;
END;
$$;
```

### [í•„ìˆ˜] ë§ˆì»¤ í´ëŸ¬ìŠ¤í„°ë§
```sql
-- íŒŒì¼: functions/04_marker_clustering.sql

-- ì¤Œ ë ˆë²¨ë³„ ë§ˆì»¤ í´ëŸ¬ìŠ¤í„°ë§
CREATE OR REPLACE FUNCTION get_clustered_markers(
  bounds_sw_lat FLOAT,
  bounds_sw_lng FLOAT,
  bounds_ne_lat FLOAT,
  bounds_ne_lng FLOAT,
  zoom_level INT
)
RETURNS TABLE (
  cluster_id TEXT,
  center_location geography,
  marker_count INT,
  marker_types JSONB
)
LANGUAGE plpgsql
AS $$
DECLARE
  grid_size FLOAT;
BEGIN
  -- ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ ê·¸ë¦¬ë“œ í¬ê¸° ê²°ì •
  grid_size := CASE 
    WHEN zoom_level < 10 THEN 0.5
    WHEN zoom_level < 13 THEN 0.1
    WHEN zoom_level < 15 THEN 0.05
    ELSE 0.01
  END;
  
  RETURN QUERY
  WITH bounds AS (
    SELECT ST_MakeEnvelope(
      bounds_sw_lng, bounds_sw_lat,
      bounds_ne_lng, bounds_ne_lat,
      4326
    ) AS bbox
  ),
  gridded_markers AS (
    SELECT 
      ST_SnapToGrid(ST_X(location::geometry), grid_size) AS grid_x,
      ST_SnapToGrid(ST_Y(location::geometry), grid_size) AS grid_y,
      marker_type,
      location
    FROM (
      -- ëª¨ë“  ë§ˆì»¤ í†µí•©
      SELECT 'store' AS marker_type, location FROM stores 
      WHERE is_active = TRUE AND location && (SELECT bbox FROM bounds)
      UNION ALL
      SELECT 'influencer', location FROM influencer_locations 
      WHERE is_sharing = TRUE AND location && (SELECT bbox FROM bounds)
      UNION ALL
      SELECT 'event', location FROM event_markers 
      WHERE NOW() BETWEEN start_date AND end_date 
        AND location && (SELECT bbox FROM bounds)
    ) all_markers
  )
  SELECT 
    CONCAT(grid_x, ',', grid_y) AS cluster_id,
    ST_SetSRID(ST_MakePoint(
      AVG(ST_X(location::geometry)), 
      AVG(ST_Y(location::geometry))
    ), 4326)::geography AS center_location,
    COUNT(*) AS marker_count,
    jsonb_object_agg(marker_type, count) AS marker_types
  FROM (
    SELECT grid_x, grid_y, marker_type, location, COUNT(*) AS count
    FROM gridded_markers
    GROUP BY grid_x, grid_y, marker_type, location
  ) grouped
  GROUP BY grid_x, grid_y
  HAVING COUNT(*) > 1 OR zoom_level >= 15;
END;
$$;
```

## 5. ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ë¶€í•˜ ê´€ë¦¬

### [í•„ìˆ˜] ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í
```sql
-- íŒŒì¼: realtime/01_update_queue.sql

-- ì—…ë°ì´íŠ¸ í í…Œì´ë¸”
CREATE TABLE realtime_update_queue (
  id SERIAL PRIMARY KEY,
  update_type TEXT NOT NULL,
  target_id UUID NOT NULL,
  update_data JSONB NOT NULL,
  priority INT DEFAULT 5,
  created_at TIMESTAMP DEFAULT NOW(),
  processed_at TIMESTAMP
);

CREATE INDEX idx_update_queue_priority 
ON realtime_update_queue(priority DESC, created_at)
WHERE processed_at IS NULL;

-- ë°°ì¹˜ ì²˜ë¦¬ í•¨ìˆ˜
CREATE OR REPLACE FUNCTION process_realtime_updates()
RETURNS INT
LANGUAGE plpgsql
AS $$
DECLARE
  processed_count INT := 0;
  batch_size INT := 100;
BEGIN
  WITH batch AS (
    SELECT id, update_type, target_id, update_data
    FROM realtime_update_queue
    WHERE processed_at IS NULL
    ORDER BY priority DESC, created_at
    LIMIT batch_size
    FOR UPDATE SKIP LOCKED
  )
  UPDATE realtime_update_queue q
  SET processed_at = NOW()
  FROM batch b
  WHERE q.id = b.id
  RETURNING q.id INTO processed_count;
  
  -- ì‹¤ì œ ì—…ë°ì´íŠ¸ ìˆ˜í–‰
  PERFORM pg_notify('realtime_updates', json_build_object(
    'count', processed_count,
    'timestamp', NOW()
  )::text);
  
  RETURN processed_count;
END;
$$;
```

### [í•„ìˆ˜] ë””ë°”ìš´ì‹± ë° ì“°ë¡œí‹€ë§
```sql
-- íŒŒì¼: realtime/02_throttling.sql

-- ì‚¬ìš©ìë³„ ì—…ë°ì´íŠ¸ ì œí•œ
CREATE TABLE user_update_limits (
  user_id UUID PRIMARY KEY,
  update_count INT DEFAULT 0,
  window_start TIMESTAMP DEFAULT NOW(),
  last_update TIMESTAMP DEFAULT NOW()
);

-- ì—…ë°ì´íŠ¸ ì œí•œ ì²´í¬
CREATE OR REPLACE FUNCTION check_update_limit(
  p_user_id UUID,
  max_updates INT DEFAULT 10,
  window_minutes INT DEFAULT 1
)
RETURNS BOOLEAN
LANGUAGE plpgsql
AS $$
DECLARE
  current_count INT;
  window_start TIMESTAMP;
BEGIN
  -- í˜„ì¬ ìƒíƒœ ì¡°íšŒ
  SELECT update_count, user_update_limits.window_start
  INTO current_count, window_start
  FROM user_update_limits
  WHERE user_id = p_user_id;
  
  -- ìƒˆ ì‚¬ìš©ì
  IF NOT FOUND THEN
    INSERT INTO user_update_limits (user_id, update_count)
    VALUES (p_user_id, 1);
    RETURN TRUE;
  END IF;
  
  -- ìœˆë„ìš° ë§Œë£Œ ì²´í¬
  IF window_start < NOW() - INTERVAL '1 minute' * window_minutes THEN
    UPDATE user_update_limits
    SET update_count = 1, window_start = NOW()
    WHERE user_id = p_user_id;
    RETURN TRUE;
  END IF;
  
  -- ì œí•œ ì²´í¬
  IF current_count >= max_updates THEN
    RETURN FALSE;
  END IF;
  
  -- ì¹´ìš´íŠ¸ ì¦ê°€
  UPDATE user_update_limits
  SET update_count = update_count + 1, last_update = NOW()
  WHERE user_id = p_user_id;
  
  RETURN TRUE;
END;
$$;
```

### [ì„ íƒ] ìºì‹œ ì›Œë°
```sql
-- íŒŒì¼: realtime/03_cache_warming.sql

-- ì¸ê¸° ì§€ì—­ ìºì‹œ
CREATE MATERIALIZED VIEW popular_areas_cache AS
WITH area_stats AS (
  SELECT 
    ST_SnapToGrid(location::geometry, 0.01) AS grid_point,
    COUNT(*) AS feed_count,
    AVG(recommendation_count) AS avg_recommendations
  FROM feeds
  WHERE created_at > NOW() - INTERVAL '7 days'
  GROUP BY grid_point
)
SELECT 
  ST_SetSRID(grid_point, 4326)::geography AS area_center,
  feed_count,
  avg_recommendations,
  NOW() AS cached_at
FROM area_stats
WHERE feed_count > 10
ORDER BY feed_count DESC
LIMIT 100;

-- ìë™ ê°±ì‹ 
CREATE OR REPLACE FUNCTION refresh_cache()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY popular_areas_cache;
  REFRESH MATERIALIZED VIEW CONCURRENTLY menu_rankings;
END;
$$ LANGUAGE plpgsql;
```

## 6. ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### [í•„ìˆ˜] ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
```sql
-- íŒŒì¼: monitoring/01_dashboard.sql

-- ì‹¤ì‹œê°„ ì„±ëŠ¥ ë©”íŠ¸ë¦­
CREATE OR REPLACE VIEW performance_metrics AS
SELECT 
  'Location Search' AS operation,
  AVG(mean_exec_time) AS avg_ms,
  MAX(mean_exec_time) AS max_ms,
  SUM(calls) AS total_calls
FROM pg_stat_statements
WHERE query LIKE '%get_nearby_feeds%'
UNION ALL
SELECT 
  'Map Markers',
  AVG(mean_exec_time),
  MAX(mean_exec_time),
  SUM(calls)
FROM pg_stat_statements
WHERE query LIKE '%get_map_markers%'
UNION ALL
SELECT 
  'Realtime Updates',
  AVG(mean_exec_time),
  MAX(mean_exec_time),
  SUM(calls)
FROM pg_stat_statements
WHERE query LIKE '%realtime_update%';

-- ìŠ¬ë¡œìš° ì¿¼ë¦¬ ì•Œë¦¼
CREATE OR REPLACE FUNCTION alert_slow_queries()
RETURNS TABLE(query TEXT, avg_time FLOAT)
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    LEFT(query, 100) AS query,
    mean_exec_time AS avg_time
  FROM pg_stat_statements
  WHERE mean_exec_time > 200  -- 200ms ì´ìƒ
    AND calls > 10
  ORDER BY mean_exec_time DESC
  LIMIT 10;
END;
$$ LANGUAGE plpgsql;
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ëª¨ë“  ì¸ë±ìŠ¤ ìƒì„± ì™„ë£Œ
- [ ] ì§€ë„ ë§ˆì»¤ ì¿¼ë¦¬ < 150ms
- [ ] ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í ì„¤ì •
- [ ] ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ êµ¬ì„±
