# ğŸ–¼ï¸ 10.1 ì´ë¯¸ì§€ ìµœì í™” ì „ëµ

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ìµœì í™” ì „ëµ](#2-ìµœì í™”-ì „ëµ)
3. [êµ¬í˜„](#3-êµ¬í˜„)
4. [ë©€í‹° ì´ë¯¸ì§€ ìµœì í™”](#4-ë©€í‹°-ì´ë¯¸ì§€-ìµœì í™”)
5. [ê²€ì¦](#5-ê²€ì¦)

## 1. ê°œìš”
ì•±ì˜ ì„±ëŠ¥ê³¼ ì‚¬ìš©ì ê²½í—˜ì„ í–¥ìƒì‹œí‚¤ê¸° ìœ„í•œ ì²´ê³„ì ì¸ ì´ë¯¸ì§€ ìµœì í™” ì „ëµì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ì´ë¯¸ì§€ ì••ì¶• ì„¤ì •
- âœ… ìºì‹± ì „ëµ
- âœ… CDN ì¤€ë¹„
- âœ… WebP ë³€í™˜ ë¡œì§
- âœ… ë©€í‹° ì´ë¯¸ì§€ ëŒ€ì‘ (5ë°° ì¦ê°€)
- âœ… ì´ë¯¸ì§€ë³„ ìµœì  ì••ì¶•ë¥ 
- âœ… ì¸ë„¤ì¼ ìƒì„± ê·œì¹™

## 2. ìµœì í™” ì „ëµ

### [í•„ìˆ˜] ì´ë¯¸ì§€ ìµœì í™” ì •ì±…
```dart
// íŒŒì¼: lib/core/config/image_optimization_constants.dart
class ImageOptimizationConstants {
  // ì´ë¯¸ì§€ íƒ€ì…ë³„ ì••ì¶• í’ˆì§ˆ ì„¤ì •
  static const Map<ImageType, Map<ImageQuality, int>> typeBasedQuality = {
    ImageType.food: {
      ImageQuality.thumbnail: 65,     // ìŒì‹ì€ ë””í…Œì¼ ì¤‘ìš”
      ImageQuality.preview: 80,
      ImageQuality.standard: 90,
      ImageQuality.high: 95,
      ImageQuality.original: 100,
    },
    ImageType.interior: {
      ImageQuality.thumbnail: 55,     // ì¸í…Œë¦¬ì–´ëŠ” ë¶„ìœ„ê¸° ìœ„ì£¼
      ImageQuality.preview: 70,
      ImageQuality.standard: 80,
      ImageQuality.high: 90,
      ImageQuality.original: 100,
    },
    ImageType.menu: {
      ImageQuality.thumbnail: 70,     // ë©”ë‰´íŒì€ ê°€ë…ì„± ì¤‘ìš”
      ImageQuality.preview: 85,
      ImageQuality.standard: 90,
      ImageQuality.high: 95,
      ImageQuality.original: 100,
    },
    ImageType.receipt: {
      ImageQuality.thumbnail: 60,     // ì˜ìˆ˜ì¦ì€ OCRìš© ê³ í’ˆì§ˆ
      ImageQuality.preview: 80,
      ImageQuality.standard: 90,
      ImageQuality.high: 95,
      ImageQuality.original: 100,
    },
    ImageType.general: {
      ImageQuality.thumbnail: 60,     // ì¼ë°˜ ì‚¬ì§„
      ImageQuality.preview: 75,
      ImageQuality.standard: 85,
      ImageQuality.high: 95,
      ImageQuality.original: 100,
    },
  };

  // ë©€í‹° ì´ë¯¸ì§€ ìµœì í™” ì„¤ì •
  static const multiImageConfig = MultiImageConfig(
    maxImagesPerFeed: 5,
    parallelProcessing: 3,           // ë™ì‹œ ì²˜ë¦¬ ê°œìˆ˜
    totalSizeLimit: 30 * 1024 * 1024, // ì „ì²´ 30MB ì œí•œ
    perImageSizeLimit: 10 * 1024 * 1024, // ê°œë³„ 10MB ì œí•œ
  );

  // ì¸ë„¤ì¼ ìƒì„± ê·œì¹™
  static const Map<ThumbnailType, ThumbnailConfig> thumbnailConfigs = {
    ThumbnailType.feedList: ThumbnailConfig(
      width: 300,
      height: 300,
      aspectRatio: AspectRatioMode.cover,
      quality: 65,
      format: ImageFormat.webp,
    ),
    ThumbnailType.feedGrid: ThumbnailConfig(
      width: 200,
      height: 200,
      aspectRatio: AspectRatioMode.cover,
      quality: 60,
      format: ImageFormat.webp,
    ),
    ThumbnailType.profileGrid: ThumbnailConfig(
      width: 150,
      height: 150,
      aspectRatio: AspectRatioMode.cover,
      quality: 55,
      format: ImageFormat.webp,
    ),
    ThumbnailType.notification: ThumbnailConfig(
      width: 80,
      height: 80,
      aspectRatio: AspectRatioMode.cover,
      quality: 50,
      format: ImageFormat.webp,
    ),
  };

  // WebP ë³€í™˜ ì „ëµ
  static const webPConfig = WebPConfig(
    enabledByDefault: true,
    fallbackFormat: ImageFormat.jpeg,
    qualityLossless: false,
    qualityFactor: 85,
    method: 4, // 0-6, ë†’ì„ìˆ˜ë¡ ì••ì¶•ë¥  í–¥ìƒ
    targetSize: 0, // 0ì€ ìë™
    filter: 20, // 0-100
    autoFilter: true,
    alphaCompression: 1,
    alphaFiltering: 1,
    alphaQuality: 100,
    pass: 10, // 1-10
    showCompressed: false,
    preprocessing: 0,
    partitions: 0,
    partitionLimit: 0,
    emulateJpegSize: false,
    threadLevel: 1,
    lowMemory: false,
    nearLossless: 100,
    exact: false,
  );
  
  // í¬ê¸° ì œí•œ ì„¤ì •
  static const Map<ImageSize, SizeConfig> sizeConfigs = {
    ImageSize.thumbnail: SizeConfig(
      maxWidth: 150,
      maxHeight: 150,
      aspectRatio: AspectRatioMode.cover,
    ),
    ImageSize.small: SizeConfig(
      maxWidth: 300,
      maxHeight: 300,
      aspectRatio: AspectRatioMode.contain,
    ),
    ImageSize.medium: SizeConfig(
      maxWidth: 600,
      maxHeight: 600,
      aspectRatio: AspectRatioMode.contain,
    ),
    ImageSize.large: SizeConfig(
      maxWidth: 1080,
      maxHeight: 1080,
      aspectRatio: AspectRatioMode.contain,
    ),
    ImageSize.xlarge: SizeConfig(
      maxWidth: 1920,
      maxHeight: 1920,
      aspectRatio: AspectRatioMode.contain,
    ),
  };
  
  // ìºì‹œ ì„¤ì • (ë©€í‹° ì´ë¯¸ì§€ ëŒ€ì‘)
  static const cacheConfig = CacheConfig(
    maxMemoryCacheSize: 200 * 1024 * 1024,  // 200MB (2ë°° ì¦ê°€)
    maxDiskCacheSize: 1000 * 1024 * 1024,   // 1GB (2ë°° ì¦ê°€)
    maxCacheAge: Duration(days: 30),
    maxMemoryCacheCount: 200,               // 2ë°° ì¦ê°€
    preloadNextImages: 3,                    // ë‹¤ìŒ 3ê°œ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë“œ
  );
  
  // í¬ë§· ìš°ì„ ìˆœìœ„
  static const List<ImageFormat> formatPriority = [
    ImageFormat.webp,    // ìµœìš°ì„ 
    ImageFormat.jpeg,    // ì°¨ì„ 
    ImageFormat.png,     // íˆ¬ëª…ë„ í•„ìš”ì‹œ
  ];
  
  // ì—…ë¡œë“œ ì œí•œ
  static const uploadLimits = UploadLimits(
    maxFileSize: 10 * 1024 * 1024,  // 10MB
    maxDimension: 4096,              // 4K
    allowedFormats: ['jpg', 'jpeg', 'png', 'heic', 'heif', 'webp'],
    maxTotalSize: 30 * 1024 * 1024, // ë©€í‹° ì´ë¯¸ì§€ ì „ì²´ 30MB
  );
  
  // ë ˆì´ì§€ ë¡œë”© ì„¤ì •
  static const lazyLoadingConfig = LazyLoadingConfig(
    preloadDistance: 300,  // 300px ì „ì— ë¯¸ë¦¬ ë¡œë“œ
    placeholder: 'assets/images/placeholder.png',
    errorWidget: 'assets/images/error.png',
    enableInViewport: true,
    viewportFraction: 0.5, // 50% ì´ìƒ ë³´ì¼ ë•Œ ë¡œë“œ
  );
}
```

## 3. êµ¬í˜„

### [í•„ìˆ˜] ë©€í‹° ì´ë¯¸ì§€ ìµœì í™” ì„œë¹„ìŠ¤
```dart
// íŒŒì¼: lib/data/services/multi_image_optimization_service.dart
import 'dart:io';
import 'dart:typed_data';
import 'dart:isolate';
import 'package:flutter_image_compress/flutter_image_compress.dart';

class MultiImageOptimizationService {
  static final MultiImageOptimizationService _instance = 
      MultiImageOptimizationService._internal();
  factory MultiImageOptimizationService() => _instance;
  MultiImageOptimizationService._internal();
  
  // ë©€í‹° ì´ë¯¸ì§€ ì¼ê´„ ìµœì í™”
  Future<List<OptimizedImage>> optimizeMultipleImages({
    required List<File> imageFiles,
    required List<ImageType> imageTypes,
    required ImageSize targetSize,
    ImageQuality quality = ImageQuality.standard,
  }) async {
    // ì „ì²´ í¬ê¸° ê²€ì¦
    int totalSize = 0;
    for (final file in imageFiles) {
      totalSize += await file.length();
    }
    
    if (totalSize > ImageOptimizationConstants.multiImageConfig.totalSizeLimit) {
      throw ImageOptimizationException(
        'Total file size exceeds limit: ${totalSize ~/ 1024 / 1024}MB'
      );
    }
    
    // ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ìœ„í•œ ë°°ì¹˜ ìƒì„±
    final batches = _createBatches(
      imageFiles, 
      ImageOptimizationConstants.multiImageConfig.parallelProcessing
    );
    
    final List<OptimizedImage> results = [];
    
    for (final batch in batches) {
      // ê° ë°°ì¹˜ë¥¼ ë³‘ë ¬ë¡œ ì²˜ë¦¬
      final batchResults = await Future.wait(
        batch.asMap().entries.map((entry) async {
          final index = entry.key;
          final file = entry.value;
          final imageType = imageTypes[imageFiles.indexOf(file)];
          
          // Isolateì—ì„œ ì²˜ë¦¬ (ë¬´ê±°ìš´ ì‘ì—…)
          return await _optimizeInIsolate(
            file: file,
            imageType: imageType,
            targetSize: targetSize,
            quality: quality,
            isFirstImage: imageFiles.indexOf(file) == 0,
          );
        }),
      );
      
      results.addAll(batchResults);
    }
    
    // ì¸ë„¤ì¼ ìƒì„± (ì²« ë²ˆì§¸ ì´ë¯¸ì§€ë§Œ)
    if (results.isNotEmpty) {
      await _generateThumbnails(results.first);
    }
    
    return results;
  }
  
  // ì´ë¯¸ì§€ íƒ€ì… ê°ì§€
  Future<ImageType> detectImageType(File imageFile) async {
    try {
      // Vision APIë¥¼ í†µí•œ ì´ë¯¸ì§€ ë¶„ì„ (Mock)
      final labels = await _analyzeImageContent(imageFile);
      
      if (_isFoodImage(labels)) {
        return ImageType.food;
      } else if (_isMenuImage(labels)) {
        return ImageType.menu;
      } else if (_isInteriorImage(labels)) {
        return ImageType.interior;
      } else if (_isReceiptImage(labels)) {
        return ImageType.receipt;
      }
      
      return ImageType.general;
    } catch (e) {
      return ImageType.general;
    }
  }
  
  // Isolateì—ì„œ ì´ë¯¸ì§€ ìµœì í™”
  Future<OptimizedImage> _optimizeInIsolate({
    required File file,
    required ImageType imageType,
    required ImageSize targetSize,
    required ImageQuality quality,
    required bool isFirstImage,
  }) async {
    final receivePort = ReceivePort();
    
    await Isolate.spawn(
      _isolateOptimizeImage,
      IsolateData(
        sendPort: receivePort.sendPort,
        filePath: file.path,
        imageType: imageType,
        targetSize: targetSize,
        quality: quality,
        isFirstImage: isFirstImage,
      ),
    );
    
    final result = await receivePort.first as OptimizedImage;
    return result;
  }
  
  // Isolate í•¨ìˆ˜
  static void _isolateOptimizeImage(IsolateData data) async {
    final file = File(data.filePath);
    final service = ImageOptimizationService();
    
    try {
      // ì´ë¯¸ì§€ íƒ€ì…ë³„ ìµœì  ì••ì¶•ë¥  ì ìš©
      final typeQuality = ImageOptimizationConstants
          .typeBasedQuality[data.imageType]![data.quality]!;
      
      final optimized = await service.optimizeImage(
        imageFile: file,
        targetSize: data.targetSize,
        quality: data.quality,
        customQuality: typeQuality,
      );
      
      // WebP ë³€í™˜ (ì²« ë²ˆì§¸ ì´ë¯¸ì§€ ë˜ëŠ” ì§€ì›ë˜ëŠ” ê²½ìš°)
      if (data.isFirstImage || _shouldConvertToWebP(data.imageType)) {
        final webpResult = await _convertToWebP(
          optimized.file,
          typeQuality,
        );
        
        if (webpResult != null) {
          optimized.file = webpResult;
          optimized.metadata.format = ImageFormat.webp;
        }
      }
      
      data.sendPort.send(optimized);
    } catch (e) {
      data.sendPort.send(
        ImageOptimizationException('Optimization failed: $e')
      );
    }
  }
  
  // WebP ë³€í™˜
  static Future<File?> _convertToWebP(File imageFile, int quality) async {
    try {
      final bytes = await imageFile.readAsBytes();
      final config = ImageOptimizationConstants.webPConfig;
      
      final webpBytes = await FlutterImageCompress.compressWithList(
        bytes,
        format: CompressFormat.webp,
        quality: quality,
        keepExif: false,
      );
      
      // í¬ê¸° ë¹„êµ (WebPê°€ ë” ì‘ì„ ë•Œë§Œ ì‚¬ìš©)
      if (webpBytes.length < bytes.length * 0.9) {
        final webpPath = imageFile.path.replaceAll(
          RegExp(r'\.(jpg|jpeg|png)$'),
          '.webp'
        );
        
        final webpFile = File(webpPath);
        await webpFile.writeAsBytes(webpBytes);
        
        return webpFile;
      }
      
      return null;
    } catch (e) {
      print('WebP conversion failed: $e');
      return null;
    }
  }
  
  // ì¸ë„¤ì¼ ìƒì„±
  Future<Map<ThumbnailType, File>> _generateThumbnails(
    OptimizedImage sourceImage
  ) async {
    final thumbnails = <ThumbnailType, File>{};
    
    for (final entry in ImageOptimizationConstants.thumbnailConfigs.entries) {
      final type = entry.key;
      final config = entry.value;
      
      final thumbnail = await _createThumbnail(
        sourceImage.file,
        config,
      );
      
      if (thumbnail != null) {
        thumbnails[type] = thumbnail;
      }
    }
    
    return thumbnails;
  }
  
  // ê°œë³„ ì¸ë„¤ì¼ ìƒì„±
  Future<File?> _createThumbnail(
    File sourceFile,
    ThumbnailConfig config,
  ) async {
    try {
      final bytes = await sourceFile.readAsBytes();
      
      final thumbnailBytes = await FlutterImageCompress.compressWithList(
        bytes,
        minWidth: config.width,
        minHeight: config.height,
        quality: config.quality,
        format: config.format == ImageFormat.webp 
            ? CompressFormat.webp 
            : CompressFormat.jpeg,
      );
      
      final thumbnailPath = _generateThumbnailPath(
        sourceFile.path,
        config,
      );
      
      final thumbnailFile = File(thumbnailPath);
      await thumbnailFile.writeAsBytes(thumbnailBytes);
      
      return thumbnailFile;
    } catch (e) {
      print('Thumbnail generation failed: $e');
      return null;
    }
  }
  
  // ë°°ì¹˜ ìƒì„±
  List<List<File>> _createBatches(List<File> files, int batchSize) {
    final batches = <List<File>>[];
    
    for (int i = 0; i < files.length; i += batchSize) {
      final end = (i + batchSize < files.length) 
          ? i + batchSize 
          : files.length;
      batches.add(files.sublist(i, end));
    }
    
    return batches;
  }
  
  // ì´ë¯¸ì§€ ë‚´ìš© ë¶„ì„ (Mock)
  Future<List<String>> _analyzeImageContent(File file) async {
    // ì‹¤ì œë¡œëŠ” Vision API í˜¸ì¶œ
    await Future.delayed(Duration(milliseconds: 500));
    
    // Mock ë ˆì´ë¸” ë°˜í™˜
    return ['food', 'dish', 'korean cuisine'];
  }
  
  // ì´ë¯¸ì§€ íƒ€ì… íŒë³„ í•¨ìˆ˜ë“¤
  bool _isFoodImage(List<String> labels) {
    final foodKeywords = ['food', 'dish', 'meal', 'cuisine', 'dessert'];
    return labels.any((label) => 
      foodKeywords.any((keyword) => label.toLowerCase().contains(keyword))
    );
  }
  
  bool _isMenuImage(List<String> labels) {
    final menuKeywords = ['menu', 'text', 'document', 'price list'];
    return labels.any((label) => 
      menuKeywords.any((keyword) => label.toLowerCase().contains(keyword))
    );
  }
  
  bool _isInteriorImage(List<String> labels) {
    final interiorKeywords = ['interior', 'restaurant', 'cafe', 'room', 'furniture'];
    return labels.any((label) => 
      interiorKeywords.any((keyword) => label.toLowerCase().contains(keyword))
    );
  }
  
  bool _isReceiptImage(List<String> labels) {
    final receiptKeywords = ['receipt', 'bill', 'invoice', 'payment'];
    return labels.any((label) => 
      receiptKeywords.any((keyword) => label.toLowerCase().contains(keyword))
    );
  }
  
  static bool _shouldConvertToWebP(ImageType type) {
    // ë©”ë‰´íŒê³¼ ì˜ìˆ˜ì¦ì€ ê°€ë…ì„±ì„ ìœ„í•´ JPEG ìœ ì§€
    return type != ImageType.menu && type != ImageType.receipt;
  }
  
  String _generateThumbnailPath(String originalPath, ThumbnailConfig config) {
    final dir = File(originalPath).parent.path;
    final filename = File(originalPath).uri.pathSegments.last;
    final nameWithoutExt = filename.split('.').first;
    final ext = config.format.toString().split('.').last;
    
    return '$dir/${nameWithoutExt}_${config.width}x${config.height}.$ext';
  }
}

// ì§€ì› í´ë˜ìŠ¤ë“¤
enum ImageType { food, interior, menu, receipt, general }
enum ThumbnailType { feedList, feedGrid, profileGrid, notification }

class MultiImageConfig {
  final int maxImagesPerFeed;
  final int parallelProcessing;
  final int totalSizeLimit;
  final int perImageSizeLimit;
  
  const MultiImageConfig({
    required this.maxImagesPerFeed,
    required this.parallelProcessing,
    required this.totalSizeLimit,
    required this.perImageSizeLimit,
  });
}

class ThumbnailConfig {
  final int width;
  final int height;
  final AspectRatioMode aspectRatio;
  final int quality;
  final ImageFormat format;
  
  const ThumbnailConfig({
    required this.width,
    required this.height,
    required this.aspectRatio,
    required this.quality,
    required this.format,
  });
}

class WebPConfig {
  final bool enabledByDefault;
  final ImageFormat fallbackFormat;
  final bool qualityLossless;
  final int qualityFactor;
  final int method;
  final int targetSize;
  final int filter;
  final bool autoFilter;
  final int alphaCompression;
  final int alphaFiltering;
  final int alphaQuality;
  final int pass;
  final bool showCompressed;
  final int preprocessing;
  final int partitions;
  final int partitionLimit;
  final bool emulateJpegSize;
  final int threadLevel;
  final bool lowMemory;
  final int nearLossless;
  final bool exact;
  
  const WebPConfig({
    required this.enabledByDefault,
    required this.fallbackFormat,
    required this.qualityLossless,
    required this.qualityFactor,
    required this.method,
    required this.targetSize,
    required this.filter,
    required this.autoFilter,
    required this.alphaCompression,
    required this.alphaFiltering,
    required this.alphaQuality,
    required this.pass,
    required this.showCompressed,
    required this.preprocessing,
    required this.partitions,
    required this.partitionLimit,
    required this.emulateJpegSize,
    required this.threadLevel,
    required this.lowMemory,
    required this.nearLossless,
    required this.exact,
  });
}

class IsolateData {
  final SendPort sendPort;
  final String filePath;
  final ImageType imageType;
  final ImageSize targetSize;
  final ImageQuality quality;
  final bool isFirstImage;
  
  IsolateData({
    required this.sendPort,
    required this.filePath,
    required this.imageType,
    required this.targetSize,
    required this.quality,
    required this.isFirstImage,
  });
}
```

## 4. ë©€í‹° ì´ë¯¸ì§€ ìµœì í™”

### [í•„ìˆ˜] ë©€í‹° ì´ë¯¸ì§€ ë·°ì–´ ìœ„ì ¯
```dart
// íŒŒì¼: lib/widgets/multi_image_viewer.dart
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';

class MultiImageViewer extends StatefulWidget {
  final List<String> imageUrls;
  final List<ImageType> imageTypes;
  final int initialIndex;
  
  const MultiImageViewer({
    Key? key,
    required this.imageUrls,
    required this.imageTypes,
    this.initialIndex = 0,
  }) : super(key: key);
  
  @override
  _MultiImageViewerState createState() => _MultiImageViewerState();
}

class _MultiImageViewerState extends State<MultiImageViewer> {
  late PageController _pageController;
  late int _currentIndex;
  final Map<int, bool> _loadedImages = {};
  
  @override
  void initState() {
    super.initState();
    _currentIndex = widget.initialIndex;
    _pageController = PageController(initialPage: _currentIndex);
    _preloadImages();
  }
  
  void _preloadImages() {
    // í˜„ì¬ ì¸ë±ìŠ¤ ê¸°ì¤€ìœ¼ë¡œ ì•ë’¤ ì´ë¯¸ì§€ ë¯¸ë¦¬ ë¡œë“œ
    final preloadRange = ImageOptimizationConstants.cacheConfig.preloadNextImages;
    
    for (int i = 0; i < widget.imageUrls.length; i++) {
      if (i >= _currentIndex - preloadRange && 
          i <= _currentIndex + preloadRange) {
        _loadImage(i);
      }
    }
  }
  
  void _loadImage(int index) {
    if (_loadedImages[index] == true) return;
    
    final imageUrl = widget.imageUrls[index];
    final imageType = widget.imageTypes[index];
    
    // ì´ë¯¸ì§€ íƒ€ì…ì— ë”°ë¥¸ ìµœì í™”ëœ URL ìƒì„±
    final optimizedUrl = _getOptimizedUrl(imageUrl, imageType);
    
    // ìºì‹œì— ë¯¸ë¦¬ ë¡œë“œ
    precacheImage(
      CachedNetworkImageProvider(optimizedUrl),
      context,
    ).then((_) {
      setState(() {
        _loadedImages[index] = true;
      });
    });
  }
  
  String _getOptimizedUrl(String originalUrl, ImageType imageType) {
    // ì´ë¯¸ì§€ íƒ€ì…ë³„ ìµœì í™” íŒŒë¼ë¯¸í„° ì ìš©
    final quality = ImageOptimizationConstants
        .typeBasedQuality[imageType]![ImageQuality.standard]!;
    
    if (AppConfig.current.isLocal) {
      return originalUrl;
    }
    
    return '${AppConfig.current.cdnUrl}/optimize'
        '?url=${Uri.encodeComponent(originalUrl)}'
        '&type=${imageType.toString()}'
        '&quality=$quality'
        '&format=webp';
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.black,
      body: Stack(
        children: [
          // ì´ë¯¸ì§€ í˜ì´ì§€ë·°
          PageView.builder(
            controller: _pageController,
            onPageChanged: (index) {
              setState(() {
                _currentIndex = index;
              });
              _preloadImages();
            },
            itemCount: widget.imageUrls.length,
            itemBuilder: (context, index) {
              return _buildImagePage(index);
            },
          ),
          
          // ìƒë‹¨ ì¸ë””ì¼€ì´í„°
          SafeArea(
            child: Container(
              padding: EdgeInsets.all(16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  // ë‹«ê¸° ë²„íŠ¼
                  IconButton(
                    icon: Icon(Icons.close, color: Colors.white),
                    onPressed: () => Navigator.pop(context),
                  ),
                  
                  // í˜ì´ì§€ ì¸ë””ì¼€ì´í„°
                  Container(
                    padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.5),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Text(
                      '${_currentIndex + 1} / ${widget.imageUrls.length}',
                      style: TextStyle(color: Colors.white),
                    ),
                  ),
                  
                  // ë‹¤ìš´ë¡œë“œ ë²„íŠ¼
                  IconButton(
                    icon: Icon(Icons.download, color: Colors.white),
                    onPressed: () => _downloadImage(_currentIndex),
                  ),
                ],
              ),
            ),
          ),
          
          // í•˜ë‹¨ ì¸ë„¤ì¼ ë¦¬ìŠ¤íŠ¸
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              height: 80,
              margin: EdgeInsets.only(bottom: 20),
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                padding: EdgeInsets.symmetric(horizontal: 16),
                itemCount: widget.imageUrls.length,
                itemBuilder: (context, index) {
                  return _buildThumbnail(index);
                },
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  Widget _buildImagePage(int index) {
    final imageUrl = widget.imageUrls[index];
    final imageType = widget.imageTypes[index];
    final optimizedUrl = _getOptimizedUrl(imageUrl, imageType);
    
    return InteractiveViewer(
      minScale: 0.5,
      maxScale: 4.0,
      child: Center(
        child: CachedNetworkImage(
          imageUrl: optimizedUrl,
          fit: BoxFit.contain,
          placeholder: (context, url) => CircularProgressIndicator(),
          errorWidget: (context, url, error) => Icon(
            Icons.error,
            color: Colors.white,
            size: 48,
          ),
        ),
      ),
    );
  }
  
  Widget _buildThumbnail(int index) {
    final imageUrl = widget.imageUrls[index];
    final isSelected = index == _currentIndex;
    
    // ì¸ë„¤ì¼ìš© URL ìƒì„±
    final thumbnailUrl = _getThumbnailUrl(imageUrl);
    
    return GestureDetector(
      onTap: () {
        _pageController.animateToPage(
          index,
          duration: Duration(milliseconds: 300),
          curve: Curves.easeInOut,
        );
      },
      child: Container(
        width: 60,
        height: 60,
        margin: EdgeInsets.only(right: 8),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected ? Theme.of(context).primaryColor : Colors.transparent,
            width: 2,
          ),
          borderRadius: BorderRadius.circular(8),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(6),
          child: CachedNetworkImage(
            imageUrl: thumbnailUrl,
            fit: BoxFit.cover,
            placeholder: (context, url) => Container(
              color: Colors.grey[800],
            ),
          ),
        ),
      ),
    );
  }
  
  String _getThumbnailUrl(String originalUrl) {
    if (AppConfig.current.isLocal) {
      return originalUrl;
    }
    
    final config = ImageOptimizationConstants
        .thumbnailConfigs[ThumbnailType.feedGrid]!;
    
    return '${AppConfig.current.cdnUrl}/optimize'
        '?url=${Uri.encodeComponent(originalUrl)}'
        '&width=${config.width}'
        '&height=${config.height}'
        '&quality=${config.quality}'
        '&format=webp';
  }
  
  void _downloadImage(int index) async {
    // ì›ë³¸ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë¡œì§
    final imageUrl = widget.imageUrls[index];
    // TODO: ë‹¤ìš´ë¡œë“œ êµ¬í˜„
  }
}
```

### [í•„ìˆ˜] ì´ë¯¸ì§€ ì—…ë¡œë“œ ì§„í–‰ ìƒíƒœ ìœ„ì ¯
```dart
// íŒŒì¼: lib/widgets/multi_image_upload_progress.dart
class MultiImageUploadProgress extends StatelessWidget {
  final List<ImageUploadState> uploadStates;
  
  const MultiImageUploadProgress({
    Key? key,
    required this.uploadStates,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: Offset(0, 5),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'ì´ë¯¸ì§€ ì—…ë¡œë“œ ì¤‘...',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          SizedBox(height: 16),
          ...uploadStates.asMap().entries.map((entry) {
            final index = entry.key;
            final state = entry.value;
            
            return _buildImageProgress(
              index: index,
              state: state,
              isFirst: index == 0,
            );
          }).toList(),
          SizedBox(height: 12),
          _buildTotalProgress(),
        ],
      ),
    );
  }
  
  Widget _buildImageProgress({
    required int index,
    required ImageUploadState state,
    required bool isFirst,
  }) {
    return Padding(
      padding: EdgeInsets.only(bottom: 12),
      child: Row(
        children: [
          // ì¸ë„¤ì¼
          Container(
            width: 40,
            height: 40,
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(8),
              color: Colors.grey[200],
            ),
            child: state.thumbnail != null
                ? ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: Image.file(
                      state.thumbnail!,
                      fit: BoxFit.cover,
                    ),
                  )
                : Center(
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                    ),
                  ),
          ),
          SizedBox(width: 12),
          
          // ì§„í–‰ ìƒíƒœ
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Text(
                      isFirst ? 'ìŒì‹ ì‚¬ì§„' : 'ì¶”ê°€ ì‚¬ì§„ ${index}',
                      style: TextStyle(
                        fontSize: 14,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                    if (state.isOptimizing) ...[
                      SizedBox(width: 8),
                      Container(
                        padding: EdgeInsets.symmetric(
                          horizontal: 8,
                          vertical: 2,
                        ),
                        decoration: BoxDecoration(
                          color: Colors.orange[100],
                          borderRadius: BorderRadius.circular(12),
                        ),
                        child: Text(
                          'WebP ë³€í™˜ ì¤‘',
                          style: TextStyle(
                            fontSize: 10,
                            color: Colors.orange[800],
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
                SizedBox(height: 4),
                Row(
                  children: [
                    Expanded(
                      child: LinearProgressIndicator(
                        value: state.progress,
                        backgroundColor: Colors.grey[200],
                        valueColor: AlwaysStoppedAnimation<Color>(
                          state.hasError 
                              ? Colors.red 
                              : Theme.of(context).primaryColor,
                        ),
                      ),
                    ),
                    SizedBox(width: 8),
                    Text(
                      '${(state.progress * 100).toInt()}%',
                      style: TextStyle(
                        fontSize: 12,
                        color: Colors.grey[600],
                      ),
                    ),
                  ],
                ),
                if (state.compressionInfo != null) ...[
                  SizedBox(height: 2),
                  Text(
                    '${state.compressionInfo!.originalSizeMB}MB â†’ '
                    '${state.compressionInfo!.compressedSizeMB}MB '
                    '(${state.compressionInfo!.compressionRatio}% ì••ì¶•)',
                    style: TextStyle(
                      fontSize: 10,
                      color: Colors.grey[500],
                    ),
                  ),
                ],
              ],
            ),
          ),
          
          // ìƒíƒœ ì•„ì´ì½˜
          SizedBox(width: 8),
          if (state.isComplete)
            Icon(Icons.check_circle, color: Colors.green, size: 20)
          else if (state.hasError)
            Icon(Icons.error, color: Colors.red, size: 20)
          else if (state.isOptimizing)
            SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
        ],
      ),
    );
  }
  
  Widget _buildTotalProgress() {
    final completedCount = uploadStates.where((s) => s.isComplete).length;
    final totalCount = uploadStates.length;
    final totalProgress = completedCount / totalCount;
    
    return Container(
      padding: EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.grey[100],
        borderRadius: BorderRadius.circular(8),
      ),
      child: Row(
        children: [
          Icon(
            Icons.cloud_upload,
            color: Theme.of(context).primaryColor,
            size: 20,
          ),
          SizedBox(width: 8),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'ì „ì²´ ì§„í–‰ë¥ ',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                SizedBox(height: 4),
                LinearProgressIndicator(
                  value: totalProgress,
                  backgroundColor: Colors.white,
                  valueColor: AlwaysStoppedAnimation<Color>(
                    Theme.of(context).primaryColor,
                  ),
                ),
              ],
            ),
          ),
          SizedBox(width: 12),
          Text(
            '$completedCount / $totalCount',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: Theme.of(context).primaryColor,
            ),
          ),
        ],
      ),
    );
  }
}

class ImageUploadState {
  final File? thumbnail;
  final double progress;
  final bool isComplete;
  final bool hasError;
  final bool isOptimizing;
  final CompressionInfo? compressionInfo;
  
  ImageUploadState({
    this.thumbnail,
    required this.progress,
    required this.isComplete,
    required this.hasError,
    required this.isOptimizing,
    this.compressionInfo,
  });
}

class CompressionInfo {
  final String originalSizeMB;
  final String compressedSizeMB;
  final String compressionRatio;
  
  CompressionInfo({
    required this.originalSizeMB,
    required this.compressedSizeMB,
    required this.compressionRatio,
  });
}
```

## 5. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì´ë¯¸ì§€ ì••ì¶•ë¥  60% ì´ìƒ ë‹¬ì„±
- [ ] WebP í¬ë§· ìë™ ë³€í™˜
- [ ] ë©”ëª¨ë¦¬ ìºì‹œ 200MB ì´í•˜ ìœ ì§€
- [ ] ë””ìŠ¤í¬ ìºì‹œ 1GB ì´í•˜ ìœ ì§€
- [ ] ë ˆì´ì§€ ë¡œë”© ì •ìƒ ì‘ë™
- [ ] ë‹¤ì–‘í•œ í¬ê¸°ë³„ ìµœì í™” í™•ì¸
- [ ] ìºì‹œ ë§Œë£Œ ì •ì±… ì‘ë™
- [ ] ë©€í‹° ì´ë¯¸ì§€ ë³‘ë ¬ ì²˜ë¦¬
- [ ] ì´ë¯¸ì§€ íƒ€ì…ë³„ ìµœì  ì••ì¶•
- [ ] ì¸ë„¤ì¼ ìë™ ìƒì„±
- [ ] WebP ë³€í™˜ ì„±ê³µë¥  80% ì´ìƒ

### ğŸ§ª ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
```dart
// íŒŒì¼: test/performance/image_optimization_test.dart
void main() {
  group('ì´ë¯¸ì§€ ìµœì í™” ì„±ëŠ¥ í…ŒìŠ¤íŠ¸', () {
    test('ë©€í‹° ì´ë¯¸ì§€ ì••ì¶• ì„±ëŠ¥', () async {
      final service = MultiImageOptimizationService();
      
      // 5ê°œ ì´ë¯¸ì§€ ì¤€ë¹„
      final testImages = List.generate(5, (i) => 
        File('test_assets/test_image_$i.jpg')
      );
      
      final stopwatch = Stopwatch()..start();
      
      final results = await service.optimizeMultipleImages(
        imageFiles: testImages,
        imageTypes: [
          ImageType.food,
          ImageType.interior,
          ImageType.menu,
          ImageType.general,
          ImageType.general,
        ],
        targetSize: ImageSize.large,
      );
      
      stopwatch.stop();
      
      // 5ê°œ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹œê°„ 5ì´ˆ ì´ë‚´
      expect(stopwatch.elapsed.inSeconds, lessThan(5));
      
      // ì••ì¶•ë¥  ê²€ì¦
      for (int i = 0; i < results.length; i++) {
        final original = await testImages[i].length();
        final compressed = await results[i].file.length();
        final ratio = compressed / original;
        
        print('Image $i compression: ${(1 - ratio) * 100}%');
        expect(ratio, lessThan(0.4)); // 60% ì´ìƒ ì••ì¶•
      }
    });
    
    test('WebP ë³€í™˜ íš¨ìœ¨ì„±', () async {
      final jpegFile = File('test_assets/food_image.jpg');
      final webpFile = await MultiImageOptimizationService
          ._convertToWebP(jpegFile, 85);
      
      expect(webpFile, isNotNull);
      
      final jpegSize = await jpegFile.length();
      final webpSize = await webpFile!.length();
      
      print('JPEG: ${jpegSize ~/ 1024}KB');
      print('WebP: ${webpSize ~/ 1024}KB');
      print('Reduction: ${((1 - webpSize/jpegSize) * 100).toStringAsFixed(1)}%');
      
      // WebPê°€ ìµœì†Œ 20% ë” ì‘ì•„ì•¼ í•¨
      expect(webpSize, lessThan(jpegSize * 0.8));
    });
  });
}
```