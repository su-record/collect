# ğŸ’¾ 10.2 API ì‘ë‹µ ìºì‹±

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ìºì‹± ì „ëµ](#2-ìºì‹±-ì „ëµ)
3. [êµ¬í˜„](#3-êµ¬í˜„)
4. [ê²€ì¦](#4-ê²€ì¦)

## 1. ê°œìš”
ë„¤íŠ¸ì›Œí¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì´ê³  ì•± ì„±ëŠ¥ì„ í–¥ìƒì‹œí‚¤ê¸° ìœ„í•œ ì²´ê³„ì ì¸ API ì‘ë‹µ ìºì‹± ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ìºì‹œ í‚¤ ì „ëµ
- âœ… TTL ì„¤ì •
- âœ… ìºì‹œ ë¬´íš¨í™”
- âœ… ì˜¤í”„ë¼ì¸ ëŒ€ì‘

## 2. ìºì‹± ì „ëµ

### [í•„ìˆ˜] ìºì‹± ì •ì±… ì •ì˜
```dart
// íŒŒì¼: lib/core/config/cache_policy_constants.dart
class CachePolicyConstants {
  // API ì—”ë“œí¬ì¸íŠ¸ë³„ ìºì‹± ì •ì±…
  static const Map<String, CachePolicy> apiCachePolicies = {
    // í”¼ë“œ ê´€ë ¨
    '/feeds': CachePolicy(
      ttl: Duration(minutes: 5),
      staleWhileRevalidate: Duration(minutes: 10),
      cacheStrategy: CacheStrategy.networkFirst,
      maxCacheSize: 100,
    ),
    '/feeds/{id}': CachePolicy(
      ttl: Duration(minutes: 10),
      staleWhileRevalidate: Duration(minutes: 30),
      cacheStrategy: CacheStrategy.cacheFirst,
      maxCacheSize: 50,
    ),
    
    // ì‚¬ìš©ì ê´€ë ¨
    '/users/{id}': CachePolicy(
      ttl: Duration(hours: 1),
      staleWhileRevalidate: Duration(hours: 2),
      cacheStrategy: CacheStrategy.cacheFirst,
      maxCacheSize: 100,
    ),
    '/users/me': CachePolicy(
      ttl: Duration(minutes: 30),
      staleWhileRevalidate: Duration(hours: 1),
      cacheStrategy: CacheStrategy.networkFirst,
      maxCacheSize: 1,
    ),
    
    // ì í¬ ê´€ë ¨
    '/stores': CachePolicy(
      ttl: Duration(hours: 6),
      staleWhileRevalidate: Duration(hours: 12),
      cacheStrategy: CacheStrategy.cacheFirst,
      maxCacheSize: 200,
    ),
    '/stores/{id}': CachePolicy(
      ttl: Duration(hours: 12),
      staleWhileRevalidate: Duration(days: 1),
      cacheStrategy: CacheStrategy.cacheFirst,
      maxCacheSize: 100,
    ),
    
    // ë­í‚¹ ê´€ë ¨
    '/rankings': CachePolicy(
      ttl: Duration(minutes: 15),
      staleWhileRevalidate: Duration(minutes: 30),
      cacheStrategy: CacheStrategy.networkFirst,
      maxCacheSize: 10,
    ),
    
    // ê²€ìƒ‰ ê´€ë ¨
    '/search': CachePolicy(
      ttl: Duration(minutes: 10),
      staleWhileRevalidate: Duration(minutes: 20),
      cacheStrategy: CacheStrategy.cacheFirst,
      maxCacheSize: 50,
    ),
    
    // ì •ì  ë°ì´í„°
    '/categories': CachePolicy(
      ttl: Duration(days: 7),
      staleWhileRevalidate: Duration(days: 14),
      cacheStrategy: CacheStrategy.cacheFirst,
      maxCacheSize: 1,
    ),
    '/tags': CachePolicy(
      ttl: Duration(days: 1),
      staleWhileRevalidate: Duration(days: 2),
      cacheStrategy: CacheStrategy.cacheFirst,
      maxCacheSize: 1,
    ),
  };
  
  // ìºì‹œ ë¬´íš¨í™” ê·œì¹™
  static const Map<String, List<String>> invalidationRules = {
    'POST /feeds': ['/feeds', '/users/me'],
    'PUT /feeds/{id}': ['/feeds', '/feeds/{id}'],
    'DELETE /feeds/{id}': ['/feeds', '/feeds/{id}'],
    'POST /recommendations': ['/feeds/{feedId}', '/rankings'],
    'POST /follows': ['/users/{userId}', '/users/me'],
  };
  
  // ê¸€ë¡œë²Œ ìºì‹œ ì„¤ì •
  static const globalCacheConfig = GlobalCacheConfig(
    maxMemoryCacheSize: 50 * 1024 * 1024,  // 50MB
    maxDiskCacheSize: 200 * 1024 * 1024,   // 200MB
    defaultTtl: Duration(minutes: 5),
    compressionEnabled: true,
    encryptionEnabled: false,
  );
  
  // ì˜¤í”„ë¼ì¸ ëª¨ë“œ ì„¤ì •
  static const offlineModeConfig = OfflineModeConfig(
    enableOfflineMode: true,
    offlineCacheDuration: Duration(days: 7),
    priorityEndpoints: [
      '/users/me',
      '/feeds',
      '/stores',
    ],
    maxOfflineQueueSize: 100,
  );
}

// ìºì‹œ ì •ì±… ëª¨ë¸
class CachePolicy {
  final Duration ttl;
  final Duration staleWhileRevalidate;
  final CacheStrategy cacheStrategy;
  final int maxCacheSize;
  
  const CachePolicy({
    required this.ttl,
    required this.staleWhileRevalidate,
    required this.cacheStrategy,
    required this.maxCacheSize,
  });
}

// ìºì‹œ ì „ëµ
enum CacheStrategy {
  networkFirst,   // ë„¤íŠ¸ì›Œí¬ ìš°ì„ , ì‹¤íŒ¨ì‹œ ìºì‹œ
  cacheFirst,     // ìºì‹œ ìš°ì„ , ì—†ìœ¼ë©´ ë„¤íŠ¸ì›Œí¬
  networkOnly,    // ìºì‹œ ì‚¬ìš© ì•ˆí•¨
  cacheOnly,      // ë„¤íŠ¸ì›Œí¬ ì‚¬ìš© ì•ˆí•¨
}

// ê¸€ë¡œë²Œ ìºì‹œ ì„¤ì •
class GlobalCacheConfig {
  final int maxMemoryCacheSize;
  final int maxDiskCacheSize;
  final Duration defaultTtl;
  final bool compressionEnabled;
  final bool encryptionEnabled;
  
  const GlobalCacheConfig({
    required this.maxMemoryCacheSize,
    required this.maxDiskCacheSize,
    required this.defaultTtl,
    required this.compressionEnabled,
    required this.encryptionEnabled,
  });
}

// ì˜¤í”„ë¼ì¸ ëª¨ë“œ ì„¤ì •
class OfflineModeConfig {
  final bool enableOfflineMode;
  final Duration offlineCacheDuration;
  final List<String> priorityEndpoints;
  final int maxOfflineQueueSize;
  
  const OfflineModeConfig({
    required this.enableOfflineMode,
    required this.offlineCacheDuration,
    required this.priorityEndpoints,
    required this.maxOfflineQueueSize,
  });
}
```

## 3. êµ¬í˜„

### [í•„ìˆ˜] API ìºì‹œ ë§¤ë‹ˆì €
```dart
// íŒŒì¼: lib/data/services/api_cache_manager.dart
import 'dart:convert';
import 'package:dio/dio.dart';
import 'package:hive/hive.dart';
import 'package:connectivity_plus/connectivity_plus.dart';

class ApiCacheManager {
  static final ApiCacheManager _instance = ApiCacheManager._internal();
  factory ApiCacheManager() => _instance;
  ApiCacheManager._internal();
  
  late Box<CachedResponse> _memoryCache;
  late Box<CachedResponse> _diskCache;
  final _connectivity = Connectivity();
  bool _isOffline = false;
  
  // ì´ˆê¸°í™”
  Future<void> initialize() async {
    // Hive ì´ˆê¸°í™”
    await Hive.initFlutter();
    Hive.registerAdapter(CachedResponseAdapter());
    
    // ìºì‹œ ë°•ìŠ¤ ì—´ê¸°
    _memoryCache = await Hive.openBox<CachedResponse>('memory_cache');
    _diskCache = await Hive.openBox<CachedResponse>('disk_cache');
    
    // ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
    _connectivity.onConnectivityChanged.listen((result) {
      _isOffline = result == ConnectivityResult.none;
    });
    
    // ë§Œë£Œëœ ìºì‹œ ì •ë¦¬
    await _cleanExpiredCache();
  }
  
  // ìºì‹œëœ ì‘ë‹µ ê°€ì ¸ì˜¤ê¸°
  Future<Response?> getCachedResponse({
    required String url,
    required RequestOptions options,
  }) async {
    final cacheKey = _generateCacheKey(url, options);
    final policy = _getCachePolicy(url);
    
    // ìºì‹œ ì „ëµì— ë”°ë¥¸ ì²˜ë¦¬
    switch (policy.cacheStrategy) {
      case CacheStrategy.networkOnly:
        return null;
        
      case CacheStrategy.cacheOnly:
        return _getFromCache(cacheKey);
        
      case CacheStrategy.networkFirst:
        if (_isOffline) {
          return _getFromCache(cacheKey);
        }
        return null;
        
      case CacheStrategy.cacheFirst:
        final cached = await _getFromCache(cacheKey);
        if (cached != null) {
          final age = DateTime.now().difference(cached.requestOptions.extra['cachedAt']);
          
          // TTL ì²´í¬
          if (age < policy.ttl) {
            return cached;
          }
          
          // Stale-while-revalidate
          if (age < policy.staleWhileRevalidate) {
            // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì—…ë°ì´íŠ¸
            _revalidateInBackground(url, options);
            return cached;
          }
        }
        return null;
    }
  }
  
  // ì‘ë‹µ ìºì‹±
  Future<void> cacheResponse({
    required String url,
    required Response response,
  }) async {
    final policy = _getCachePolicy(url);
    if (policy.cacheStrategy == CacheStrategy.networkOnly) {
      return;
    }
    
    final cacheKey = _generateCacheKey(url, response.requestOptions);
    final cachedResponse = CachedResponse(
      key: cacheKey,
      url: url,
      statusCode: response.statusCode ?? 0,
      headers: response.headers.map,
      data: json.encode(response.data),
      cachedAt: DateTime.now(),
      expiresAt: DateTime.now().add(policy.ttl),
    );
    
    // ë©”ëª¨ë¦¬ ìºì‹œì— ì €ì¥
    await _memoryCache.put(cacheKey, cachedResponse);
    
    // ì¤‘ìš”í•œ ì—”ë“œí¬ì¸íŠ¸ëŠ” ë””ìŠ¤í¬ì—ë„ ì €ì¥
    if (CachePolicyConstants.offlineModeConfig.priorityEndpoints
        .any((endpoint) => url.contains(endpoint))) {
      await _diskCache.put(cacheKey, cachedResponse);
    }
    
    // ìºì‹œ í¬ê¸° ê´€ë¦¬
    await _manageCacheSize(url);
  }
  
  // ìºì‹œ ë¬´íš¨í™”
  Future<void> invalidateCache({
    required String pattern,
    bool exact = false,
  }) async {
    final keysToDelete = <String>[];
    
    // ë©”ëª¨ë¦¬ ìºì‹œì—ì„œ ì°¾ê¸°
    for (final key in _memoryCache.keys) {
      if (exact && key == pattern) {
        keysToDelete.add(key);
      } else if (!exact && key.toString().contains(pattern)) {
        keysToDelete.add(key);
      }
    }
    
    // ì‚­ì œ
    for (final key in keysToDelete) {
      await _memoryCache.delete(key);
      await _diskCache.delete(key);
    }
  }
  
  // ìºì‹œ í‚¤ ìƒì„±
  String _generateCacheKey(String url, RequestOptions options) {
    final method = options.method;
    final queryParams = options.queryParameters;
    final body = options.data;
    
    // URLì—ì„œ íŒŒë¼ë¯¸í„° ì¶”ì¶œ
    final uri = Uri.parse(url);
    final pathSegments = uri.pathSegments;
    
    // í‚¤ êµ¬ì„±ìš”ì†Œ
    final components = [
      method,
      uri.path,
      json.encode(queryParams),
      if (body != null) json.encode(body),
    ];
    
    return base64.encode(
      utf8.encode(components.join('|')),
    );
  }
  
  // ìºì‹œ ì •ì±… ê°€ì ¸ì˜¤ê¸°
  CachePolicy _getCachePolicy(String url) {
    // URL íŒ¨í„´ ë§¤ì¹­
    for (final entry in CachePolicyConstants.apiCachePolicies.entries) {
      final pattern = entry.key;
      if (_matchesPattern(url, pattern)) {
        return entry.value;
      }
    }
    
    // ê¸°ë³¸ ì •ì±…
    return CachePolicy(
      ttl: CachePolicyConstants.globalCacheConfig.defaultTtl,
      staleWhileRevalidate: Duration(minutes: 10),
      cacheStrategy: CacheStrategy.networkFirst,
      maxCacheSize: 10,
    );
  }
  
  // URL íŒ¨í„´ ë§¤ì¹­
  bool _matchesPattern(String url, String pattern) {
    // {id} ê°™ì€ íŒŒë¼ë¯¸í„°ë¥¼ ì •ê·œì‹ìœ¼ë¡œ ë³€í™˜
    final regexPattern = pattern.replaceAllMapped(
      RegExp(r'\{(\w+)\}'),
      (match) => r'[\w-]+',
    );
    
    final regex = RegExp('^$regexPattern\$');
    final uri = Uri.parse(url);
    return regex.hasMatch(uri.path);
  }
  
  // ìºì‹œì—ì„œ ê°€ì ¸ì˜¤ê¸°
  Future<Response?> _getFromCache(String cacheKey) async {
    // ë¨¼ì € ë©”ëª¨ë¦¬ì—ì„œ
    var cached = _memoryCache.get(cacheKey);
    
    // ì—†ìœ¼ë©´ ë””ìŠ¤í¬ì—ì„œ
    if (cached == null) {
      cached = _diskCache.get(cacheKey);
      if (cached != null) {
        // ë©”ëª¨ë¦¬ë¡œ ìŠ¹ê²©
        await _memoryCache.put(cacheKey, cached);
      }
    }
    
    if (cached == null) return null;
    
    // Response ê°ì²´ë¡œ ë³€í™˜
    return Response(
      requestOptions: RequestOptions(
        path: cached.url,
        extra: {'cachedAt': cached.cachedAt},
      ),
      statusCode: cached.statusCode,
      headers: Headers.fromMap(cached.headers),
      data: json.decode(cached.data),
    );
  }
  
  // ë°±ê·¸ë¼ìš´ë“œ ì¬ê²€ì¦
  void _revalidateInBackground(String url, RequestOptions options) {
    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë„¤íŠ¸ì›Œí¬ ìš”ì²­
    Future(() async {
      try {
        final dio = Dio();
        final response = await dio.request(
          url,
          options: options,
        );
        
        // ìƒˆ ì‘ë‹µ ìºì‹±
        await cacheResponse(url: url, response: response);
      } catch (e) {
        print('Background revalidation failed: $e');
      }
    });
  }
  
  // ìºì‹œ í¬ê¸° ê´€ë¦¬
  Future<void> _manageCacheSize(String url) async {
    final policy = _getCachePolicy(url);
    
    // í•´ë‹¹ URL íŒ¨í„´ì˜ ìºì‹œ ìˆ˜ í™•ì¸
    final pattern = _getPatternForUrl(url);
    int count = 0;
    final oldestKeys = <String>[];
    
    for (final entry in _memoryCache.toMap().entries) {
      if (entry.value.url.contains(pattern)) {
        count++;
        oldestKeys.add(entry.key);
      }
    }
    
    // ì œí•œ ì´ˆê³¼ì‹œ ì˜¤ë˜ëœ ê²ƒë¶€í„° ì‚­ì œ
    if (count > policy.maxCacheSize) {
      oldestKeys.sort((a, b) {
        final aTime = _memoryCache.get(a)!.cachedAt;
        final bTime = _memoryCache.get(b)!.cachedAt;
        return aTime.compareTo(bTime);
      });
      
      final toDelete = count - policy.maxCacheSize;
      for (int i = 0; i < toDelete; i++) {
        await _memoryCache.delete(oldestKeys[i]);
      }
    }
  }
  
  // URLì—ì„œ íŒ¨í„´ ì¶”ì¶œ
  String _getPatternForUrl(String url) {
    final uri = Uri.parse(url);
    final segments = uri.pathSegments;
    
    // ID ê°™ì€ ë™ì  ì„¸ê·¸ë¨¼íŠ¸ ì œê±°
    final pattern = segments.map((segment) {
      if (RegExp(r'^[\w-]+$').hasMatch(segment) && segment.length > 10) {
        return '{id}';
      }
      return segment;
    }).join('/');
    
    return '/$pattern';
  }
  
  // ë§Œë£Œëœ ìºì‹œ ì •ë¦¬
  Future<void> _cleanExpiredCache() async {
    final now = DateTime.now();
    final keysToDelete = <String>[];
    
    // ë©”ëª¨ë¦¬ ìºì‹œ ì •ë¦¬
    for (final entry in _memoryCache.toMap().entries) {
      if (entry.value.expiresAt.isBefore(now)) {
        keysToDelete.add(entry.key);
      }
    }
    
    for (final key in keysToDelete) {
      await _memoryCache.delete(key);
    }
    
    // ë””ìŠ¤í¬ ìºì‹œ ì •ë¦¬
    keysToDelete.clear();
    for (final entry in _diskCache.toMap().entries) {
      final maxAge = now.subtract(
        CachePolicyConstants.offlineModeConfig.offlineCacheDuration,
      );
      if (entry.value.cachedAt.isBefore(maxAge)) {
        keysToDelete.add(entry.key);
      }
    }
    
    for (final key in keysToDelete) {
      await _diskCache.delete(key);
    }
  }
  
  // ì˜¤í”„ë¼ì¸ í ê´€ë¦¬
  Future<void> queueOfflineRequest({
    required String url,
    required RequestOptions options,
  }) async {
    if (!CachePolicyConstants.offlineModeConfig.enableOfflineMode) {
      return;
    }
    
    // ì˜¤í”„ë¼ì¸ íì— ì¶”ê°€
    final queue = await Hive.openBox<OfflineRequest>('offline_queue');
    
    if (queue.length >= CachePolicyConstants.offlineModeConfig.maxOfflineQueueSize) {
      // ê°€ì¥ ì˜¤ë˜ëœ ìš”ì²­ ì œê±°
      await queue.deleteAt(0);
    }
    
    await queue.add(OfflineRequest(
      url: url,
      method: options.method,
      headers: options.headers,
      data: options.data,
      timestamp: DateTime.now(),
    ));
  }
  
  // ìºì‹œ í†µê³„
  Future<CacheStats> getCacheStats() async {
    final memoryCacheSize = _calculateCacheSize(_memoryCache);
    final diskCacheSize = _calculateCacheSize(_diskCache);
    
    return CacheStats(
      memoryCacheCount: _memoryCache.length,
      memoryCacheSize: memoryCacheSize,
      diskCacheCount: _diskCache.length,
      diskCacheSize: diskCacheSize,
      hitRate: _calculateHitRate(),
    );
  }
  
  int _calculateCacheSize(Box<CachedResponse> box) {
    int totalSize = 0;
    for (final value in box.values) {
      totalSize += value.data.length;
    }
    return totalSize;
  }
  
  double _calculateHitRate() {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” hit/miss ì¹´ìš´í„° ìœ ì§€
    return 0.0;
  }
}

// ìºì‹œëœ ì‘ë‹µ ëª¨ë¸
@HiveType(typeId: 0)
class CachedResponse extends HiveObject {
  @HiveField(0)
  final String key;
  
  @HiveField(1)
  final String url;
  
  @HiveField(2)
  final int statusCode;
  
  @HiveField(3)
  final Map<String, List<String>> headers;
  
  @HiveField(4)
  final String data;
  
  @HiveField(5)
  final DateTime cachedAt;
  
  @HiveField(6)
  final DateTime expiresAt;
  
  CachedResponse({
    required this.key,
    required this.url,
    required this.statusCode,
    required this.headers,
    required this.data,
    required this.cachedAt,
    required this.expiresAt,
  });
}

// ì˜¤í”„ë¼ì¸ ìš”ì²­
@HiveType(typeId: 1)
class OfflineRequest extends HiveObject {
  @HiveField(0)
  final String url;
  
  @HiveField(1)
  final String method;
  
  @HiveField(2)
  final Map<String, dynamic> headers;
  
  @HiveField(3)
  final dynamic data;
  
  @HiveField(4)
  final DateTime timestamp;
  
  OfflineRequest({
    required this.url,
    required this.method,
    required this.headers,
    required this.data,
    required this.timestamp,
  });
}

// ìºì‹œ í†µê³„
class CacheStats {
  final int memoryCacheCount;
  final int memoryCacheSize;
  final int diskCacheCount;
  final int diskCacheSize;
  final double hitRate;
  
  CacheStats({
    required this.memoryCacheCount,
    required this.memoryCacheSize,
    required this.diskCacheCount,
    required this.diskCacheSize,
    required this.hitRate,
  });
}
```

### [í•„ìˆ˜] Dio ì¸í„°ì…‰í„°
```dart
// íŒŒì¼: lib/data/network/interceptors/cache_interceptor.dart
import 'package:dio/dio.dart';

class CacheInterceptor extends Interceptor {
  final ApiCacheManager _cacheManager;
  
  CacheInterceptor(this._cacheManager);
  
  @override
  void onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    // GET ìš”ì²­ë§Œ ìºì‹±
    if (options.method != 'GET') {
      return handler.next(options);
    }
    
    // ìºì‹œ í™•ì¸
    final cachedResponse = await _cacheManager.getCachedResponse(
      url: options.uri.toString(),
      options: options,
    );
    
    if (cachedResponse != null) {
      // ìºì‹œëœ ì‘ë‹µ ë°˜í™˜
      return handler.resolve(cachedResponse);
    }
    
    // ìºì‹œ ì—†ìœ¼ë©´ ê³„ì† ì§„í–‰
    handler.next(options);
  }
  
  @override
  void onResponse(
    Response response,
    ResponseInterceptorHandler handler,
  ) async {
    // ì„±ê³µ ì‘ë‹µë§Œ ìºì‹±
    if (response.statusCode == 200) {
      await _cacheManager.cacheResponse(
        url: response.requestOptions.uri.toString(),
        response: response,
      );
    }
    
    handler.next(response);
  }
  
  @override
  void onError(
    DioError err,
    ErrorInterceptorHandler handler,
  ) async {
    // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ì‹œ ìºì‹œ í™•ì¸
    if (err.type == DioErrorType.other || 
        err.type == DioErrorType.connectionTimeout) {
      
      final cachedResponse = await _cacheManager.getCachedResponse(
        url: err.requestOptions.uri.toString(),
        options: err.requestOptions,
      );
      
      if (cachedResponse != null) {
        // ìºì‹œëœ ì‘ë‹µ ë°˜í™˜
        return handler.resolve(cachedResponse);
      }
      
      // POST/PUT/DELETE ìš”ì²­ì€ ì˜¤í”„ë¼ì¸ íì— ì¶”ê°€
      if (err.requestOptions.method != 'GET') {
        await _cacheManager.queueOfflineRequest(
          url: err.requestOptions.uri.toString(),
          options: err.requestOptions,
        );
      }
    }
    
    handler.next(err);
  }
}
```

## 4. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ìºì‹œ í‚¤ ìƒì„± ì •í™•ì„±
- [ ] TTL ë§Œë£Œ ì •ìƒ ì‘ë™
- [ ] Stale-while-revalidate ë™ì‘ í™•ì¸
- [ ] ìºì‹œ ë¬´íš¨í™” ê·œì¹™ ì ìš©
- [ ] ì˜¤í”„ë¼ì¸ ëª¨ë“œ ì •ìƒ ì‘ë™
- [ ] ë©”ëª¨ë¦¬ 50MB ì´í•˜ ìœ ì§€
- [ ] ë””ìŠ¤í¬ 200MB ì´í•˜ ìœ ì§€