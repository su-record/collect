# ğŸ—ºï¸ 10.7 ì§€ë„ ì„±ëŠ¥ ìµœì í™”

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ë§ˆì»¤ í´ëŸ¬ìŠ¤í„°ë§ ì „ëµ](#2-ë§ˆì»¤-í´ëŸ¬ìŠ¤í„°ë§-ì „ëµ)
3. [ì¤Œ ë ˆë²¨ë³„ ë°ì´í„° ë¡œë”©](#3-ì¤Œ-ë ˆë²¨ë³„-ë°ì´í„°-ë¡œë”©)
4. [ë§ˆì»¤ ë Œë”ë§ ìµœì í™”](#4-ë§ˆì»¤-ë Œë”ë§-ìµœì í™”)
5. [ë©”ëª¨ë¦¬ ê´€ë¦¬](#5-ë©”ëª¨ë¦¬-ê´€ë¦¬)

## 1. ê°œìš”

Fallingoì˜ ì§€ë„ ê¸°ë°˜ ê¸°ëŠ¥ì„ ìµœì í™”í•˜ì—¬ ë¶€ë“œëŸ¬ìš´ ì‚¬ìš©ì ê²½í—˜ì„ ì œê³µí•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… 1,000ê°œ ì´ìƒ ë§ˆì»¤ ì²˜ë¦¬
- âœ… 60fps ìŠ¤í¬ë¡¤ ì„±ëŠ¥ ìœ ì§€
- âœ… ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ < 100MB
- âœ… ì´ˆê¸° ë¡œë”© < 2ì´ˆ

## 2. ë§ˆì»¤ í´ëŸ¬ìŠ¤í„°ë§ ì „ëµ

### [í•„ìˆ˜] í´ëŸ¬ìŠ¤í„°ë§ ë§¤ë‹ˆì €
```dart
// íŒŒì¼: lib/features/map/services/marker_cluster_manager.dart
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:google_maps_cluster_manager/google_maps_cluster_manager.dart';

class MarkerClusterManager {
  late ClusterManager<MarkerItem> _clusterManager;
  final Map<MarkerId, MarkerItem> _items = {};
  
  // í´ëŸ¬ìŠ¤í„°ë§ ì„¤ì •
  static const ClusteringConfig config = ClusteringConfig(
    minClusterSize: 3,        // ìµœì†Œ í´ëŸ¬ìŠ¤í„° í¬ê¸°
    maxClusterZoom: 14,       // í´ëŸ¬ìŠ¤í„°ë§ ìµœëŒ€ ì¤Œ
    gridSize: 60,             // ê·¸ë¦¬ë“œ í¬ê¸° (í”½ì…€)
    animationDuration: 300,   // ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ (ms)
  );
  
  Future<void> initialize({
    required GoogleMapController mapController,
    required Function(Set<Marker>) updateMarkers,
  }) async {
    _clusterManager = ClusterManager<MarkerItem>(
      _items.values.toList(),
      _updateMarkers,
      markerBuilder: _markerBuilder,
      initialZoom: 15.0,
      stopClusteringZoom: 16.0,
    );
  }
  
  // ë§ˆì»¤ ë¹Œë”
  Future<Marker> _markerBuilder(Cluster<MarkerItem> cluster) async {
    if (cluster.isMultiple) {
      return _createClusterMarker(cluster);
    } else {
      return _createSingleMarker(cluster.items.first);
    }
  }
  
  // í´ëŸ¬ìŠ¤í„° ë§ˆì»¤ ìƒì„±
  Future<Marker> _createClusterMarker(Cluster<MarkerItem> cluster) async {
    // ë§ˆì»¤ íƒ€ì…ë³„ ê°œìˆ˜ ê³„ì‚°
    final typeCount = <MarkerType, int>{};
    for (final item in cluster.items) {
      typeCount[item.type] = (typeCount[item.type] ?? 0) + 1;
    }
    
    // ì»¤ìŠ¤í…€ í´ëŸ¬ìŠ¤í„° ì•„ì´ì½˜ ìƒì„±
    final icon = await _createClusterIcon(
      count: cluster.count,
      typeCount: typeCount,
    );
    
    return Marker(
      markerId: MarkerId('cluster_${cluster.getId()}'),
      position: cluster.location,
      icon: icon,
      onTap: () => _onClusterTap(cluster),
    );
  }
  
  // í´ëŸ¬ìŠ¤í„° ì•„ì´ì½˜ ìƒì„± (Canvas ì‚¬ìš©)
  Future<BitmapDescriptor> _createClusterIcon({
    required int count,
    required Map<MarkerType, int> typeCount,
  }) async {
    final size = _getClusterSize(count);
    final pictureRecorder = PictureRecorder();
    final canvas = Canvas(pictureRecorder);
    
    // ë°°ê²½ ì›
    final paint = Paint()
      ..color = AppColors.primaryOrange.withOpacity(0.8)
      ..style = PaintingStyle.fill;
    
    canvas.drawCircle(
      Offset(size / 2, size / 2),
      size / 2,
      paint,
    );
    
    // í…Œë‘ë¦¬
    paint
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;
    
    canvas.drawCircle(
      Offset(size / 2, size / 2),
      size / 2 - 1.5,
      paint,
    );
    
    // ìˆ«ì í…ìŠ¤íŠ¸
    final textPainter = TextPainter(
      text: TextSpan(
        text: count.toString(),
        style: TextStyle(
          color: Colors.white,
          fontSize: size * 0.4,
          fontWeight: FontWeight.bold,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size - textPainter.width) / 2,
        (size - textPainter.height) / 2,
      ),
    );
    
    final image = await pictureRecorder
        .endRecording()
        .toImage(size.toInt(), size.toInt());
    
    final bytes = await image.toByteData(format: ImageByteFormat.png);
    return BitmapDescriptor.fromBytes(bytes!.buffer.asUint8List());
  }
  
  double _getClusterSize(int count) {
    if (count < 10) return 40;
    if (count < 50) return 50;
    if (count < 100) return 60;
    return 70;
  }
}
```

### [í•„ìˆ˜] ë™ì  í´ëŸ¬ìŠ¤í„°ë§
```dart
// íŒŒì¼: lib/features/map/services/dynamic_clustering.dart
class DynamicClusteringService {
  // ì¤Œ ë ˆë²¨ë³„ í´ëŸ¬ìŠ¤í„°ë§ ì „ëµ
  static const Map<int, ClusterStrategy> strategies = {
    // ì¤Œ 1-8: ë„ì‹œ ë‹¨ìœ„ í´ëŸ¬ìŠ¤í„°ë§
    8: ClusterStrategy(gridSize: 200, minSize: 10),
    // ì¤Œ 9-12: êµ¬ì—­ ë‹¨ìœ„
    12: ClusterStrategy(gridSize: 100, minSize: 5),
    // ì¤Œ 13-15: ë™ë„¤ ë‹¨ìœ„
    15: ClusterStrategy(gridSize: 60, minSize: 3),
    // ì¤Œ 16+: í´ëŸ¬ìŠ¤í„°ë§ ì—†ìŒ
    20: ClusterStrategy(gridSize: 0, minSize: 0),
  };
  
  // ì„±ëŠ¥ ê¸°ë°˜ ë™ì  ì¡°ì •
  Future<ClusterStrategy> getOptimalStrategy({
    required double zoomLevel,
    required int markerCount,
    required double fps,
  }) async {
    final baseStrategy = _getBaseStrategy(zoomLevel);
    
    // FPSê°€ ë‚®ìœ¼ë©´ ë” ê³µê²©ì ì¸ í´ëŸ¬ìŠ¤í„°ë§
    if (fps < 30 && markerCount > 100) {
      return ClusterStrategy(
        gridSize: baseStrategy.gridSize * 1.5,
        minSize: baseStrategy.minSize ~/ 2,
      );
    }
    
    // ë§ˆì»¤ê°€ ë§ìœ¼ë©´ ê·¸ë¦¬ë“œ í¬ê¸° ì¦ê°€
    if (markerCount > 500) {
      return ClusterStrategy(
        gridSize: baseStrategy.gridSize * 1.2,
        minSize: baseStrategy.minSize,
      );
    }
    
    return baseStrategy;
  }
  
  ClusterStrategy _getBaseStrategy(double zoom) {
    for (final entry in strategies.entries) {
      if (zoom <= entry.key) {
        return entry.value;
      }
    }
    return strategies[20]!;
  }
}
```

## 3. ì¤Œ ë ˆë²¨ë³„ ë°ì´í„° ë¡œë”©

### [í•„ìˆ˜] ë ˆë²¨ë³„ ë°ì´í„° ë¡œë”
```dart
// íŒŒì¼: lib/features/map/services/zoom_based_loader.dart
class ZoomBasedDataLoader {
  static const Map<int, LoadingStrategy> zoomStrategies = {
    10: LoadingStrategy(
      radius: 50.0,  // 50km
      maxMarkers: 20,
      types: [MarkerType.event],  // ì´ë²¤íŠ¸ë§Œ
    ),
    13: LoadingStrategy(
      radius: 10.0,  // 10km
      maxMarkers: 50,
      types: [MarkerType.event, MarkerType.store],
    ),
    15: LoadingStrategy(
      radius: 3.0,   // 3km
      maxMarkers: 100,
      types: MarkerType.values,  // ëª¨ë“  íƒ€ì…
    ),
    18: LoadingStrategy(
      radius: 1.0,   // 1km
      maxMarkers: 200,
      types: MarkerType.values,
      includeDetails: true,
    ),
  };
  
  final SupabaseClient _supabase;
  final _cache = <String, CachedData>{};
  
  Future<List<MarkerData>> loadMarkersForZoom({
    required LatLng center,
    required double zoom,
    required LatLngBounds bounds,
  }) async {
    final strategy = _getStrategyForZoom(zoom);
    final cacheKey = _getCacheKey(center, zoom, strategy);
    
    // ìºì‹œ í™•ì¸
    if (_cache.containsKey(cacheKey)) {
      final cached = _cache[cacheKey]!;
      if (cached.isValid) {
        return cached.data;
      }
    }
    
    // ë·°í¬íŠ¸ ê¸°ë°˜ ë¡œë”©
    final markers = await _loadFromDatabase(
      bounds: bounds,
      strategy: strategy,
    );
    
    // ìºì‹œ ì €ì¥
    _cache[cacheKey] = CachedData(
      data: markers,
      timestamp: DateTime.now(),
    );
    
    // ë©”ëª¨ë¦¬ ê´€ë¦¬
    _cleanupCache();
    
    return markers;
  }
  
  Future<List<MarkerData>> _loadFromDatabase({
    required LatLngBounds bounds,
    required LoadingStrategy strategy,
  }) async {
    try {
      // PostgreSQL í•¨ìˆ˜ í˜¸ì¶œ
      final response = await _supabase.rpc(
        'get_markers_in_bounds',
        params: {
          'sw_lat': bounds.southwest.latitude,
          'sw_lng': bounds.southwest.longitude,
          'ne_lat': bounds.northeast.latitude,
          'ne_lng': bounds.northeast.longitude,
          'marker_types': strategy.types.map((t) => t.name).toList(),
          'max_count': strategy.maxMarkers,
          'include_details': strategy.includeDetails,
        },
      );
      
      return (response as List)
          .map((json) => MarkerData.fromJson(json))
          .toList();
    } catch (e) {
      print('ë§ˆì»¤ ë¡œë”© ì˜¤ë¥˜: $e');
      return [];
    }
  }
  
  // í”„ë¦¬ë¡œë”©
  Future<void> preloadAdjacentAreas({
    required LatLng center,
    required double zoom,
  }) async {
    if (zoom < 13) return;  // ë‚®ì€ ì¤Œì—ì„œëŠ” í”„ë¦¬ë¡œë”© ì•ˆ í•¨
    
    final offset = 0.01 * (20 - zoom);  // ì¤Œì— ë”°ë¥¸ ì˜¤í”„ì…‹
    
    final adjacentCenters = [
      LatLng(center.latitude + offset, center.longitude),
      LatLng(center.latitude - offset, center.longitude),
      LatLng(center.latitude, center.longitude + offset),
      LatLng(center.latitude, center.longitude - offset),
    ];
    
    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¡œë”©
    for (final adjCenter in adjacentCenters) {
      unawaited(loadMarkersForZoom(
        center: adjCenter,
        zoom: zoom,
        bounds: _getBoundsForCenter(adjCenter, zoom),
      ));
    }
  }
}
```

### [í•„ìˆ˜] ì ì§„ì  ë¡œë”©
```dart
// íŒŒì¼: lib/features/map/services/progressive_loader.dart
class ProgressiveLoader {
  final _loadingQueue = Queue<LoadTask>();
  bool _isLoading = false;
  
  // ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë¡œë”©
  Future<void> loadMarkers({
    required LatLngBounds visibleBounds,
    required double zoom,
    required Function(List<MarkerData>) onLoad,
  }) async {
    // í™”ë©´ ì¤‘ì•™ë¶€í„° ë¡œë”©
    final center = LatLng(
      (visibleBounds.northeast.latitude + visibleBounds.southwest.latitude) / 2,
      (visibleBounds.northeast.longitude + visibleBounds.southwest.longitude) / 2,
    );
    
    // êµ¬ì—­ ë¶„í• 
    final sectors = _divideBounds(visibleBounds, zoom);
    
    // ìš°ì„ ìˆœìœ„ íì— ì¶”ê°€
    for (var i = 0; i < sectors.length; i++) {
      final distance = _calculateDistance(center, sectors[i].center);
      _loadingQueue.add(LoadTask(
        bounds: sectors[i],
        priority: i == 0 ? 0 : distance,  // ì¤‘ì•™ì€ ìµœìš°ì„ 
        onComplete: onLoad,
      ));
    }
    
    // ë¡œë”© ì‹œì‘
    if (!_isLoading) {
      _processQueue();
    }
  }
  
  Future<void> _processQueue() async {
    _isLoading = true;
    
    while (_loadingQueue.isNotEmpty) {
      // ìš°ì„ ìˆœìœ„ ì •ë ¬
      final sortedTasks = _loadingQueue.toList()
        ..sort((a, b) => a.priority.compareTo(b.priority));
      
      _loadingQueue.clear();
      _loadingQueue.addAll(sortedTasks);
      
      final task = _loadingQueue.removeFirst();
      
      try {
        final markers = await _loadSector(task.bounds);
        task.onComplete(markers);
        
        // í”„ë ˆì„ ì–‘ë³´
        await Future.delayed(Duration(milliseconds: 16));
      } catch (e) {
        print('ì„¹í„° ë¡œë”© ì˜¤ë¥˜: $e');
      }
    }
    
    _isLoading = false;
  }
}
```

## 4. ë§ˆì»¤ ë Œë”ë§ ìµœì í™”

### [í•„ìˆ˜] ì»¤ìŠ¤í…€ ë§ˆì»¤ ë Œë”ëŸ¬
```dart
// íŒŒì¼: lib/features/map/presentation/widgets/optimized_marker_layer.dart
class OptimizedMarkerLayer extends StatefulWidget {
  final List<MarkerData> markers;
  final GoogleMapController mapController;
  final double currentZoom;
  
  @override
  State<OptimizedMarkerLayer> createState() => _OptimizedMarkerLayerState();
}

class _OptimizedMarkerLayerState extends State<OptimizedMarkerLayer> {
  final Map<String, BitmapDescriptor> _iconCache = {};
  final Map<MarkerId, Marker> _visibleMarkers = {};
  
  // ë·°í¬íŠ¸ ì»¬ë§
  Future<void> _updateVisibleMarkers() async {
    final bounds = await widget.mapController.getVisibleRegion();
    final newVisibleMarkers = <MarkerId, Marker>{};
    
    for (final markerData in widget.markers) {
      // í™”ë©´ì— ë³´ì´ëŠ” ë§ˆì»¤ë§Œ ë Œë”ë§
      if (_isInBounds(markerData.position, bounds)) {
        final marker = await _createOptimizedMarker(markerData);
        newVisibleMarkers[marker.markerId] = marker;
      }
    }
    
    setState(() {
      _visibleMarkers.clear();
      _visibleMarkers.addAll(newVisibleMarkers);
    });
  }
  
  // ìµœì í™”ëœ ë§ˆì»¤ ìƒì„±
  Future<Marker> _createOptimizedMarker(MarkerData data) async {
    // ì•„ì´ì½˜ ìºì‹±
    final iconKey = '${data.type}_${data.subType}';
    if (!_iconCache.containsKey(iconKey)) {
      _iconCache[iconKey] = await _createIcon(data.type, data.subType);
    }
    
    return Marker(
      markerId: MarkerId(data.id),
      position: data.position,
      icon: _iconCache[iconKey]!,
      // ì¤Œ ë ˆë²¨ì— ë”°ë¥¸ ì •ë³´ í‘œì‹œ
      infoWindow: widget.currentZoom > 15 
          ? InfoWindow(
              title: data.title,
              snippet: data.snippet,
            )
          : InfoWindow.noText,
      // íƒ­ ìµœì í™”
      consumeTapEvents: true,
      onTap: () => _onMarkerTap(data),
    );
  }
  
  // ë°°ì¹˜ ì•„ì´ì½˜ ìƒì„±
  Future<void> _preloadIcons() async {
    final iconTypes = <String>{};
    
    for (final marker in widget.markers) {
      iconTypes.add('${marker.type}_${marker.subType}');
    }
    
    // ë³‘ë ¬ ë¡œë”©
    await Future.wait(
      iconTypes.map((key) async {
        if (!_iconCache.containsKey(key)) {
          final parts = key.split('_');
          _iconCache[key] = await _createIcon(
            MarkerType.values.firstWhere((t) => t.name == parts[0]),
            parts.length > 1 ? parts[1] : null,
          );
        }
      }),
    );
  }
}
```

### [í•„ìˆ˜] ì• ë‹ˆë©”ì´ì…˜ ìµœì í™”
```dart
// íŒŒì¼: lib/features/map/services/marker_animation_controller.dart
class MarkerAnimationController {
  final Map<MarkerId, AnimationController> _controllers = {};
  final TickerProvider vsync;
  
  // í”„ë ˆì„ ë“œë¡­ ë°©ì§€
  static const int maxConcurrentAnimations = 10;
  final _animationQueue = Queue<AnimationTask>();
  int _activeAnimations = 0;
  
  // ë¶€ë“œëŸ¬ìš´ ë§ˆì»¤ ë“±ì¥
  Future<void> animateMarkerAppearance(
    List<Marker> markers,
  ) async {
    // ê±°ë¦¬ë³„ ì§€ì—° ì‹œê°„ ê³„ì‚°
    final center = _calculateCenter(markers);
    final sortedMarkers = markers.toList()
      ..sort((a, b) {
        final distA = _distance(a.position, center);
        final distB = _distance(b.position, center);
        return distA.compareTo(distB);
      });
    
    // ìˆœì°¨ì  ì• ë‹ˆë©”ì´ì…˜
    for (var i = 0; i < sortedMarkers.length; i++) {
      final delay = i * 50;  // 50ms ê°„ê²©
      
      if (_activeAnimations < maxConcurrentAnimations) {
        _startAnimation(sortedMarkers[i], delay);
      } else {
        _animationQueue.add(AnimationTask(
          marker: sortedMarkers[i],
          delay: delay,
        ));
      }
    }
  }
  
  void _startAnimation(Marker marker, int delayMs) {
    _activeAnimations++;
    
    Future.delayed(Duration(milliseconds: delayMs), () {
      final controller = AnimationController(
        duration: Duration(milliseconds: 300),
        vsync: vsync,
      );
      
      _controllers[marker.markerId] = controller;
      
      controller.forward().then((_) {
        _activeAnimations--;
        _processQueue();
      });
    });
  }
  
  // í”„ë ˆì„ ìµœì í™”
  void optimizeForPerformance(double fps) {
    if (fps < 30) {
      // ì• ë‹ˆë©”ì´ì…˜ ë¹„í™œì„±í™”
      _controllers.forEach((_, controller) {
        controller.stop();
      });
    } else if (fps < 45) {
      // ì• ë‹ˆë©”ì´ì…˜ ë‹¨ìˆœí™”
      _controllers.forEach((_, controller) {
        controller.duration = Duration(milliseconds: 150);
      });
    }
  }
}
```

## 5. ë©”ëª¨ë¦¬ ê´€ë¦¬

### [í•„ìˆ˜] ë©”ëª¨ë¦¬ íš¨ìœ¨ì  ìºì‹±
```dart
// íŒŒì¼: lib/features/map/services/memory_efficient_cache.dart
class MemoryEfficientCache {
  // LRU ìºì‹œ êµ¬í˜„
  final int maxSize;
  final int maxMemoryMB;
  final _cache = LinkedHashMap<String, CacheEntry>();
  int _currentMemoryUsage = 0;
  
  MemoryEfficientCache({
    this.maxSize = 1000,
    this.maxMemoryMB = 50,
  });
  
  // ìŠ¤ë§ˆíŠ¸ ìºì‹±
  void put(String key, dynamic data, {int? sizeBytes}) {
    final size = sizeBytes ?? _estimateSize(data);
    
    // ë©”ëª¨ë¦¬ ì œí•œ ì²´í¬
    while (_currentMemoryUsage + size > maxMemoryMB * 1024 * 1024 ||
           _cache.length >= maxSize) {
      _evictOldest();
    }
    
    _cache[key] = CacheEntry(
      data: data,
      size: size,
      lastAccess: DateTime.now(),
      accessCount: 0,
    );
    
    _currentMemoryUsage += size;
  }
  
  // ì ì‘í˜• ì œê±° ì •ì±…
  void _evictOldest() {
    if (_cache.isEmpty) return;
    
    // LFU + LRU í˜¼í•© ì „ëµ
    final candidates = _cache.entries.toList()
      ..sort((a, b) {
        // ì ‘ê·¼ ë¹ˆë„ê°€ ë‚®ê³  ì˜¤ë˜ëœ í•­ëª© ìš°ì„  ì œê±°
        final scoreA = a.value.accessCount / 
            DateTime.now().difference(a.value.lastAccess).inMinutes;
        final scoreB = b.value.accessCount / 
            DateTime.now().difference(b.value.lastAccess).inMinutes;
        return scoreA.compareTo(scoreB);
      });
    
    final toRemove = candidates.first;
    _currentMemoryUsage -= toRemove.value.size;
    _cache.remove(toRemove.key);
  }
  
  // ë©”ëª¨ë¦¬ ì••ë°• ì‹œ ëŒ€ì‘
  void handleMemoryPressure() {
    // 50% ì œê±°
    final targetSize = _cache.length ~/ 2;
    while (_cache.length > targetSize) {
      _evictOldest();
    }
    
    // ì´ë¯¸ì§€ í’ˆì§ˆ ë‚®ì¶”ê¸°
    _downgradeImageQuality();
  }
}
```

### [í•„ìˆ˜] ë¦¬ì†ŒìŠ¤ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬
```dart
// íŒŒì¼: lib/features/map/services/resource_lifecycle_manager.dart
class ResourceLifecycleManager {
  final List<StreamSubscription> _subscriptions = [];
  final Map<String, Timer> _timers = {};
  final Map<String, Uint8List> _imageCache = {};
  
  // ìë™ ì •ë¦¬
  void registerResource(dynamic resource, String tag) {
    if (resource is StreamSubscription) {
      _subscriptions.add(resource);
    } else if (resource is Timer) {
      _timers[tag] = resource;
    } else if (resource is Uint8List) {
      _imageCache[tag] = resource;
    }
  }
  
  // ì£¼ê¸°ì  ë©”ëª¨ë¦¬ ì •ë¦¬
  void startMemoryMonitoring() {
    _timers['memory_monitor'] = Timer.periodic(
      Duration(seconds: 30),
      (_) => _checkMemoryUsage(),
    );
  }
  
  void _checkMemoryUsage() {
    final usage = _calculateMemoryUsage();
    
    if (usage > 80) {  // 80MB ì´ìƒ
      // ì˜¤ë˜ëœ ì´ë¯¸ì§€ ì œê±°
      _cleanupOldImages();
      
      // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
      _forceGarbageCollection();
    }
  }
  
  void _cleanupOldImages() {
    final now = DateTime.now();
    final toRemove = <String>[];
    
    _imageCache.forEach((key, data) {
      // 5ë¶„ ì´ìƒ ëœ ì´ë¯¸ì§€ ì œê±°
      if (key.contains('_timestamp_')) {
        final timestamp = DateTime.parse(
          key.split('_timestamp_')[1]
        );
        if (now.difference(timestamp).inMinutes > 5) {
          toRemove.add(key);
        }
      }
    });
    
    toRemove.forEach(_imageCache.remove);
  }
  
  // ì „ì²´ ì •ë¦¬
  void dispose() {
    for (final sub in _subscriptions) {
      sub.cancel();
    }
    _subscriptions.clear();
    
    _timers.forEach((_, timer) => timer.cancel());
    _timers.clear();
    
    _imageCache.clear();
  }
}
```

### [ì„ íƒ] ë©”ëª¨ë¦¬ í”„ë¡œíŒŒì¼ë§
```dart
// íŒŒì¼: lib/features/map/debug/memory_profiler.dart
class MapMemoryProfiler {
  static void profileMemoryUsage() {
    if (!kDebugMode) return;
    
    Timer.periodic(Duration(seconds: 5), (_) {
      final info = ProcessInfo();
      print('''
      === ì§€ë„ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ===
      ì´ ë©”ëª¨ë¦¬: ${info.currentRss ~/ 1024 ~/ 1024}MB
      ë§ˆì»¤ ìºì‹œ: ${_markerCacheSize()}MB
      ì´ë¯¸ì§€ ìºì‹œ: ${_imageCacheSize()}MB
      í™œì„± ì• ë‹ˆë©”ì´ì…˜: ${_activeAnimations}
      ====================
      ''');
    });
  }
}
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] í´ëŸ¬ìŠ¤í„°ë§ ë§¤ë‹ˆì € êµ¬í˜„
- [ ] ì¤Œ ë ˆë²¨ë³„ ë¡œë”© ì „ëµ ì ìš©
- [ ] ë§ˆì»¤ ë Œë”ë§ ìµœì í™” ì™„ë£Œ
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ < 100MB ë‹¬ì„±