# ğŸŒ 10.6 ê¸€ë¡œë²Œ CDN êµ¬ì„±

## ğŸ“‹ ëª©ì°¨

1. [ê°œìš”](#1-ê°œìš”)
2. [CDN ì•„í‚¤í…ì²˜](#2-cdn-ì•„í‚¤í…ì²˜)
3. [ìºì‹± ì •ì±…](#3-ìºì‹±-ì •ì±…)
4. [ì„±ëŠ¥ ìµœì í™”](#4-ì„±ëŠ¥-ìµœì í™”)
5. [ë¹„ìš© ê´€ë¦¬](#5-ë¹„ìš©-ê´€ë¦¬)

## 1. ê°œìš”

Fallingoì˜ ê¸€ë¡œë²Œ ì„œë¹„ìŠ¤ë¥¼ ìœ„í•œ CDN êµ¬ì„±ìœ¼ë¡œ ë¹ ë¥¸ ì½˜í…ì¸  ì „ì†¡ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸

- âœ… ì£¼ìš” 3ê°œ ì§€ì—­ ìš°ì„  ë°°í¬ (ì•„ì‹œì•„, ë¶ë¯¸, ìœ ëŸ½)
- âœ… ì´ë¯¸ì§€ ì¤‘ì‹¬ ìµœì í™”ë¡œ 90% ìºì‹œ ì ì¤‘ë¥ 
- âœ… ì§€ì—­ë³„ 50ms ì´í•˜ ì‘ë‹µ ì‹œê°„ ëª©í‘œ

## 2. CDN ì•„í‚¤í…ì²˜

### [í•„ìˆ˜] ì§€ì—­ë³„ ì—£ì§€ ì„œë²„ ë°°ì¹˜

```yaml
# íŒŒì¼: config/cdn_regions.yaml
cdn_configuration:
  primary_regions: # 1ì°¨ ë°°í¬ (ì¶œì‹œ ì‹œì )
    asia_pacific:
      - location: "Seoul, South Korea"
        code: "ICN"
        priority: 1
        coverage: ["KR", "JP", "CN"]
      - location: "Tokyo, Japan"
        code: "NRT"
        priority: 1
        coverage: ["JP", "KR", "TW"]
      - location: "Singapore"
        code: "SIN"
        priority: 2
        coverage: ["SG", "MY", "TH", "ID"]

  secondary_regions: # 2ì°¨ ë°°í¬ (6ê°œì›” í›„)
    north_america:
      - location: "Los Angeles, USA"
        code: "LAX"
        priority: 3
        coverage: ["US-West", "MX"]
      - location: "New York, USA"
        code: "JFK"
        priority: 3
        coverage: ["US-East", "CA"]

    europe:
      - location: "Frankfurt, Germany"
        code: "FRA"
        priority: 4
        coverage: ["DE", "FR", "NL"]
      - location: "London, UK"
        code: "LHR"
        priority: 4
        coverage: ["UK", "IE", "ES"]
```

### [í•„ìˆ˜] CDN ì œê³µì—…ì²´ ì„ íƒ

```python
# íŒŒì¼: backend/config/cdn_provider.py
CDN_PROVIDERS = {
    "primary": {
        "provider": "Cloudflare",
        "features": [
            "ë¬´ë£Œ í”Œëœìœ¼ë¡œ ì‹œì‘ ê°€ëŠ¥",
            "ì´ë¯¸ì§€ ìµœì í™” (Polish)",
            "ìë™ WebP ë³€í™˜",
            "ê¸€ë¡œë²Œ ë„¤íŠ¸ì›Œí¬ (275+ PoP)"
        ],
        "pricing": "Free ~ Enterprise"
    },
    "alternative": {
        "provider": "Bunny CDN",
        "features": [
            "ì €ë ´í•œ ê°€ê²© ($0.01/GB)",
            "ì´ë¯¸ì§€ ìµœì í™” ì—”ì§„",
            "ì¦‰ì‹œ purge ì§€ì›",
            "114ê°œ PoP"
        ],
        "pricing": "$0.01-0.06/GB"
    },
    "enterprise": {
        "provider": "AWS CloudFront",
        "features": [
            "AWS ì„œë¹„ìŠ¤ í†µí•©",
            "Lambda@Edge ì§€ì›",
            "ì‹¤ì‹œê°„ ë¡œê·¸",
            "450+ PoP"
        ],
        "pricing": "$0.085/GB (ì²« 10TB)"
    }
}
```

### [í•„ìˆ˜] Origin ì„œë²„ êµ¬ì„±

```nginx
# íŒŒì¼: config/nginx/origin.conf
server {
    listen 80;
    server_name origin.fallingo.com;

    # ì´ë¯¸ì§€ ì €ì¥ì†Œ ìœ„ì¹˜
    location /images/ {
        proxy_pass http://supabase-storage:5000/;

        # Origin ìºì‹œ í—¤ë”
        add_header Cache-Control "public, max-age=31536000";
        add_header X-Content-Type-Options "nosniff";

        # CORS ì„¤ì •
        add_header Access-Control-Allow-Origin "*";

        # ì´ë¯¸ì§€ íƒ€ì…ë§Œ í—ˆìš©
        location ~ \.(jpg|jpeg|png|webp|gif)$ {
            expires 1y;
            add_header Pragma public;
            add_header Cache-Control "public";
        }
    }
}
```

## 3. ìºì‹± ì •ì±…

### [í•„ìˆ˜] ì½˜í…ì¸  íƒ€ì…ë³„ ìºì‹± ê·œì¹™

```python
# íŒŒì¼: backend/utils/cache_headers.py
CACHE_POLICIES = {
    "user_images": {
        "pattern": r"/images/users/.*",
        "cache_control": "public, max-age=31536000, immutable",
        "cdn_ttl": 365 * 24 * 60 * 60,  # 1ë…„
        "browser_ttl": 7 * 24 * 60 * 60,  # 7ì¼
        "stale_while_revalidate": 60 * 60  # 1ì‹œê°„
    },
    "feed_thumbnails": {
        "pattern": r"/images/feeds/.*/thumb_.*",
        "cache_control": "public, max-age=2592000",
        "cdn_ttl": 30 * 24 * 60 * 60,  # 30ì¼
        "browser_ttl": 24 * 60 * 60,  # 1ì¼
        "stale_if_error": 7 * 24 * 60 * 60  # 7ì¼
    },
    "feed_originals": {
        "pattern": r"/images/feeds/.*/original_.*",
        "cache_control": "public, max-age=86400",
        "cdn_ttl": 7 * 24 * 60 * 60,  # 7ì¼
        "browser_ttl": 60 * 60,  # 1ì‹œê°„
        "vary": "Accept, Accept-Encoding"
    },
    "static_assets": {
        "pattern": r"\.(css|js|woff2?)$",
        "cache_control": "public, max-age=31536000, immutable",
        "cdn_ttl": 365 * 24 * 60 * 60,  # 1ë…„
        "browser_ttl": 30 * 24 * 60 * 60  # 30ì¼
    }
}

def get_cache_headers(path, content_type):
    """ê²½ë¡œì™€ ì½˜í…ì¸  íƒ€ì…ì— ë”°ë¥¸ ìºì‹œ í—¤ë” ìƒì„±"""
    for policy_name, policy in CACHE_POLICIES.items():
        if re.match(policy["pattern"], path):
            return {
                "Cache-Control": policy["cache_control"],
                "CDN-Cache-Control": f"max-age={policy['cdn_ttl']}",
                "Surrogate-Control": f"max-age={policy['cdn_ttl']}",
                "Vary": policy.get("vary", "Accept-Encoding")
            }
    return {"Cache-Control": "no-cache"}
```

### [í•„ìˆ˜] ìºì‹œ ë¬´íš¨í™” ì „ëµ

```python
# íŒŒì¼: backend/services/cache_invalidation.py
class CacheInvalidationService:
    def __init__(self, cdn_provider="cloudflare"):
        self.cdn_provider = cdn_provider

    async def purge_image(self, image_url):
        """íŠ¹ì • ì´ë¯¸ì§€ ìºì‹œ ë¬´íš¨í™”"""
        if self.cdn_provider == "cloudflare":
            return await self._cloudflare_purge(image_url)
        elif self.cdn_provider == "bunny":
            return await self._bunny_purge(image_url)

    async def _cloudflare_purge(self, url):
        """Cloudflare ìºì‹œ ì œê±°"""
        headers = {
            "X-Auth-Email": os.getenv("CLOUDFLARE_EMAIL"),
            "X-Auth-Key": os.getenv("CLOUDFLARE_API_KEY"),
            "Content-Type": "application/json"
        }

        data = {"files": [url]}
        zone_id = os.getenv("CLOUDFLARE_ZONE_ID")

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"https://api.cloudflare.com/client/v4/zones/{zone_id}/purge_cache",
                headers=headers,
                json=data
            ) as response:
                return await response.json()
```

## 4. ì„±ëŠ¥ ìµœì í™”

### [í•„ìˆ˜] ì´ë¯¸ì§€ ìµœì í™” ì„¤ì •

```javascript
// íŒŒì¼: cdn/transform_rules.js
const imageTransformRules = {
  // ë””ë°”ì´ìŠ¤ë³„ ìµœì í™”
  mobile: {
    maxWidth: 720,
    quality: 85,
    format: "auto", // WebP/AVIF ìë™ ì„ íƒ
    fit: "cover",
  },
  tablet: {
    maxWidth: 1200,
    quality: 90,
    format: "auto",
    fit: "cover",
  },
  desktop: {
    maxWidth: 1920,
    quality: 95,
    format: "auto",
    fit: "cover",
  },

  // ìš©ë„ë³„ ìµœì í™”
  thumbnail: {
    width: 150,
    height: 150,
    quality: 80,
    format: "webp",
    fit: "cover",
    sharpen: 1,
  },
  feed: {
    maxWidth: 600,
    quality: 85,
    format: "auto",
    fit: "contain",
  },
  full: {
    maxWidth: 2048,
    quality: 95,
    format: "auto",
    fit: "contain",
  },
};
```

### [í•„ìˆ˜] ì§€ì—° ì‹œê°„ ëª¨ë‹ˆí„°ë§

```python
# íŒŒì¼: backend/monitoring/cdn_performance.py
class CDNPerformanceMonitor:
    def __init__(self):
        self.regions = ["ICN", "NRT", "SIN", "LAX", "FRA"]
        self.target_latency_ms = 50

    async def measure_latency(self):
        """ê° ì§€ì—­ë³„ ì§€ì—° ì‹œê°„ ì¸¡ì •"""
        results = {}

        for region in self.regions:
            test_url = f"https://{region}.cdn.fallingo.com/health/ping.jpg"

            start_time = time.time()
            async with aiohttp.ClientSession() as session:
                async with session.get(test_url) as response:
                    await response.read()

            latency_ms = (time.time() - start_time) * 1000

            results[region] = {
                "latency_ms": round(latency_ms, 2),
                "status": "good" if latency_ms < self.target_latency_ms else "slow",
                "timestamp": datetime.now().isoformat()
            }

        return results
```

### [ì„ íƒ] ì ì‘í˜• ì´ë¯¸ì§€ ë¡œë”©

```dart
// íŒŒì¼: lib/widgets/adaptive_image.dart
class AdaptiveImage extends StatelessWidget {
  final String imageUrl;
  final double? width;
  final double? height;

  const AdaptiveImage({
    required this.imageUrl,
    this.width,
    this.height,
  });

  @override
  Widget build(BuildContext context) {
    final devicePixelRatio = MediaQuery.of(context).devicePixelRatio;
    final screenWidth = MediaQuery.of(context).size.width;

    // ë””ë°”ì´ìŠ¤ì— ë§ëŠ” ì´ë¯¸ì§€ URL ìƒì„±
    String optimizedUrl = _getOptimizedUrl(
      imageUrl,
      screenWidth * devicePixelRatio,
    );

    return CachedNetworkImage(
      imageUrl: optimizedUrl,
      width: width,
      height: height,
      placeholder: (context, url) => Shimmer.fromColors(
        baseColor: Colors.grey[300]!,
        highlightColor: Colors.grey[100]!,
        child: Container(
          color: Colors.white,
          width: width,
          height: height,
        ),
      ),
      errorWidget: (context, url, error) => Icon(Icons.error),
    );
  }

  String _getOptimizedUrl(String originalUrl, double targetWidth) {
    // CDN ë³€í™˜ íŒŒë¼ë¯¸í„° ì¶”ê°€
    final uri = Uri.parse(originalUrl);
    final params = Map<String, String>.from(uri.queryParameters);

    params['w'] = targetWidth.round().toString();
    params['q'] = '85';
    params['auto'] = 'format';

    return uri.replace(queryParameters: params).toString();
  }
}
```

## 5. ë¹„ìš© ê´€ë¦¬

### [í•„ìˆ˜] ë¹„ìš© ì˜ˆì¸¡ ëª¨ë¸

```python
# íŒŒì¼: backend/utils/cdn_cost_calculator.py
class CDNCostCalculator:
    def __init__(self, provider="cloudflare"):
        self.provider = provider
        self.pricing = self._get_pricing()

    def _get_pricing(self):
        """ì œê³µì—…ì²´ë³„ ê°€ê²© ì •ë³´"""
        pricing = {
            "cloudflare": {
                "free_tier_gb": 10000,  # 10TB ë¬´ë£Œ
                "paid_per_gb": 0.08,    # $0.08/GB
                "image_optimization": 5  # $5/ì›” (ë¬´ì œí•œ)
            },
            "bunny": {
                "tier_1_gb": 0.01,      # ì²« 500TB
                "tier_2_gb": 0.005,     # ë‹¤ìŒ 4PB
                "storage_gb": 0.01      # $0.01/GB/ì›”
            },
            "aws_cloudfront": {
                "tier_1_gb": 0.085,     # ì²« 10TB
                "tier_2_gb": 0.080,     # ë‹¤ìŒ 40TB
                "tier_3_gb": 0.060,     # ë‹¤ìŒ 100TB
                "https_requests": 0.01  # $0.01/10,000 ìš”ì²­
            }
        }
        return pricing.get(self.provider, {})

    def calculate_monthly_cost(self, monthly_gb, requests_millions):
        """ì›”ê°„ CDN ë¹„ìš© ê³„ì‚°"""
        if self.provider == "cloudflare":
            if monthly_gb <= self.pricing["free_tier_gb"]:
                bandwidth_cost = 0
            else:
                bandwidth_cost = (monthly_gb - self.pricing["free_tier_gb"]) * self.pricing["paid_per_gb"]

            total_cost = bandwidth_cost + self.pricing["image_optimization"]

        elif self.provider == "bunny":
            bandwidth_cost = monthly_gb * self.pricing["tier_1_gb"]
            storage_cost = (monthly_gb * 0.1) * self.pricing["storage_gb"]  # 10% ìºì‹œ
            total_cost = bandwidth_cost + storage_cost

        return {
            "provider": self.provider,
            "bandwidth_gb": monthly_gb,
            "bandwidth_cost_usd": round(bandwidth_cost, 2),
            "total_cost_usd": round(total_cost, 2),
            "total_cost_krw": round(total_cost * 1300, 0),
            "cost_per_gb": round(total_cost / monthly_gb, 4)
        }
```

### [í•„ìˆ˜] ë¹„ìš© ìµœì í™” ì „ëµ

```yaml
# íŒŒì¼: config/cdn_optimization.yaml
optimization_strategies:
  bandwidth_reduction:
    - strategy: "ì´ë¯¸ì§€ ì••ì¶•"
      reduction: "60-80%"
      implementation: "WebP/AVIF ìë™ ë³€í™˜"

    - strategy: "ì ì‘í˜• í’ˆì§ˆ"
      reduction: "30-40%"
      implementation: "ë„¤íŠ¸ì›Œí¬ ì†ë„ë³„ í’ˆì§ˆ ì¡°ì •"

    - strategy: "ì§€ì—° ë¡œë”©"
      reduction: "40-50%"
      implementation: "ë·°í¬íŠ¸ ê¸°ë°˜ ë¡œë”©"

  cache_optimization:
    - strategy: "ì¥ê¸° ìºì‹±"
      cache_hit_ratio: "95%+"
      implementation: "ì´ë®¤í„°ë¸” URL + 1ë…„ TTL"

    - strategy: "ì—£ì§€ ìºì‹±"
      cache_hit_ratio: "90%+"
      implementation: "ì§€ì—­ë³„ ì¸ê¸° ì½˜í…ì¸  ì‚¬ì „ ìºì‹±"

  cost_control:
    - strategy: "ëŒ€ì—­í­ ìƒí•œ"
      limit: "ì›” 100TB"
      action: "í’ˆì§ˆ ìë™ í•˜í–¥ ì¡°ì •"

    - strategy: "ì§€ì—­ë³„ ì°¨ë“±"
      implementation: "ê³ ë¹„ìš© ì§€ì—­ í’ˆì§ˆ ì œí•œ"
```

### [ì„ íƒ] ì‹¤ì‹œê°„ ë¹„ìš© ëª¨ë‹ˆí„°ë§

```python
# íŒŒì¼: backend/monitoring/cdn_cost_monitor.py
class CDNCostMonitor:
    def __init__(self):
        self.alert_threshold_usd = 1000  # ì›” $1,000

    async def check_daily_usage(self):
        """ì¼ì¼ ì‚¬ìš©ëŸ‰ ë° ë¹„ìš© í™•ì¸"""
        # CDN APIë¥¼ í†µí•œ ì‚¬ìš©ëŸ‰ ì¡°íšŒ
        usage = await self._get_cdn_usage()

        daily_gb = usage["bandwidth_gb"]
        daily_cost = usage["estimated_cost_usd"]

        # ì›”ê°„ ì˜ˆìƒ ë¹„ìš©
        projected_monthly = daily_cost * 30

        if projected_monthly > self.alert_threshold_usd:
            await self._send_cost_alert(projected_monthly)

        return {
            "date": datetime.now().isoformat(),
            "daily_gb": daily_gb,
            "daily_cost_usd": daily_cost,
            "projected_monthly_usd": projected_monthly,
            "alert_triggered": projected_monthly > self.alert_threshold_usd
        }
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] CDN ì œê³µì—…ì²´ ì„ ì • ë° ê³„ì • ì„¤ì •
- [ ] ì´ë¯¸ì§€ ë³€í™˜ ê·œì¹™ êµ¬ì„±
- [ ] ìºì‹± ì •ì±… ì ìš© ë° í…ŒìŠ¤íŠ¸
- [ ] ë¹„ìš© ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ êµ¬ì¶•
