# ğŸ… 8.3 ì¸ì¦ ì¶”ì²œë§›ì§‘ ë¡œì§

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ì¸ì¦ ê¸°ì¤€](#2-ì¸ì¦-ê¸°ì¤€)
3. [êµ¬í˜„](#3-êµ¬í˜„)
4. [ê²€ì¦](#4-ê²€ì¦)

## 1. ê°œìš”
ì í¬ì˜ ë©”ë‰´ ì¸ê¸°ë„ì™€ ê³ ê¸‰ ì‚¬ìš©ì ë°©ë¬¸ ì´ë ¥ì„ ê¸°ë°˜ìœ¼ë¡œ 'ì¸ì¦ ì¶”ì²œë§›ì§‘'ì„ ì„ ì •í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ì¸ì¦ ê¸°ì¤€ íŒì •
- âœ… ì¸ì¦ ë±ƒì§€ ë¶€ì—¬
- âœ… ì¸ì¦ ë§›ì§‘ í•„í„°
- âœ… ì¸ì¦ ì·¨ì†Œ ì²˜ë¦¬

## 2. ì¸ì¦ ê¸°ì¤€

### [í•„ìˆ˜] ì¸ì¦ ì •ì±… ì •ì˜
```dart
// íŒŒì¼: lib/core/constants/certification_constants.dart
class CertificationConstants {
  // ê¸°ë³¸ ì¸ì¦ ì¡°ê±´
  static const int minPopularMenuCount = 3;        // ìµœì†Œ ì¸ê¸° ë©”ë‰´ ìˆ˜
  static const int minRecommendPerMenu = 10;       // ë©”ë‰´ë‹¹ ìµœì†Œ ì¶”ì²œ ìˆ˜
  static const int minHighGradeVisitor = 1;        // ìµœì†Œ ê³ ê¸‰ ìœ ì € ë°©ë¬¸ ìˆ˜
  static const int highGradeThreshold = 7;         // ê³ ê¸‰ ìœ ì € ê¸°ì¤€ (ìˆ˜ëìƒ ì´ìƒ)
  
  // ì¸ì¦ ìœ ì§€ ì¡°ê±´
  static const Duration certificationPeriod = Duration(days: 90);  // 90ì¼
  static const int minMonthlyActivity = 5;         // ì›” ìµœì†Œ í™œë™ ìˆ˜
  
  // ì¸ì¦ ë“±ê¸‰
  static const Map<String, CertificationLevel> levels = {
    'bronze': CertificationLevel(
      name: 'ë¸Œë¡ ì¦ˆ ì¸ì¦',
      icon: 'ğŸ¥‰',
      color: Color(0xFFCD7F32),
      requiredMenus: 3,
      requiredVisitors: 1,
    ),
    'silver': CertificationLevel(
      name: 'ì‹¤ë²„ ì¸ì¦',
      icon: 'ğŸ¥ˆ',
      color: Color(0xFFC0C0C0),
      requiredMenus: 5,
      requiredVisitors: 3,
    ),
    'gold': CertificationLevel(
      name: 'ê³¨ë“œ ì¸ì¦',
      icon: 'ğŸ¥‡',
      color: Color(0xFFFFD700),
      requiredMenus: 10,
      requiredVisitors: 5,
    ),
  };
}

// ì¸ì¦ ë ˆë²¨ ëª¨ë¸
class CertificationLevel {
  final String name;
  final String icon;
  final Color color;
  final int requiredMenus;
  final int requiredVisitors;
  
  const CertificationLevel({
    required this.name,
    required this.icon,
    required this.color,
    required this.requiredMenus,
    required this.requiredVisitors,
  });
}
```

### [í•„ìˆ˜] ì¸ì¦ ë§›ì§‘ ëª¨ë¸
```dart
// íŒŒì¼: lib/models/certified_restaurant.dart
class CertifiedRestaurant {
  final String storeId;
  final String storeName;
  final String address;
  final DateTime certifiedAt;
  final DateTime? expiresAt;
  final String certificationLevel;
  final Map<String, dynamic> stats;
  final List<String> popularMenus;
  final List<HighGradeVisitor> highGradeVisitors;
  final bool isActive;
  
  CertifiedRestaurant({
    required this.storeId,
    required this.storeName,
    required this.address,
    required this.certifiedAt,
    this.expiresAt,
    required this.certificationLevel,
    required this.stats,
    required this.popularMenus,
    required this.highGradeVisitors,
    this.isActive = true,
  });
  
  factory CertifiedRestaurant.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return CertifiedRestaurant(
      storeId: doc.id,
      storeName: data['storeName'],
      address: data['address'],
      certifiedAt: (data['certifiedAt'] as Timestamp).toDate(),
      expiresAt: data['expiresAt'] != null 
          ? (data['expiresAt'] as Timestamp).toDate() 
          : null,
      certificationLevel: data['certificationLevel'],
      stats: data['stats'],
      popularMenus: List<String>.from(data['popularMenus']),
      highGradeVisitors: (data['highGradeVisitors'] as List)
          .map((v) => HighGradeVisitor.fromMap(v))
          .toList(),
      isActive: data['isActive'] ?? true,
    );
  }
}

// ê³ ê¸‰ ìœ ì € ë°©ë¬¸ì ì •ë³´
class HighGradeVisitor {
  final String userId;
  final String nickname;
  final int grade;
  final DateTime visitedAt;
  
  HighGradeVisitor({
    required this.userId,
    required this.nickname,
    required this.grade,
    required this.visitedAt,
  });
  
  factory HighGradeVisitor.fromMap(Map<String, dynamic> map) {
    return HighGradeVisitor(
      userId: map['userId'],
      nickname: map['nickname'],
      grade: map['grade'],
      visitedAt: (map['visitedAt'] as Timestamp).toDate(),
    );
  }
}
```

## 3. êµ¬í˜„

### [í•„ìˆ˜] ì¸ì¦ ì„œë¹„ìŠ¤
```dart
// íŒŒì¼: lib/features/certification/services/certification_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class CertificationService {
  static final CertificationService _instance = CertificationService._internal();
  factory CertificationService() => _instance;
  CertificationService._internal();
  
  // ì¸ì¦ í‰ê°€
  Future<CertificationResult?> evaluateStore(String storeId) async {
    try {
      // 1. ì í¬ ì •ë³´ ì¡°íšŒ
      final storeDoc = await FirestoreService.stores().doc(storeId).get();
      if (!storeDoc.exists) return null;
      
      final storeData = storeDoc.data() as Map<String, dynamic>;
      
      // 2. ì¸ê¸° ë©”ë‰´ ë¶„ì„
      final popularMenus = await _analyzePopularMenus(storeId);
      
      // 3. ê³ ê¸‰ ìœ ì € ë°©ë¬¸ ì´ë ¥ ì¡°íšŒ
      final highGradeVisitors = await _getHighGradeVisitors(storeId);
      
      // 4. ì¸ì¦ ê¸°ì¤€ í‰ê°€
      final evaluation = _evaluateCriteria(
        popularMenus: popularMenus,
        highGradeVisitors: highGradeVisitors,
      );
      
      if (!evaluation.isEligible) {
        return CertificationResult(
          isEligible: false,
          reason: evaluation.reason,
        );
      }
      
      // 5. ì¸ì¦ ë ˆë²¨ ê²°ì •
      final level = _determineCertificationLevel(
        popularMenuCount: popularMenus.length,
        visitorCount: highGradeVisitors.length,
      );
      
      // 6. ì¸ì¦ ì²˜ë¦¬
      await _processCertification(
        storeId: storeId,
        storeName: storeData['name'],
        address: storeData['address'],
        level: level,
        popularMenus: popularMenus,
        highGradeVisitors: highGradeVisitors,
      );
      
      return CertificationResult(
        isEligible: true,
        level: level,
        popularMenus: popularMenus,
        highGradeVisitors: highGradeVisitors,
      );
      
    } catch (e) {
      print('Certification evaluation error: $e');
      return null;
    }
  }
  
  // ì¸ê¸° ë©”ë‰´ ë¶„ì„
  Future<List<PopularMenu>> _analyzePopularMenus(String storeId) async {
    // í•´ë‹¹ ì í¬ì˜ ëª¨ë“  í”¼ë“œ ì¡°íšŒ
    final feedsSnapshot = await FirestoreService.feeds()
        .where('storeId', isEqualTo: storeId)
        .where('isActive', isEqualTo: true)
        .get();
    
    // ë©”ë‰´ë³„ ì¶”ì²œ ìˆ˜ ì§‘ê³„
    final menuStats = <String, MenuStat>{};
    
    for (final feedDoc in feedsSnapshot.docs) {
      final feedData = feedDoc.data() as Map<String, dynamic>;
      final menuName = feedData['menuName'] as String;
      final feedId = feedDoc.id;
      
      // ì¶”ì²œ ìˆ˜ ì¡°íšŒ
      final recommendCount = await _getRecommendationCount(feedId);
      
      if (menuStats.containsKey(menuName)) {
        menuStats[menuName]!.addRecommendation(recommendCount);
      } else {
        menuStats[menuName] = MenuStat(
          menuName: menuName,
          totalRecommends: recommendCount,
          feedCount: 1,
        );
      }
    }
    
    // ì¸ê¸° ë©”ë‰´ í•„í„°ë§
    final popularMenus = <PopularMenu>[];
    menuStats.forEach((menuName, stat) {
      if (stat.averageRecommends >= CertificationConstants.minRecommendPerMenu) {
        popularMenus.add(PopularMenu(
          name: menuName,
          totalRecommends: stat.totalRecommends,
          feedCount: stat.feedCount,
          averageRecommends: stat.averageRecommends,
        ));
      }
    });
    
    // ì¶”ì²œ ìˆ˜ ê¸°ì¤€ ì •ë ¬
    popularMenus.sort((a, b) => b.totalRecommends.compareTo(a.totalRecommends));
    
    return popularMenus;
  }
  
  // ì¶”ì²œ ìˆ˜ ì¡°íšŒ
  Future<int> _getRecommendationCount(String feedId) async {
    final count = await FirestoreService.recommendations()
        .where('feedId', isEqualTo: feedId)
        .where('isActive', isEqualTo: true)
        .count()
        .get();
    
    return count.count;
  }
  
  // ê³ ê¸‰ ìœ ì € ë°©ë¬¸ ì´ë ¥ ì¡°íšŒ
  Future<List<HighGradeVisitor>> _getHighGradeVisitors(String storeId) async {
    // í•´ë‹¹ ì í¬ì˜ í”¼ë“œ ì‘ì„±ì ì¤‘ ê³ ê¸‰ ìœ ì € ì¡°íšŒ
    final feedsSnapshot = await FirestoreService.feeds()
        .where('storeId', isEqualTo: storeId)
        .where('isActive', isEqualTo: true)
        .get();
    
    final uniqueVisitors = <String, HighGradeVisitor>{};
    
    for (final feedDoc in feedsSnapshot.docs) {
      final feedData = feedDoc.data() as Map<String, dynamic>;
      final userId = feedData['userId'] as String;
      
      // ì´ë¯¸ í™•ì¸í•œ ìœ ì €ëŠ” ìŠ¤í‚µ
      if (uniqueVisitors.containsKey(userId)) continue;
      
      // ìœ ì € ì •ë³´ ì¡°íšŒ
      final userDoc = await FirestoreService.users().doc(userId).get();
      if (!userDoc.exists) continue;
      
      final userData = userDoc.data() as Map<String, dynamic>;
      final userGrade = userData['gradeLevel'] ?? 1;
      
      // ê³ ê¸‰ ìœ ì €ì¸ ê²½ìš°ë§Œ ì¶”ê°€
      if (userGrade >= CertificationConstants.highGradeThreshold) {
        uniqueVisitors[userId] = HighGradeVisitor(
          userId: userId,
          nickname: userData['nickname'],
          grade: userGrade,
          visitedAt: (feedData['createdAt'] as Timestamp).toDate(),
        );
      }
    }
    
    return uniqueVisitors.values.toList();
  }
  
  // ì¸ì¦ ê¸°ì¤€ í‰ê°€
  CertificationEvaluation _evaluateCriteria({
    required List<PopularMenu> popularMenus,
    required List<HighGradeVisitor> highGradeVisitors,
  }) {
    // ì¸ê¸° ë©”ë‰´ ìˆ˜ í™•ì¸
    if (popularMenus.length < CertificationConstants.minPopularMenuCount) {
      return CertificationEvaluation(
        isEligible: false,
        reason: 'ì¸ê¸° ë©”ë‰´ê°€ ${CertificationConstants.minPopularMenuCount}ê°œ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤',
      );
    }
    
    // ê³ ê¸‰ ìœ ì € ë°©ë¬¸ í™•ì¸
    if (highGradeVisitors.length < CertificationConstants.minHighGradeVisitor) {
      return CertificationEvaluation(
        isEligible: false,
        reason: 'ìˆ˜ëìƒ ì´ìƒ ë“±ê¸‰ ìœ ì €ì˜ ë°©ë¬¸ì´ í•„ìš”í•©ë‹ˆë‹¤',
      );
    }
    
    return CertificationEvaluation(isEligible: true);
  }
  
  // ì¸ì¦ ë ˆë²¨ ê²°ì •
  String _determineCertificationLevel({
    required int popularMenuCount,
    required int visitorCount,
  }) {
    // ê³¨ë“œ ê¸°ì¤€ í™•ì¸
    final gold = CertificationConstants.levels['gold']!;
    if (popularMenuCount >= gold.requiredMenus && 
        visitorCount >= gold.requiredVisitors) {
      return 'gold';
    }
    
    // ì‹¤ë²„ ê¸°ì¤€ í™•ì¸
    final silver = CertificationConstants.levels['silver']!;
    if (popularMenuCount >= silver.requiredMenus && 
        visitorCount >= silver.requiredVisitors) {
      return 'silver';
    }
    
    // ê¸°ë³¸ ë¸Œë¡ ì¦ˆ
    return 'bronze';
  }
  
  // ì¸ì¦ ì²˜ë¦¬
  Future<void> _processCertification({
    required String storeId,
    required String storeName,
    required String address,
    required String level,
    required List<PopularMenu> popularMenus,
    required List<HighGradeVisitor> highGradeVisitors,
  }) async {
    final now = DateTime.now();
    final certification = {
      'storeId': storeId,
      'storeName': storeName,
      'address': address,
      'certifiedAt': now,
      'expiresAt': now.add(CertificationConstants.certificationPeriod),
      'certificationLevel': level,
      'stats': {
        'popularMenuCount': popularMenus.length,
        'highGradeVisitorCount': highGradeVisitors.length,
        'totalRecommends': popularMenus.fold(0, (sum, menu) => sum + menu.totalRecommends),
      },
      'popularMenus': popularMenus.map((m) => m.name).toList(),
      'highGradeVisitors': highGradeVisitors.map((v) => {
        'userId': v.userId,
        'nickname': v.nickname,
        'grade': v.grade,
        'visitedAt': v.visitedAt,
      }).toList(),
      'isActive': true,
    };
    
    // ì¸ì¦ ì •ë³´ ì €ì¥
    await FirestoreService.instance
        .collection('certified_restaurants')
        .doc(storeId)
        .set(certification);
    
    // ì í¬ ì •ë³´ ì—…ë°ì´íŠ¸
    await FirestoreService.stores().doc(storeId).update({
      'isCertified': true,
      'certificationLevel': level,
      'certifiedAt': now,
    });
    
    // ì•Œë¦¼ ë°œì†¡
    await _sendCertificationNotification(storeId, storeName, level);
  }
  
  // ì¸ì¦ ì·¨ì†Œ
  Future<bool> revokeCertification(String storeId) async {
    try {
      // ì¸ì¦ ì •ë³´ ë¹„í™œì„±í™”
      await FirestoreService.instance
          .collection('certified_restaurants')
          .doc(storeId)
          .update({'isActive': false});
      
      // ì í¬ ì •ë³´ ì—…ë°ì´íŠ¸
      await FirestoreService.stores().doc(storeId).update({
        'isCertified': false,
        'certificationLevel': null,
        'certifiedAt': null,
      });
      
      return true;
    } catch (e) {
      print('Revoke certification error: $e');
      return false;
    }
  }
  
  // ì¸ì¦ ê°±ì‹  ì²´í¬ (ìŠ¤ì¼€ì¤„ëŸ¬ì—ì„œ í˜¸ì¶œ)
  Future<void> checkCertificationRenewal() async {
    final now = DateTime.now();
    
    // ë§Œë£Œ ì˜ˆì • ì¸ì¦ ì¡°íšŒ
    final expiringCerts = await FirestoreService.instance
        .collection('certified_restaurants')
        .where('isActive', isEqualTo: true)
        .where('expiresAt', isLessThan: now.add(Duration(days: 7)))
        .get();
    
    for (final doc in expiringCerts.docs) {
      final certData = doc.data();
      final storeId = certData['storeId'];
      
      // ìµœê·¼ í™œë™ í™•ì¸
      final recentActivity = await _checkRecentActivity(storeId);
      
      if (recentActivity >= CertificationConstants.minMonthlyActivity) {
        // ì¸ì¦ ì—°ì¥
        await _renewCertification(storeId);
      } else {
        // ì¸ì¦ ë§Œë£Œ ê²½ê³ 
        await _sendExpirationWarning(storeId);
      }
    }
  }
  
  // ìµœê·¼ í™œë™ í™•ì¸
  Future<int> _checkRecentActivity(String storeId) async {
    final oneMonthAgo = DateTime.now().subtract(Duration(days: 30));
    
    final count = await FirestoreService.feeds()
        .where('storeId', isEqualTo: storeId)
        .where('createdAt', isGreaterThan: oneMonthAgo)
        .count()
        .get();
    
    return count.count;
  }
  
  // ì¸ì¦ ê°±ì‹ 
  Future<void> _renewCertification(String storeId) async {
    final newExpiry = DateTime.now().add(CertificationConstants.certificationPeriod);
    
    await FirestoreService.instance
        .collection('certified_restaurants')
        .doc(storeId)
        .update({
      'expiresAt': newExpiry,
      'lastRenewed': FieldValue.serverTimestamp(),
    });
  }
  
  // ì•Œë¦¼ ë°œì†¡
  Future<void> _sendCertificationNotification(
    String storeId,
    String storeName,
    String level,
  ) async {
    // êµ¬í˜„: FCM ë“±ì„ í†µí•œ í‘¸ì‹œ ì•Œë¦¼
  }
  
  Future<void> _sendExpirationWarning(String storeId) async {
    // êµ¬í˜„: ë§Œë£Œ ê²½ê³  ì•Œë¦¼
  }
}

// ì§€ì› ëª¨ë¸ë“¤
class MenuStat {
  final String menuName;
  int totalRecommends;
  int feedCount;
  
  MenuStat({
    required this.menuName,
    required this.totalRecommends,
    required this.feedCount,
  });
  
  double get averageRecommends => totalRecommends / feedCount;
  
  void addRecommendation(int count) {
    totalRecommends += count;
    feedCount++;
  }
}

class PopularMenu {
  final String name;
  final int totalRecommends;
  final int feedCount;
  final double averageRecommends;
  
  PopularMenu({
    required this.name,
    required this.totalRecommends,
    required this.feedCount,
    required this.averageRecommends,
  });
}

class CertificationResult {
  final bool isEligible;
  final String? level;
  final String? reason;
  final List<PopularMenu>? popularMenus;
  final List<HighGradeVisitor>? highGradeVisitors;
  
  CertificationResult({
    required this.isEligible,
    this.level,
    this.reason,
    this.popularMenus,
    this.highGradeVisitors,
  });
}

class CertificationEvaluation {
  final bool isEligible;
  final String? reason;
  
  CertificationEvaluation({
    required this.isEligible,
    this.reason,
  });
}
```

### [í•„ìˆ˜] ì¸ì¦ ë±ƒì§€ UI
```dart
// íŒŒì¼: lib/features/certification/widgets/certification_badge.dart
import 'package:flutter/material.dart';

class CertificationBadge extends StatelessWidget {
  final String level;
  final double size;
  final bool showLabel;
  
  const CertificationBadge({
    required this.level,
    this.size = 24,
    this.showLabel = false,
  });
  
  @override
  Widget build(BuildContext context) {
    final levelInfo = CertificationConstants.levels[level];
    if (levelInfo == null) return SizedBox.shrink();
    
    final badge = Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        color: levelInfo.color,
        shape: BoxShape.circle,
        boxShadow: [
          BoxShadow(
            color: levelInfo.color.withOpacity(0.4),
            blurRadius: 4,
            offset: Offset(0, 2),
          ),
        ],
      ),
      child: Center(
        child: Text(
          levelInfo.icon,
          style: TextStyle(fontSize: size * 0.6),
        ),
      ),
    );
    
    if (!showLabel) return badge;
    
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        badge,
        SizedBox(height: 4),
        Text(
          'ì¸ì¦ ì¶”ì²œë§›ì§‘!',
          style: TextStyle(
            fontSize: 10,
            fontWeight: FontWeight.bold,
            color: levelInfo.color,
          ),
        ),
      ],
    );
  }
}
```

## 4. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì¸ê¸° ë©”ë‰´ 3ê°œ ì´ìƒ ì •í™•íˆ ê³„ì‚°
- [ ] ë©”ë‰´ë‹¹ í‰ê·  ì¶”ì²œ 10ê°œ ì´ìƒ í™•ì¸
- [ ] ìˆ˜ëìƒ ì´ìƒ ìœ ì € ë°©ë¬¸ í™•ì¸
- [ ] ë¸Œë¡ ì¦ˆ/ì‹¤ë²„/ê³¨ë“œ ë ˆë²¨ êµ¬ë¶„
- [ ] 90ì¼ ì¸ì¦ ê¸°ê°„ ì„¤ì •
- [ ] ì¸ì¦ ë±ƒì§€ ì •ìƒ í‘œì‹œ
- [ ] ì¸ì¦ ì·¨ì†Œ ê¸°ëŠ¥ ì‘ë™