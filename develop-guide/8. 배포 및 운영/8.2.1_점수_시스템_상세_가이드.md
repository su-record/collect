# ğŸ“Š 8.2.1 ì ìˆ˜ ì‹œìŠ¤í…œ ìƒì„¸ ê°€ì´ë“œ

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ì´ì›í™” ì ìˆ˜ ì‹œìŠ¤í…œ](#2-ì´ì›í™”-ì ìˆ˜-ì‹œìŠ¤í…œ)
3. [ì ìˆ˜ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜](#3-ì ìˆ˜-ê³„ì‚°-ì•Œê³ ë¦¬ì¦˜)
4. [ì¼ì¼ ì œí•œ ë° ì–´ë·°ì§• ë°©ì§€](#4-ì¼ì¼-ì œí•œ-ë°-ì–´ë·°ì§•-ë°©ì§€)
5. [êµ¬í˜„ ì˜ˆì œ](#5-êµ¬í˜„-ì˜ˆì œ)

## 1. ê°œìš”

Fallingoì˜ ì ìˆ˜ ì‹œìŠ¤í…œì€ ì‚¬ìš©ì í™œë™ì„ ì •ëŸ‰í™”í•˜ê³  ì„±ì¥ì„ ìœ ë„í•˜ëŠ” í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜ì…ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ë ˆë²¨ì—… ì ìˆ˜ì™€ ì¸í”Œë£¨ì–¸ì„œ ì ìˆ˜ ë¶„ë¦¬
- âœ… 2ì‹œê°„ ì ê¸ˆìœ¼ë¡œ ì‹ ì¤‘í•œ í™œë™ ìœ ë„
- âœ… ì¼ì¼ í•œë„ë¡œ ì–´ë·°ì§• ë°©ì§€

## 2. ì´ì›í™” ì ìˆ˜ ì‹œìŠ¤í…œ

### [í•„ìˆ˜] ì ìˆ˜ íƒ€ì… ì •ì˜
```dart
// íŒŒì¼: lib/core/models/score_types.dart
enum ScoreType {
  levelUp,      // 1~7ë“±ê¸‰ìš©
  influencer,   // 8~10ë“±ê¸‰ìš©
}

class UserScore {
  final int levelUpPoints;        // ëˆ„ì  ë ˆë²¨ì—… ì ìˆ˜
  final int influencerPoints;     // ì—°ê°„ ì¸í”Œë£¨ì–¸ì„œ ì ìˆ˜
  final int dailyEarnedPoints;    // ì˜¤ëŠ˜ íšë“í•œ ì ìˆ˜
  final DateTime lastResetDate;   // ë§ˆì§€ë§‰ ë¦¬ì…‹ ë‚ ì§œ
  
  const UserScore({
    required this.levelUpPoints,
    required this.influencerPoints,
    required this.dailyEarnedPoints,
    required this.lastResetDate,
  });
}
```

### [í•„ìˆ˜] ì ìˆ˜ íšë“ ê·œì¹™
```dart
// íŒŒì¼: lib/core/constants/score_rules.dart
class ScoreRules {
  // ê¸°ë³¸ í™œë™ ì ìˆ˜
  static const int feedPost = 3;              // í”¼ë“œ ë“±ë¡
  static const int firstPost = 10;            // ìµœì´ˆ ë“±ë¡
  static const int ocrBonus = 5;              // OCR ì¶”ê°€
  static const int recommend = 1;             // ì¶”ì²œí•˜ê¸°
  static const int bookmark = 1;              // ë¶ë§ˆí¬
  
  // ë°˜ì‘ ë³´ìƒ (ì¼ì¼)
  static const int minDailyReward = 5;        // ìµœì†Œ ë³´ìƒ
  static const int maxDailyReward = 50;       // ìµœëŒ€ ë³´ìƒ
  
  // ì¼ì¼ í•œë„
  static const int dailyLimit = 100;          // ì¼ì¼ ìµœëŒ€ íšë“
  
  // 2ì‹œê°„ ì ê¸ˆ
  static const Duration lockPeriod = Duration(hours: 2);
}
```

## 3. ì ìˆ˜ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜

### [í•„ìˆ˜] ì ìˆ˜ ê³„ì‚° ì„œë¹„ìŠ¤
```dart
// íŒŒì¼: lib/services/score_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class ScoreService {
  final SupabaseClient _supabase;
  
  ScoreService(this._supabase);
  
  // í”¼ë“œ ë“±ë¡ ì ìˆ˜ ê³„ì‚°
  Future<int> calculateFeedScore({
    required String userId,
    required String placeId,
    required String menuName,
    required bool hasOcr,
  }) async {
    int baseScore = ScoreRules.feedPost;
    
    // ìµœì´ˆ ë“±ë¡ í™•ì¸
    final isFirst = await _checkFirstPost(placeId, menuName);
    if (isFirst) {
      baseScore += ScoreRules.firstPost;
    }
    
    // OCR ë³´ë„ˆìŠ¤
    if (hasOcr) {
      baseScore += ScoreRules.ocrBonus;
    }
    
    // ì¼ì¼ í•œë„ ì²´í¬
    final canEarn = await _checkDailyLimit(userId, baseScore);
    
    return canEarn ? baseScore : 0;
  }
  
  // ë°˜ì‘ ë³´ìƒ ê³„ì‚° (ìì • ì‹¤í–‰)
  Future<int> calculateDailyReward({
    required String userId,
    required int recommendCount,
    required int bookmarkCount,
  }) async {
    final totalReactions = recommendCount + bookmarkCount;
    
    // êµ¬ê°„ë³„ ë³´ìƒ ê³„ì‚°
    int reward = 0;
    if (totalReactions >= 50) {
      reward = ScoreRules.maxDailyReward;
    } else if (totalReactions >= 20) {
      reward = 30;
    } else if (totalReactions >= 10) {
      reward = 15;
    } else if (totalReactions >= 5) {
      reward = ScoreRules.minDailyReward;
    }
    
    return reward;
  }
  
  // ìµœì´ˆ ë“±ë¡ í™•ì¸
  Future<bool> _checkFirstPost(String placeId, String menuName) async {
    final response = await _supabase
        .from('feeds')
        .select('id')
        .eq('place_id', placeId)
        .eq('menu_name', menuName)
        .limit(1);
        
    return response.isEmpty;
  }
  
  // ì¼ì¼ í•œë„ í™•ì¸
  Future<bool> _checkDailyLimit(String userId, int points) async {
    final response = await _supabase
        .from('users')
        .select('score')
        .eq('id', userId)
        .single();
        
    final score = UserScore.fromJson(response['score']);
    
    // ë‚ ì§œ ë³€ê²½ ì‹œ ë¦¬ì…‹
    if (!_isSameDay(score.lastResetDate, DateTime.now())) {
      await _resetDailyPoints(userId);
      return true;
    }
    
    return (score.dailyEarnedPoints + points) <= ScoreRules.dailyLimit;
  }
  
  bool _isSameDay(DateTime date1, DateTime date2) {
    return date1.year == date2.year &&
           date1.month == date2.month &&
           date1.day == date2.day;
  }
}
```

### [í•„ìˆ˜] ì¸í”Œë£¨ì–¸ì„œ ì ìˆ˜ ê³„ì‚°
```dart
// íŒŒì¼: lib/services/influencer_score_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class InfluencerScoreService {
  final SupabaseClient _supabase;
  
  InfluencerScoreService(this._supabase);
  // ë‹¤ì–‘ì„± ì§€í‘œ ê³„ì‚°
  double calculateDiversityScore({
    required List<String> categories,
    required List<String> regions,
  }) {
    final categoryDiversity = categories.toSet().length / 10; // ìµœëŒ€ 10ê°œ ì¹´í…Œê³ ë¦¬
    final regionDiversity = regions.toSet().length / 20;     // ìµœëŒ€ 20ê°œ ì§€ì—­
    
    return (categoryDiversity + regionDiversity) / 2;
  }
  
  // ì—°ê°„ ì¸í”Œë£¨ì–¸ì„œ ì ìˆ˜ ì§‘ê³„
  Future<List<InfluencerCandidate>> getYearlyRanking() async {
    final candidates = <InfluencerCandidate>[];
    
    // ìˆ˜ëìƒ ë“±ê¸‰ ì‚¬ìš©ìë§Œ ëŒ€ìƒ
    final response = await _supabase
        .from('users')
        .select('id, username, profile_image')
        .eq('level', 7);
        
    for (final user in response) {
      final yearlyStats = await _getUserYearlyStats(user['id']);
      final diversityScore = calculateDiversityScore(
        categories: yearlyStats.categories,
        regions: yearlyStats.regions,
      );
      
      candidates.add(InfluencerCandidate(
        userId: user['id'],
        totalPoints: yearlyStats.totalPoints,
        diversityScore: diversityScore,
        finalScore: yearlyStats.totalPoints * (1 + diversityScore),
      ));
    }
    
    // ìµœì¢… ì ìˆ˜ë¡œ ì •ë ¬
    candidates.sort((a, b) => b.finalScore.compareTo(a.finalScore));
    
    return candidates;
  }
}
```

## 4. ì¼ì¼ ì œí•œ ë° ì–´ë·°ì§• ë°©ì§€

### [í•„ìˆ˜] 2ì‹œê°„ ì ê¸ˆ ì‹œìŠ¤í…œ
```dart
// íŒŒì¼: lib/services/lock_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class LockService {
  final SupabaseClient _supabase;
  
  LockService(this._supabase);
  // í”¼ë“œ ë“±ë¡ ì‹œ ì ê¸ˆ ìƒì„±
  Future<String> createLock({
    required String feedId,
    required String userId,
    required int pendingPoints,
  }) async {
    final response = await _supabase
        .from('score_locks')
        .insert({
          'feed_id': feedId,
          'user_id': userId,
          'pending_points': pendingPoints,
          'created_at': DateTime.now().toIso8601String(),
          'unlock_at': DateTime.now().add(ScoreRules.lockPeriod).toIso8601String(),
          'status': 'pending',
        })
        .select()
        .single();
    
    return response['id'];
  }
  
  // ì ê¸ˆ í•´ì œ (Supabase Edge Functionsë¡œ ìë™ ì‹¤í–‰)
  Future<void> processExpiredLocks() async {
    final now = DateTime.now();
    final expiredLocks = await _supabase
        .from('score_locks')
        .select()
        .eq('status', 'pending')
        .lte('unlock_at', now.toIso8601String());
    
    for (final lock in expiredLocks) {
      // í”¼ë“œ ì¡´ì¬ í™•ì¸
      final feedExists = await _checkFeedExists(lock['feed_id']);
      
      if (feedExists) {
        // ì ìˆ˜ ì§€ê¸‰
        await _awardPoints(
          lock['user_id'], 
          lock['pending_points']
        );
        
        // ì ê¸ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
        await _supabase
            .from('score_locks')
            .update({
              'status': 'completed',
              'completed_at': DateTime.now().toIso8601String(),
            })
            .eq('id', lock['id']);
      } else {
        // í”¼ë“œ ì‚­ì œë¨ - ì ìˆ˜ ë¯¸ì§€ê¸‰
        await _supabase
            .from('score_locks')
            .update({
              'status': 'cancelled',
              'reason': 'feed_deleted',
            })
            .eq('id', lock['id']);
      }
    }
  }
}
```

### [í•„ìˆ˜] ì–´ë·°ì§• ë°©ì§€ ë¡œì§
```dart
// íŒŒì¼: lib/services/anti_abuse_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class AntiAbuseService {
  final SupabaseClient _supabase;
  
  AntiAbuseService(this._supabase);
  // ë¹„ì •ìƒ íŒ¨í„´ ê°ì§€
  Future<bool> detectAbusePattern(String userId) async {
    final recentActivities = await _getRecentActivities(userId, hours: 1);
    
    // 1ì‹œê°„ ë‚´ ê³¼ë„í•œ í™œë™
    if (recentActivities.length > 30) {
      await _flagUser(userId, 'excessive_activity');
      return true;
    }
    
    // ë°˜ë³µì ì¸ ì¶”ì²œ/ë¶ë§ˆí¬ íŒ¨í„´
    final targetCounts = <String, int>{};
    for (final activity in recentActivities) {
      targetCounts[activity.targetId] = 
          (targetCounts[activity.targetId] ?? 0) + 1;
    }
    
    // ê°™ì€ ëŒ€ìƒì— 5ë²ˆ ì´ìƒ ë°˜ë³µ
    if (targetCounts.values.any((count) => count > 5)) {
      await _flagUser(userId, 'repetitive_pattern');
      return true;
    }
    
    return false;
  }
  
  // ì¼ì¼ í•œë„ ë™ì  ì¡°ì •
  Future<int> getDynamicDailyLimit(String userId) async {
    final userFlags = await _getUserFlags(userId);
    
    if (userFlags.isEmpty) {
      return ScoreRules.dailyLimit;
    }
    
    // í”Œë˜ê·¸ ìˆ˜ì— ë”°ë¼ í•œë„ ê°ì†Œ
    final reduction = userFlags.length * 20;
    return (ScoreRules.dailyLimit - reduction).clamp(20, 100);
  }
}
```

## 5. êµ¬í˜„ ì˜ˆì œ

### [í•„ìˆ˜] í†µí•© ì ìˆ˜ ê´€ë¦¬ì
```dart
// íŒŒì¼: lib/managers/score_manager.dart
class ScoreManager {
  final ScoreService _scoreService;
  final LockService _lockService;
  final AntiAbuseService _antiAbuseService;
  
  // í”¼ë“œ ë“±ë¡ ì²˜ë¦¬
  Future<ScoreResult> handleFeedPost({
    required String userId,
    required FeedData feedData,
  }) async {
    // ì–´ë·°ì§• ì²´í¬
    final isAbuse = await _antiAbuseService.detectAbusePattern(userId);
    if (isAbuse) {
      return ScoreResult(
        success: false,
        message: 'ë¹„ì •ìƒì ì¸ í™œë™ íŒ¨í„´ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤',
      );
    }
    
    // ì ìˆ˜ ê³„ì‚°
    final points = await _scoreService.calculateFeedScore(
      userId: userId,
      placeId: feedData.placeId,
      menuName: feedData.menuName,
      hasOcr: feedData.hasOcr,
    );
    
    if (points == 0) {
      return ScoreResult(
        success: false,
        message: 'ì¼ì¼ íšë“ í•œë„ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤',
      );
    }
    
    // 2ì‹œê°„ ì ê¸ˆ ìƒì„±
    final lockId = await _lockService.createLock(
      feedId: feedData.id,
      userId: userId,
      pendingPoints: points,
    );
    
    return ScoreResult(
      success: true,
      pendingPoints: points,
      lockId: lockId,
      message: '2ì‹œê°„ í›„ ì ìˆ˜ê°€ í™•ì •ë©ë‹ˆë‹¤',
    );
  }
}
```

### [ì„ íƒ] ì ìˆ˜ í˜„í™© UI
```dart
// íŒŒì¼: lib/widgets/score_status_widget.dart
class ScoreStatusWidget extends StatelessWidget {
  final UserScore score;
  
  @override
  Widget build(BuildContext context) {
    final remaining = ScoreRules.dailyLimit - score.dailyEarnedPoints;
    
    return Card(
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          children: [
            Text('ì˜¤ëŠ˜ íšë“: ${score.dailyEarnedPoints}ì '),
            Text('ì¼ì¼ í•œë„: ${remaining}ì  ë‚¨ìŒ'),
            if (remaining <= 20)
              Text(
                'ì¼ì¼ í•œë„ê°€ ê±°ì˜ ì°¼ìŠµë‹ˆë‹¤!',
                style: TextStyle(color: AppColors.primaryOrange),
              ),
          ],
        ),
      ),
    );
  }
}
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì´ì›í™” ì ìˆ˜ ì‹œìŠ¤í…œ êµ¬í˜„
- [ ] 2ì‹œê°„ ì ê¸ˆ ë¡œì§ ì™„ì„±
- [ ] ì¼ì¼ í•œë„ ì²´í¬ ê¸°ëŠ¥
- [ ] ì–´ë·°ì§• ë°©ì§€ ì‹œìŠ¤í…œ
- [ ] ìì • ë¦¬ì…‹ ìŠ¤ì¼€ì¤„ëŸ¬