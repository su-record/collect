# ğŸŒŸ 7.3 ì¸í”Œë£¨ì–¸ì„œ ìœ„ì¹˜ ê³µìœ 

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ê¶Œí•œ ë° í”„ë¼ì´ë²„ì‹œ](#2-ê¶Œí•œ-ë°-í”„ë¼ì´ë²„ì‹œ)
3. [êµ¬í˜„](#3-êµ¬í˜„)
4. [ê²€ì¦](#4-ê²€ì¦)

## 1. ê°œìš”
ìˆ˜ëìƒ ë“±ê¸‰ ì´ìƒ ì‚¬ìš©ìê°€ ì„ íƒì ìœ¼ë¡œ ìœ„ì¹˜ë¥¼ ê³µìœ í•˜ê³ , ì§€ë„ì— ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œí•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ìœ„ì¹˜ ê³µìœ  í† ê¸€ UI
- âœ… ì‹¤ì‹œê°„ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
- âœ… í”„ë¼ì´ë²„ì‹œ ë³´í˜¸
- âœ… ì§€ë„ í‘œì‹œ ìµœì í™”

## 2. ê¶Œí•œ ë° í”„ë¼ì´ë²„ì‹œ

### [í•„ìˆ˜] ìœ„ì¹˜ ê³µìœ  ì •ì±…
```dart
// íŒŒì¼: lib/core/constants/location_sharing_policy.dart
class LocationSharingPolicy {
  // ìœ„ì¹˜ ê³µìœ  ê°€ëŠ¥ ë“±ê¸‰ (ìˆ˜ëìƒ ì´ìƒ)
  static const int minGradeForSharing = 7;
  
  // ìœ„ì¹˜ ì •í™•ë„ ì„¤ì •
  static const double locationFuzzingRadius = 100.0; // 100m ë°˜ê²½ ëª¨í˜¸í™”
  
  // ì—…ë°ì´íŠ¸ ì£¼ê¸°
  static const Duration updateInterval = Duration(minutes: 5);
  static const Duration maxSharingDuration = Duration(hours: 4); // ìµœëŒ€ 4ì‹œê°„
  
  // í‘œì‹œ ì •ë³´ ì œí•œ
  static const List<String> allowedInfo = [
    'nickname',
    'grade',
    'gradeEmoji',
  ];
  
  // ìµëª…ì„± ë³´ì¥
  static const bool showRealName = false;
  static const bool showProfileImage = false;
  static const bool allowDirectMessage = false;
}
```

### [í•„ìˆ˜] ì‚¬ìš©ì ë™ì˜ ëª¨ë¸
```dart
// íŒŒì¼: lib/models/location_sharing_consent.dart
class LocationSharingConsent {
  final String userId;
  final DateTime consentDate;
  final bool isActive;
  final DateTime? expiryTime;
  final Map<String, bool> permissions;
  
  LocationSharingConsent({
    required this.userId,
    required this.consentDate,
    required this.isActive,
    this.expiryTime,
    required this.permissions,
  });
  
  // ê¸°ë³¸ ê¶Œí•œ ì„¤ì •
  factory LocationSharingConsent.defaultConsent(String userId) {
    return LocationSharingConsent(
      userId: userId,
      consentDate: DateTime.now(),
      isActive: false,
      permissions: {
        'shareLocation': false,
        'showOnMap': false,
        'notifyNearby': false,
      },
    );
  }
}
```

## 3. êµ¬í˜„

### [í•„ìˆ˜] ìœ„ì¹˜ ê³µìœ  ì„œë¹„ìŠ¤
```dart
// íŒŒì¼: lib/features/influencer/services/location_sharing_service.dart
import 'dart:async';
import 'dart:math';
import 'package:geolocator/geolocator.dart';

class LocationSharingService {
  static final LocationSharingService _instance = LocationSharingService._internal();
  factory LocationSharingService() => _instance;
  LocationSharingService._internal();
  
  // ìƒíƒœ ê´€ë¦¬
  Timer? _updateTimer;
  StreamSubscription<Position>? _positionSubscription;
  bool _isSharing = false;
  DateTime? _sharingStartTime;
  
  // ìœ„ì¹˜ ê³µìœ  ì‹œì‘
  Future<bool> startSharing({required String userId, required int userGrade}) async {
    // ë“±ê¸‰ í™•ì¸
    if (userGrade < LocationSharingPolicy.minGradeForSharing) {
      throw Exception('ìˆ˜ëìƒ ë“±ê¸‰ ì´ìƒë§Œ ìœ„ì¹˜ ê³µìœ ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤');
    }
    
    // ì´ë¯¸ ê³µìœ  ì¤‘ì¸ì§€ í™•ì¸
    if (_isSharing) {
      return false;
    }
    
    // ìœ„ì¹˜ ê¶Œí•œ í™•ì¸
    final permission = await Geolocator.checkPermission();
    if (permission != LocationPermission.always && 
        permission != LocationPermission.whileInUse) {
      final requested = await Geolocator.requestPermission();
      if (requested != LocationPermission.always && 
          requested != LocationPermission.whileInUse) {
        return false;
      }
    }
    
    _isSharing = true;
    _sharingStartTime = DateTime.now();
    
    // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì‹œì‘
    _startLocationUpdates(userId);
    
    // ìë™ ì¢…ë£Œ íƒ€ì´ë¨¸
    _setAutoStopTimer();
    
    return true;
  }
  
  // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
  void _startLocationUpdates(String userId) {
    // ì£¼ê¸°ì  ì—…ë°ì´íŠ¸
    _updateTimer = Timer.periodic(LocationSharingPolicy.updateInterval, (_) async {
      if (!_isSharing) return;
      
      try {
        final position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high,
        );
        
        // ìœ„ì¹˜ ëª¨í˜¸í™”
        final fuzzedLocation = _fuzzyLocation(position);
        
        // Firestore ì—…ë°ì´íŠ¸
        await _updateLocationInFirestore(userId, fuzzedLocation);
      } catch (e) {
        print('Location update error: $e');
      }
    });
    
    // ì²« ì—…ë°ì´íŠ¸ëŠ” ì¦‰ì‹œ
    _updateTimer?.cancel();
    Timer.run(() => _updateTimer?.isActive);
  }
  
  // ìœ„ì¹˜ ëª¨í˜¸í™” (í”„ë¼ì´ë²„ì‹œ ë³´í˜¸)
  Position _fuzzyLocation(Position originalPosition) {
    final random = Random();
    final angle = random.nextDouble() * 2 * pi;
    final distance = random.nextDouble() * LocationSharingPolicy.locationFuzzingRadius;
    
    // ë¯¸í„° ë‹¨ìœ„ë¥¼ ìœ„ë„/ê²½ë„ë¡œ ë³€í™˜
    final latOffset = (distance * cos(angle)) / 111320.0;
    final lngOffset = (distance * sin(angle)) / (111320.0 * cos(originalPosition.latitude * pi / 180));
    
    return Position(
      latitude: originalPosition.latitude + latOffset,
      longitude: originalPosition.longitude + lngOffset,
      timestamp: originalPosition.timestamp,
      accuracy: LocationSharingPolicy.locationFuzzingRadius,
      altitude: originalPosition.altitude,
      heading: originalPosition.heading,
      speed: originalPosition.speed,
      speedAccuracy: originalPosition.speedAccuracy,
    );
  }
  
  // Firestore ì—…ë°ì´íŠ¸
  Future<void> _updateLocationInFirestore(String userId, Position position) async {
    final locationData = {
      'userId': userId,
      'location': {
        'latitude': position.latitude,
        'longitude': position.longitude,
      },
      'accuracy': position.accuracy,
      'updatedAt': FieldValue.serverTimestamp(),
      'isSharing': true,
    };
    
    if (AppConfig.current.isLocal) {
      // Mock ì—…ë°ì´íŠ¸
      print('Mock location update: $locationData');
      return;
    }
    
    await FirestoreService.instance
        .collection('influencer_locations')
        .doc(userId)
        .set(locationData, SetOptions(merge: true));
  }
  
  // ìë™ ì¢…ë£Œ íƒ€ì´ë¨¸
  void _setAutoStopTimer() {
    Timer(LocationSharingPolicy.maxSharingDuration, () {
      if (_isSharing) {
        stopSharing();
      }
    });
  }
  
  // ìœ„ì¹˜ ê³µìœ  ì¤‘ì§€
  Future<void> stopSharing({String? userId}) async {
    _isSharing = false;
    _updateTimer?.cancel();
    _positionSubscription?.cancel();
    
    if (userId != null) {
      // Firestoreì—ì„œ ê³µìœ  ìƒíƒœ ì—…ë°ì´íŠ¸
      if (!AppConfig.current.isLocal) {
        await FirestoreService.instance
            .collection('influencer_locations')
            .doc(userId)
            .update({'isSharing': false});
      }
    }
  }
  
  // ê³µìœ  ìƒíƒœ í™•ì¸
  bool get isSharing => _isSharing;
  
  // ê³µìœ  ì‹œê°„ í™•ì¸
  Duration? get sharingDuration {
    if (_sharingStartTime == null) return null;
    return DateTime.now().difference(_sharingStartTime!);
  }
}
```

### [í•„ìˆ˜] ìœ„ì¹˜ ê³µìœ  UI
```dart
// íŒŒì¼: lib/features/profile/widgets/location_sharing_toggle.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class LocationSharingToggle extends ConsumerStatefulWidget {
  final int userGrade;
  
  const LocationSharingToggle({required this.userGrade});
  
  @override
  _LocationSharingToggleState createState() => _LocationSharingToggleState();
}

class _LocationSharingToggleState extends ConsumerState<LocationSharingToggle> {
  final LocationSharingService _service = LocationSharingService();
  bool _isSharing = false;
  Timer? _durationTimer;
  Duration _sharingDuration = Duration.zero;
  
  @override
  void initState() {
    super.initState();
    _isSharing = _service.isSharing;
    if (_isSharing) {
      _startDurationTimer();
    }
  }
  
  @override
  Widget build(BuildContext context) {
    // ìˆ˜ëìƒ ë¯¸ë§Œì€ í‘œì‹œí•˜ì§€ ì•ŠìŒ
    if (widget.userGrade < LocationSharingPolicy.minGradeForSharing) {
      return SizedBox.shrink();
    }
    
    return Card(
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  Icons.location_on,
                  color: _isSharing ? AppColors.primaryOrange : Colors.grey,
                ),
                SizedBox(width: 8),
                Text(
                  'ì‹¤ì‹œê°„ ìœ„ì¹˜ ê³µìœ ',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Spacer(),
                Switch(
                  value: _isSharing,
                  onChanged: _onToggleSharing,
                  activeColor: AppColors.primaryOrange,
                ),
              ],
            ),
            
            SizedBox(height: 8),
            
            Text(
              _isSharing 
                  ? 'ì£¼ë³€ ì‚¬ìš©ìë“¤ì´ íšŒì›ë‹˜ì˜ ëŒ€ëµì ì¸ ìœ„ì¹˜ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤'
                  : 'ìœ„ì¹˜ ê³µìœ ê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤',
              style: TextStyle(
                color: Colors.grey[600],
                fontSize: 14,
              ),
            ),
            
            if (_isSharing) ...[
              SizedBox(height: 8),
              Text(
                'ê³µìœ  ì‹œê°„: ${_formatDuration(_sharingDuration)}',
                style: TextStyle(
                  color: AppColors.primaryOrange,
                  fontSize: 12,
                ),
              ),
              Text(
                'ìµœëŒ€ 4ì‹œê°„ê¹Œì§€ ê³µìœ ë©ë‹ˆë‹¤',
                style: TextStyle(
                  color: Colors.grey,
                  fontSize: 12,
                ),
              ),
            ],
            
            SizedBox(height: 12),
            
            // í”„ë¼ì´ë²„ì‹œ ì•ˆë‚´
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.blue[50],
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(Icons.info_outline, size: 16, color: Colors.blue),
                  SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'ì •í™•í•œ ìœ„ì¹˜ëŠ” ê³µê°œë˜ì§€ ì•Šìœ¼ë©°, 100m ë°˜ê²½ ë‚´ì—ì„œ ëª¨í˜¸í™”ë©ë‹ˆë‹¤',
                      style: TextStyle(fontSize: 12, color: Colors.blue[800]),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  void _onToggleSharing(bool value) async {
    if (value) {
      // ìœ„ì¹˜ ê³µìœ  ì‹œì‘ í™•ì¸
      final confirmed = await _showConsentDialog();
      if (!confirmed) return;
      
      final userId = ref.read(currentUserProvider)?.id;
      if (userId == null) return;
      
      final started = await _service.startSharing(
        userId: userId,
        userGrade: widget.userGrade,
      );
      
      if (started) {
        setState(() => _isSharing = true);
        _startDurationTimer();
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('ìœ„ì¹˜ ê³µìœ ê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤'),
            backgroundColor: AppColors.primaryOrange,
          ),
        );
      }
    } else {
      // ìœ„ì¹˜ ê³µìœ  ì¤‘ì§€
      final userId = ref.read(currentUserProvider)?.id;
      await _service.stopSharing(userId: userId);
      
      setState(() => _isSharing = false);
      _durationTimer?.cancel();
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('ìœ„ì¹˜ ê³µìœ ê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤')),
      );
    }
  }
  
  Future<bool> _showConsentDialog() async {
    return await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('ìœ„ì¹˜ ê³µìœ  ë™ì˜'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('ì‹¤ì‹œê°„ ìœ„ì¹˜ë¥¼ ê³µìœ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?'),
            SizedBox(height: 16),
            Text(
              'â€¢ 100m ë°˜ê²½ìœ¼ë¡œ ëª¨í˜¸í™”ëœ ìœ„ì¹˜ê°€ í‘œì‹œë©ë‹ˆë‹¤\n'
              'â€¢ ë‹‰ë„¤ì„ê³¼ ë“±ê¸‰ë§Œ ê³µê°œë©ë‹ˆë‹¤\n'
              'â€¢ ìµœëŒ€ 4ì‹œê°„ ë™ì•ˆ ê³µìœ ë©ë‹ˆë‹¤\n'
              'â€¢ ì–¸ì œë“  ì¤‘ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤',
              style: TextStyle(fontSize: 14, color: Colors.grey[600]),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('ì·¨ì†Œ'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primaryOrange,
            ),
            child: Text('ë™ì˜í•˜ê³  ì‹œì‘'),
          ),
        ],
      ),
    ) ?? false;
  }
  
  void _startDurationTimer() {
    _durationTimer = Timer.periodic(Duration(seconds: 1), (_) {
      setState(() {
        _sharingDuration = _service.sharingDuration ?? Duration.zero;
      });
    });
  }
  
  String _formatDuration(Duration duration) {
    final hours = duration.inHours;
    final minutes = (duration.inMinutes % 60).toString().padLeft(2, '0');
    final seconds = (duration.inSeconds % 60).toString().padLeft(2, '0');
    return '$hours:$minutes:$seconds';
  }
  
  @override
  void dispose() {
    _durationTimer?.cancel();
    super.dispose();
  }
}
```

### [í•„ìˆ˜] ì§€ë„ í‘œì‹œ
```dart
// íŒŒì¼: lib/features/map/widgets/influencer_markers.dart
class InfluencerMarkers extends StatelessWidget {
  final Set<InfluencerLocation> influencers;
  
  const InfluencerMarkers({required this.influencers});
  
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirestoreService.instance
          .collection('influencer_locations')
          .where('isSharing', isEqualTo: true)
          .snapshots(),
      builder: (context, snapshot) {
        if (!snapshot.hasData) return SizedBox.shrink();
        
        final markers = <Marker>{};
        
        for (final doc in snapshot.data!.docs) {
          final data = doc.data() as Map<String, dynamic>;
          final location = data['location'] as Map<String, dynamic>;
          
          markers.add(
            Marker(
              markerId: MarkerId('influencer_${doc.id}'),
              position: LatLng(
                location['latitude'],
                location['longitude'],
              ),
              icon: BitmapDescriptor.defaultMarkerWithHue(
                BitmapDescriptor.hueOrange,
              ),
              infoWindow: InfoWindow(
                title: 'â­ ì¸í”Œë£¨ì–¸ì„œ',
                snippet: 'ëŒ€ëµì ì¸ ìœ„ì¹˜ì…ë‹ˆë‹¤',
              ),
            ),
          );
        }
        
        return GoogleMap(
          markers: markers,
          // ê¸°íƒ€ ì§€ë„ ì„¤ì •...
        );
      },
    );
  }
}
```

## 4. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ìˆ˜ëìƒ ë“±ê¸‰ ì´ìƒë§Œ í† ê¸€ í‘œì‹œ
- [ ] ìœ„ì¹˜ ê³µìœ  ë™ì˜ ë‹¤ì´ì–¼ë¡œê·¸
- [ ] 100m ë°˜ê²½ ìœ„ì¹˜ ëª¨í˜¸í™” í™•ì¸
- [ ] 5ë¶„ë§ˆë‹¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
- [ ] 4ì‹œê°„ í›„ ìë™ ì¤‘ì§€
- [ ] ê³µìœ  ì‹œê°„ ì‹¤ì‹œê°„ í‘œì‹œ
- [ ] ì§€ë„ì— ì¸í”Œë£¨ì–¸ì„œ ë§ˆì»¤ í‘œì‹œ