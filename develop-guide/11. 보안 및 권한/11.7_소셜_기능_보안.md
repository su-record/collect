# ğŸ›¡ï¸ 11.7 ì†Œì…œ ê¸°ëŠ¥ ë³´ì•ˆ

## ğŸ“‹ ëª©ì°¨

1. [ê°œìš”](#1-ê°œìš”)
2. [íŒ”ë¡œìš° ì‹œìŠ¤í…œ ë³´ì•ˆ](#2-íŒ”ë¡œìš°-ì‹œìŠ¤í…œ-ë³´ì•ˆ)
3. [ì°¨ë‹¨ ê¸°ëŠ¥ êµ¬í˜„](#3-ì°¨ë‹¨-ê¸°ëŠ¥-êµ¬í˜„)
4. [ëŒ“ê¸€ ë³´ì•ˆ ë° í•„í„°ë§](#4-ëŒ“ê¸€-ë³´ì•ˆ-ë°-í•„í„°ë§)
5. [ì¸í”Œë£¨ì–¸ì„œ ë³´í˜¸](#5-ì¸í”Œë£¨ì–¸ì„œ-ë³´í˜¸)

## 1. ê°œìš”

Fallingoì˜ ì†Œì…œ ê¸°ëŠ¥ì„ ì•ˆì „í•˜ê²Œ ìš´ì˜í•˜ê³  ì‚¬ìš©ìë¥¼ ë³´í˜¸í•˜ê¸° ìœ„í•œ ë³´ì•ˆ ì „ëµì„ ì •ì˜í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸

- âœ… í”„ë¼ì´ë²„ì‹œ ìš°ì„  íŒ”ë¡œìš° ì‹œìŠ¤í…œ
- âœ… ê°•ë ¥í•œ ì°¨ë‹¨ ë° ì‹ ê³  ê¸°ëŠ¥
- âœ… AI ê¸°ë°˜ ìœ í•´ ì½˜í…ì¸  í•„í„°ë§
- âœ… ì¸í”Œë£¨ì–¸ì„œ íŠ¹ë³„ ë³´í˜¸ ì¡°ì¹˜

## 2. íŒ”ë¡œìš° ì‹œìŠ¤í…œ ë³´ì•ˆ

### [í•„ìˆ˜] íŒ”ë¡œìš° ê´€ê³„ í…Œì´ë¸” ë° ë³´ì•ˆ

```sql
-- íŒŒì¼: backend/migrations/secure_follow_system.sql

-- íŒ”ë¡œìš° ê´€ê³„ í…Œì´ë¸”
CREATE TABLE user_follows (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    follower_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    following_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    followed_at TIMESTAMP DEFAULT NOW(),
    is_mutual BOOLEAN DEFAULT FALSE,
    visibility_level VARCHAR(20) DEFAULT 'public',

    -- ì¤‘ë³µ ë°©ì§€
    UNIQUE(follower_id, following_id),

    -- ìê¸° ìì‹  íŒ”ë¡œìš° ë°©ì§€
    CONSTRAINT no_self_follow CHECK (follower_id != following_id)
);

-- íŒ”ë¡œìš° ìš”ì²­ í…Œì´ë¸” (ë¹„ê³µê°œ ê³„ì •ìš©)
CREATE TABLE follow_requests (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    requester_id UUID NOT NULL REFERENCES users(id),
    target_id UUID NOT NULL REFERENCES users(id),
    requested_at TIMESTAMP DEFAULT NOW(),
    status VARCHAR(20) DEFAULT 'pending', -- pending, accepted, rejected
    responded_at TIMESTAMP,

    UNIQUE(requester_id, target_id)
);

-- RLS ì •ì±…
ALTER TABLE user_follows ENABLE ROW LEVEL SECURITY;

-- ìì‹ ì˜ íŒ”ë¡œìš° ê´€ê³„ë§Œ ìƒì„±
CREATE POLICY "Users can create own follows"
ON user_follows FOR INSERT
TO authenticated
USING (auth.uid() = follower_id);

-- íŒ”ë¡œìš° ëª©ë¡ ì¡°íšŒ ê¶Œí•œ
CREATE POLICY "Users can view follow relationships"
ON user_follows FOR SELECT
TO authenticated
USING (
    -- ìì‹ ì˜ íŒ”ë¡œìš° ê´€ê³„
    auth.uid() IN (follower_id, following_id)
    OR
    -- ê³µê°œ í”„ë¡œí•„ì˜ íŒ”ë¡œìš° ê´€ê³„
    EXISTS (
        SELECT 1 FROM user_profiles
        WHERE user_id = following_id
        AND privacy_settings->>'follow_list_visibility' = 'public'
    )
    OR
    -- ì¸í”Œë£¨ì–¸ì„œì˜ íŒ”ë¡œì›Œ ëª©ë¡ (ì„ íƒì  ê³µê°œ)
    EXISTS (
        SELECT 1 FROM user_profiles
        WHERE user_id = following_id
        AND user_level >= 7  -- ìˆ˜ëìƒ ì´ìƒ
        AND privacy_settings->>'show_followers' = 'true'
    )
);
```

### [í•„ìˆ˜] íŒ”ë¡œìš° API ë³´ì•ˆ

```python
# íŒŒì¼: backend/api/social/follow_security.py
from flask import Blueprint, g, jsonify
from backend.core.security import rate_limit, validate_user

follow_bp = Blueprint('follow', __name__)

class FollowSecurity:
    """íŒ”ë¡œìš° ì‹œìŠ¤í…œ ë³´ì•ˆ ê´€ë¦¬"""

    @staticmethod
    async def can_follow(follower_id: str, target_id: str) -> tuple[bool, str]:
        """íŒ”ë¡œìš° ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸"""

        # ì°¨ë‹¨ ê´€ê³„ í™•ì¸
        if await BlockManager.is_blocked(follower_id, target_id):
            return False, "Blocked user"

        # íŒ”ë¡œìš° ì œí•œ í™•ì¸ (ìŠ¤íŒ¸ ë°©ì§€)
        follow_count = await FollowSecurity._get_recent_follow_count(follower_id)
        if follow_count > 50:  # í•˜ë£¨ 50ëª… ì œí•œ
            return False, "Follow limit exceeded"

        # íƒ€ê²Ÿ ì‚¬ìš©ì ì„¤ì • í™•ì¸
        target_profile = await g.supabase.table('user_profiles')\
            .select('privacy_settings')\
            .eq('user_id', target_id)\
            .single()\
            .execute()

        if target_profile.data['privacy_settings'].get('require_follow_approval'):
            # íŒ”ë¡œìš° ìš”ì²­ í•„ìš”
            return True, "Request required"

        return True, "OK"

    @staticmethod
    async def _get_recent_follow_count(user_id: str) -> int:
        """ìµœê·¼ 24ì‹œê°„ íŒ”ë¡œìš° ìˆ˜ í™•ì¸"""
        yesterday = datetime.utcnow() - timedelta(days=1)

        result = await g.supabase.table('user_follows')\
            .select('count')\
            .eq('follower_id', user_id)\
            .gte('followed_at', yesterday)\
            .execute()

        return result.data[0]['count'] if result.data else 0

@follow_bp.route('/follow/<user_id>', methods=['POST'])
@require_auth
@rate_limit(10, 60)  # ë¶„ë‹¹ 10íšŒ ì œí•œ
async def follow_user(user_id: str):
    """ì‚¬ìš©ì íŒ”ë¡œìš°"""
    follower_id = g.current_user.id

    # ë³´ì•ˆ ê²€ì¦
    can_follow, reason = await FollowSecurity.can_follow(follower_id, user_id)

    if not can_follow:
        return jsonify({'error': reason}), 403

    if reason == "Request required":
        # íŒ”ë¡œìš° ìš”ì²­ ìƒì„±
        await g.supabase.table('follow_requests').insert({
            'requester_id': follower_id,
            'target_id': user_id
        }).execute()

        # ì•Œë¦¼ ì „ì†¡
        await NotificationService.send_follow_request(user_id, follower_id)

        return jsonify({'status': 'requested'}), 201

    # íŒ”ë¡œìš° ê´€ê³„ ìƒì„±
    try:
        await g.supabase.table('user_follows').insert({
            'follower_id': follower_id,
            'following_id': user_id
        }).execute()

        # ìƒí˜¸ íŒ”ë¡œìš° í™•ì¸
        mutual = await FollowSecurity._check_mutual_follow(follower_id, user_id)
        if mutual:
            await FollowSecurity._update_mutual_status(follower_id, user_id)

        return jsonify({'status': 'following', 'is_mutual': mutual}), 201

    except Exception as e:
        return jsonify({'error': 'Follow failed'}), 400
```

### [í•„ìˆ˜] í”„ë¡ íŠ¸ì—”ë“œ íŒ”ë¡œìš° ë³´ì•ˆ

```dart
// íŒŒì¼: lib/features/social/domain/usecases/follow_manager.dart
class FollowManager {
  static final _supabase = Supabase.instance.client;
  static final _followCache = <String, FollowStatus>{};

  // íŒ”ë¡œìš° ìƒíƒœ í™•ì¸ (ìºì‹œ í™œìš©)
  static Future<FollowStatus> getFollowStatus(String targetUserId) async {
    final currentUserId = _supabase.auth.currentUser?.id;
    if (currentUserId == null) return FollowStatus.notAuthenticated;

    // ìºì‹œ í™•ì¸
    final cacheKey = '$currentUserId:$targetUserId';
    if (_followCache.containsKey(cacheKey)) {
      return _followCache[cacheKey]!;
    }

    try {
      // íŒ”ë¡œìš° ê´€ê³„ í™•ì¸
      final follow = await _supabase
          .from('user_follows')
          .select()
          .eq('follower_id', currentUserId)
          .eq('following_id', targetUserId)
          .maybeSingle();

      // íŒ”ë¡œìš° ìš”ì²­ í™•ì¸
      final request = await _supabase
          .from('follow_requests')
          .select()
          .eq('requester_id', currentUserId)
          .eq('target_id', targetUserId)
          .eq('status', 'pending')
          .maybeSingle();

      final status = follow != null
          ? FollowStatus.following
          : request != null
              ? FollowStatus.requested
              : FollowStatus.notFollowing;

      // ìºì‹œ ì—…ë°ì´íŠ¸
      _followCache[cacheKey] = status;

      return status;
    } catch (e) {
      return FollowStatus.error;
    }
  }

  // ì•ˆì „í•œ íŒ”ë¡œìš° í† ê¸€
  static Future<bool> toggleFollow(String targetUserId) async {
    try {
      // í˜„ì¬ ìƒíƒœ í™•ì¸
      final currentStatus = await getFollowStatus(targetUserId);

      // ì¿¨ë‹¤ìš´ ì²´í¬ (ì—°ì† í´ë¦­ ë°©ì§€)
      if (!_cooldownManager.canPerformAction('follow:$targetUserId')) {
        throw Exception('ë„ˆë¬´ ë¹ ë¥¸ ìš”ì²­ì…ë‹ˆë‹¤');
      }

      switch (currentStatus) {
        case FollowStatus.notFollowing:
          return await _followUser(targetUserId);
        case FollowStatus.following:
          return await _unfollowUser(targetUserId);
        case FollowStatus.requested:
          return await _cancelFollowRequest(targetUserId);
        default:
          return false;
      }
    } catch (e) {
      _handleFollowError(e);
      return false;
    }
  }
}
```

## 3. ì°¨ë‹¨ ê¸°ëŠ¥ êµ¬í˜„

### [í•„ìˆ˜] ì°¨ë‹¨ ì‹œìŠ¤í…œ DB êµ¬ì¡°

```sql
-- íŒŒì¼: backend/migrations/block_system.sql

-- ì°¨ë‹¨ ê´€ê³„ í…Œì´ë¸”
CREATE TABLE user_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    blocker_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    blocked_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    blocked_at TIMESTAMP DEFAULT NOW(),
    reason VARCHAR(100),

    -- ì–‘ë°©í–¥ ì°¨ë‹¨ì„ ìœ„í•œ ì¸ë±ìŠ¤
    UNIQUE(blocker_id, blocked_id)
);

-- ì°¨ë‹¨ íš¨ê³¼ ë·° (ì–‘ë°©í–¥ ì°¨ë‹¨ êµ¬í˜„)
CREATE VIEW blocked_relationships AS
SELECT
    blocker_id as user1_id,
    blocked_id as user2_id
FROM user_blocks
UNION
SELECT
    blocked_id as user1_id,
    blocker_id as user2_id
FROM user_blocks;

-- ì°¨ë‹¨ ì‹œ ìë™ ì–¸íŒ”ë¡œìš° íŠ¸ë¦¬ê±°
CREATE OR REPLACE FUNCTION auto_unfollow_on_block()
RETURNS TRIGGER AS $$
BEGIN
    -- ì–‘ë°©í–¥ íŒ”ë¡œìš° ê´€ê³„ ì‚­ì œ
    DELETE FROM user_follows
    WHERE (follower_id = NEW.blocker_id AND following_id = NEW.blocked_id)
       OR (follower_id = NEW.blocked_id AND following_id = NEW.blocker_id);

    -- íŒ”ë¡œìš° ìš”ì²­ë„ ì‚­ì œ
    DELETE FROM follow_requests
    WHERE (requester_id = NEW.blocker_id AND target_id = NEW.blocked_id)
       OR (requester_id = NEW.blocked_id AND target_id = NEW.blocker_id);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_auto_unfollow
AFTER INSERT ON user_blocks
FOR EACH ROW
EXECUTE FUNCTION auto_unfollow_on_block();
```

### [í•„ìˆ˜] ì°¨ë‹¨ ê´€ë¦¬ API

```python
# íŒŒì¼: backend/api/social/block_manager.py
class BlockManager:
    """ì°¨ë‹¨ ì‹œìŠ¤í…œ ê´€ë¦¬"""

    @staticmethod
    async def block_user(blocker_id: str, blocked_id: str, reason: str = None):
        """ì‚¬ìš©ì ì°¨ë‹¨ ì²˜ë¦¬"""

        # ìê¸° ìì‹  ì°¨ë‹¨ ë°©ì§€
        if blocker_id == blocked_id:
            raise ValueError("Cannot block yourself")

        # ì´ë¯¸ ì°¨ë‹¨í–ˆëŠ”ì§€ í™•ì¸
        existing = await g.supabase.table('user_blocks')\
            .select('id')\
            .eq('blocker_id', blocker_id)\
            .eq('blocked_id', blocked_id)\
            .execute()

        if existing.data:
            return {'status': 'already_blocked'}

        # ì°¨ë‹¨ ê´€ê³„ ìƒì„±
        await g.supabase.table('user_blocks').insert({
            'blocker_id': blocker_id,
            'blocked_id': blocked_id,
            'reason': reason
        }).execute()

        # ìºì‹œ ë¬´íš¨í™”
        await CacheManager.invalidate_pattern(f'block:*{blocker_id}*')
        await CacheManager.invalidate_pattern(f'block:*{blocked_id}*')

        # ì‹¤ì‹œê°„ ì•Œë¦¼ ì°¨ë‹¨ (Realtime)
        await RealtimeManager.block_channels(blocker_id, blocked_id)

        return {'status': 'blocked'}

    @staticmethod
    async def is_blocked(user1_id: str, user2_id: str) -> bool:
        """ì°¨ë‹¨ ê´€ê³„ í™•ì¸ (ì–‘ë°©í–¥)"""

        # ìºì‹œ í™•ì¸
        cache_key = f'block:{min(user1_id, user2_id)}:{max(user1_id, user2_id)}'
        cached = await CacheManager.get(cache_key)
        if cached is not None:
            return cached

        # DB ì¡°íšŒ
        result = await g.supabase.table('blocked_relationships')\
            .select('count')\
            .eq('user1_id', user1_id)\
            .eq('user2_id', user2_id)\
            .execute()

        is_blocked = result.data[0]['count'] > 0 if result.data else False

        # ìºì‹œ ì €ì¥ (5ë¶„)
        await CacheManager.set(cache_key, is_blocked, ttl=300)

        return is_blocked

    @staticmethod
    async def apply_block_filter(query, user_id: str):
        """ì¿¼ë¦¬ì— ì°¨ë‹¨ í•„í„° ì ìš©"""

        # ì°¨ë‹¨í•œ ì‚¬ìš©ìë“¤ì˜ ID ëª©ë¡
        blocked_users = await g.supabase.table('user_blocks')\
            .select('blocked_id')\
            .eq('blocker_id', user_id)\
            .execute()

        blocked_ids = [b['blocked_id'] for b in blocked_users.data]

        # ë‚˜ë¥¼ ì°¨ë‹¨í•œ ì‚¬ìš©ìë“¤ì˜ ID ëª©ë¡
        blocking_users = await g.supabase.table('user_blocks')\
            .select('blocker_id')\
            .eq('blocked_id', user_id)\
            .execute()

        blocking_ids = [b['blocker_id'] for b in blocking_users.data]

        # ì „ì²´ ì°¨ë‹¨ ëª©ë¡
        all_blocked = list(set(blocked_ids + blocking_ids))

        if all_blocked:
            # ì°¨ë‹¨ëœ ì‚¬ìš©ìì˜ ì½˜í…ì¸  ì œì™¸
            query = query.not_.in_('user_id', all_blocked)

        return query
```

### [í•„ìˆ˜] í”„ë¡ íŠ¸ì—”ë“œ ì°¨ë‹¨ UI

```dart
// íŒŒì¼: lib/features/social/presentation/screens/block_manager_ui.dart
class BlockManagerUI extends ConsumerWidget {
  static final _blockManager = BlockManager();

  // ì°¨ë‹¨ ë‹¤ì´ì–¼ë¡œê·¸
  static Future<bool> showBlockDialog(
    BuildContext context,
    String userId,
    String username,
  ) async {
    return await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('ì‚¬ìš©ì ì°¨ë‹¨'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('$usernameë‹˜ì„ ì°¨ë‹¨í•˜ì‹œê² ìŠµë‹ˆê¹Œ?'),
            const SizedBox(height: 16),
            const Text(
              'ì°¨ë‹¨í•˜ë©´:\n'
              'â€¢ ì„œë¡œì˜ ê²Œì‹œë¬¼ì„ ë³¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤\n'
              'â€¢ ì„œë¡œ íŒ”ë¡œìš°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤\n'
              'â€¢ ì„œë¡œ ëŒ“ê¸€ì„ ë‹¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
              style: TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('ì·¨ì†Œ'),
          ),
          ElevatedButton(
            onPressed: () async {
              final success = await _blockManager.blockUser(userId);
              if (context.mounted) {
                Navigator.pop(context, success);
                if (success) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤')),
                  );
                }
              }
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('ì°¨ë‹¨'),
          ),
        ],
      ),
    ) ?? false;
  }

  // ì°¨ë‹¨ ëª©ë¡ í™”ë©´
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final blockedUsers = ref.watch(blockedUsersProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('ì°¨ë‹¨ ê´€ë¦¬')),
      body: blockedUsers.when(
        data: (users) => ListView.builder(
          itemCount: users.length,
          itemBuilder: (context, index) {
            final user = users[index];
            return ListTile(
              leading: CircleAvatar(
                backgroundImage: NetworkImage(user.profileImage),
              ),
              title: Text(user.username),
              subtitle: Text('ì°¨ë‹¨ì¼: ${user.blockedAt}'),
              trailing: TextButton(
                onPressed: () => _showUnblockDialog(context, user),
                child: const Text('ì°¨ë‹¨ í•´ì œ'),
              ),
            );
          },
        ),
        loading: () => const CircularProgressIndicator(),
        error: (e, s) => Text('ì˜¤ë¥˜: $e'),
      ),
    );
  }
}
```

## 4. ëŒ“ê¸€ ë³´ì•ˆ ë° í•„í„°ë§

### [í•„ìˆ˜] AI ê¸°ë°˜ ìœ í•´ ì½˜í…ì¸  í•„í„°

```python
# íŒŒì¼: backend/core/moderation/content_filter.py
import re
from typing import Dict, Tuple
import tensorflow as tf

class ContentModerationFilter:
    """AI ê¸°ë°˜ ì½˜í…ì¸  ê²€ì—´"""

    def __init__(self):
        # ìš•ì„¤/ë¹„ì†ì–´ íŒ¨í„´ ë¡œë“œ
        self.profanity_patterns = self._load_profanity_patterns()

        # TensorFlow ëª¨ë¸ ë¡œë“œ (ì‚¬ì „ í›ˆë ¨ëœ í…ìŠ¤íŠ¸ ë¶„ë¥˜ ëª¨ë¸)
        self.toxicity = tf.keras.models.load('models/toxicity_classifier')

    async def moderate_comment(self, text: str, user_id: str) -> Dict[str, any]:
        """ëŒ“ê¸€ ê²€ì—´"""

        # 1. ê¸°ë³¸ í•„í„°ë§
        basic_check = self._basic_filtering(text)
        if not basic_check['passed']:
            return {
                'allowed': False,
                'reason': basic_check['reason'],
                'severity': 'high'
            }

        # 2. AI ë…ì„± ì ìˆ˜ ê³„ì‚°
        toxicity_score = await self._calculate_toxicity(text)

        # 3. ì‚¬ìš©ì ì‹ ë¢°ë„ í™•ì¸
        user_trust = await self._get_user_trust_score(user_id)

        # 4. ì¢…í•© íŒë‹¨
        threshold = 0.7 if user_trust > 0.8 else 0.5

        if toxicity_score > threshold:
            return {
                'allowed': False,
                'reason': 'toxic_content',
                'severity': 'medium',
                'score': toxicity_score
            }

        # 5. ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ê²½ìš° ì‚¬í›„ ê²€í†  ëŒ€ìƒ
        if toxicity_score > 0.3:
            await self._flag_for_review(text, user_id, toxicity_score)

        return {
            'allowed': True,
            'score': toxicity_score,
            'filtered_text': self._apply_soft_filter(text)
        }

    def _basic_filtering(self, text: str) -> Dict[str, any]:
        """ê¸°ë³¸ í•„í„°ë§ ê·œì¹™"""

        # ê¸¸ì´ ì²´í¬
        if len(text) > 500:
            return {'passed': False, 'reason': 'too_long'}

        # ë°˜ë³µ ë¬¸ì ì²´í¬
        if re.search(r'(.)\1{4,}', text):
            return {'passed': False, 'reason': 'spam_pattern'}

        # ìš•ì„¤ íŒ¨í„´ ì²´í¬
        for pattern in self.profanity_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return {'passed': False, 'reason': 'profanity'}

        # URL ìŠ¤íŒ¸ ì²´í¬
        url_count = len(re.findall(r'https?://\S+', text))
        if url_count > 2:
            return {'passed': False, 'reason': 'url_spam'}

        return {'passed': True}

    async def _calculate_toxicity(self, text: str) -> float:
        """AI ëª¨ë¸ë¡œ ë…ì„± ì ìˆ˜ ê³„ì‚°"""

        # í…ìŠ¤íŠ¸ ì „ì²˜ë¦¬
        processed = self._preprocess_text(text)

        # ëª¨ë¸ ì˜ˆì¸¡
        prediction = self.toxicity.predict([processed])[0][0]

        return float(prediction)

    def _apply_soft_filter(self, text: str) -> str:
        """ì•½í•œ ìš•ì„¤ì€ ë§ˆìŠ¤í‚¹ ì²˜ë¦¬"""

        mild_profanity = ['ë°”ë³´', 'ë©ì²­ì´']  # ì˜ˆì‹œ

        for word in mild_profanity:
            if word in text:
                masked = word[0] + '*' * (len(word) - 1)
                text = text.replace(word, masked)

        return text
```

### [í•„ìˆ˜] ëŒ“ê¸€ ë³´ì•ˆ API

```python
# íŒŒì¼: backend/api/social/comment_security.py
@comment_bp.route('/feeds/<feed_id>/comments', methods=['POST'])
@require_auth
@rate_limit(5, 60)  # ë¶„ë‹¹ 5ê°œ ëŒ“ê¸€ ì œí•œ
async def create_comment(feed_id: str):
    """ëŒ“ê¸€ ì‘ì„±"""

    user_id = g.current_user.id
    content = request.json.get('content', '').strip()

    # ì°¨ë‹¨ ê´€ê³„ í™•ì¸
    feed = await g.supabase.table('feeds')\
        .select('user_id')\
        .eq('id', feed_id)\
        .single()\
        .execute()

    if await BlockManager.is_blocked(user_id, feed.data['user_id']):
        return jsonify({'error': 'Blocked'}), 403

    # ì½˜í…ì¸  ê²€ì—´
    moderation = await ContentModerationFilter().moderate_comment(content, user_id)

    if not moderation['allowed']:
        # ê²€ì—´ ë¡œê·¸ ê¸°ë¡
        await ModerationLog.create({
            'user_id': user_id,
            'content_type': 'comment',
            'content': content,
            'action': 'blocked',
            'reason': moderation['reason']
        })

        return jsonify({
            'error': 'inappropriate_content',
            'message': 'ë¶€ì ì ˆí•œ ë‚´ìš©ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤'
        }), 400

    # ëŒ“ê¸€ ìƒì„±
    comment = await g.supabase.table('comments').insert({
        'feed_id': feed_id,
        'user_id': user_id,
        'content': moderation['filtered_text'],
        'original_content': content if moderation['filtered_text'] != content else None,
        'moderation_score': moderation.get('score', 0)
    }).execute()

    # ì•Œë¦¼ ì „ì†¡ (ì°¨ë‹¨ë˜ì§€ ì•Šì€ ê²½ìš°ë§Œ)
    if not await BlockManager.is_blocked(feed.data['user_id'], user_id):
        await NotificationService.send_comment_notification(
            feed.data['user_id'],
            user_id,
            feed_id
        )

    return jsonify(comment.data[0]), 201
```

### [í•„ìˆ˜] ì‹¤ì‹œê°„ ëŒ“ê¸€ í•„í„°ë§

```dart
// íŒŒì¼: lib/features/social/presentation/widgets/comment_filter.dart
class CommentFilter {
  // í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œ ê¸°ë³¸ í•„í„°
  static final _basicProfanityRegex = RegExp(
    r'(ìš•ì„¤íŒ¨í„´1|ìš•ì„¤íŒ¨í„´2)',
    caseSensitive: false,
  );

  static String? validateComment(String text) {
    // ë¹ˆ ëŒ“ê¸€
    if (text.trim().isEmpty) {
      return 'ëŒ“ê¸€ì„ ì…ë ¥í•´ì£¼ì„¸ìš”';
    }

    // ê¸¸ì´ ì œí•œ
    if (text.length > 500) {
      return 'ëŒ“ê¸€ì€ 500ì ì´ë‚´ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”';
    }

    // ê¸°ë³¸ ìš•ì„¤ ì²´í¬
    if (_basicProfanityRegex.hasMatch(text)) {
      return 'ë¶€ì ì ˆí•œ í‘œí˜„ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤';
    }

    // ë°˜ë³µ ë¬¸ì ì²´í¬
    if (RegExp(r'(.)\1{4,}').hasMatch(text)) {
      return 'ë°˜ë³µë˜ëŠ” ë¬¸ìë¥¼ ì¤„ì—¬ì£¼ì„¸ìš”';
    }

    return null; // í†µê³¼
  }

  // ì‹¤ì‹œê°„ ë§ˆìŠ¤í‚¹
  static String applySoftMasking(String text) {
    const mildWords = ['ë°”ë³´', 'ë©ì²­ì´'];

    String filtered = text;
    for (final word in mildWords) {
      if (filtered.contains(word)) {
        final masked = word[0] + '*' * (word.length - 1);
        filtered = filtered.replaceAll(word, masked);
      }
    }

    return filtered;
  }
}

// ëŒ“ê¸€ ì…ë ¥ ìœ„ì ¯
class CommentInput extends StatefulWidget {
  final String feedId;

  const CommentInput({required this.feedId});

  @override
  State<CommentInput> createState() => _CommentInputState();
}

class _CommentInputState extends State<CommentInput> {
  final _controller = TextEditingController();
  final _focusNode = FocusNode();
  bool _isSubmitting = false;

  Future<void> _submitComment() async {
    final text = _controller.text;

    // í´ë¼ì´ì–¸íŠ¸ ê²€ì¦
    final error = CommentFilter.validateComment(text);
    if (error != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(error)),
      );
      return;
    }

    setState(() => _isSubmitting = true);

    try {
      // ì„œë²„ ì „ì†¡
      await CommentService.createComment(
        feedId: widget.feedId,
        content: text,
      );

      _controller.clear();
      _focusNode.unfocus();

    } catch (e) {
      if (e.toString().contains('inappropriate_content')) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('ë¶€ì ì ˆí•œ ë‚´ìš©ì´ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      setState(() => _isSubmitting = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(8.0),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _controller,
              focusNode: _focusNode,
              maxLength: 500,
              decoration: const InputDecoration(
                hintText: 'ëŒ“ê¸€ì„ ì…ë ¥í•˜ì„¸ìš”...',
                border: OutlineInputBorder(),
              ),
              onChanged: (text) {
                // ì‹¤ì‹œê°„ ì†Œí”„íŠ¸ í•„í„°ë§ í‘œì‹œ
                setState(() {});
              },
            ),
          ),
          IconButton(
            onPressed: _isSubmitting ? null : _submitComment,
            icon: _isSubmitting
                ? const CircularProgressIndicator()
                : const Icon(Icons.send),
          ),
        ],
      ),
    );
  }
}
```

## 5. ì¸í”Œë£¨ì–¸ì„œ ë³´í˜¸

### [í•„ìˆ˜] ì¸í”Œë£¨ì–¸ì„œ íŠ¹ë³„ ë³´í˜¸ ì •ì±…

```sql
-- íŒŒì¼: backend/migrations/influencer_protection.sql

-- ì¸í”Œë£¨ì–¸ì„œ ë³´í˜¸ ì„¤ì •
CREATE TABLE influencer_protection_settings (
    user_id UUID PRIMARY KEY REFERENCES users(id),

    -- ìœ„ì¹˜ ê³µìœ  ë³´í˜¸
    location_blur_radius INTEGER DEFAULT 1000, -- ë¯¸í„° ë‹¨ìœ„
    location_share_schedule JSONB, -- ì‹œê°„ëŒ€ë³„ ê³µìœ  ì„¤ì •

    -- ëŒ“ê¸€ ë³´í˜¸
    comment_moderation_level VARCHAR(20) DEFAULT 'standard', -- strict, standard, relaxed
    auto_hide_toxic_comments BOOLEAN DEFAULT TRUE,
    require_comment_approval BOOLEAN DEFAULT FALSE,

    -- íŒ”ë¡œìš° ë³´í˜¸
    require_follow_approval BOOLEAN DEFAULT TRUE,
    follower_quality_filter BOOLEAN DEFAULT TRUE,

    -- ê°œì¸ì •ë³´ ë³´í˜¸
    hide_real_name BOOLEAN DEFAULT TRUE,
    hide_contact_info BOOLEAN DEFAULT TRUE,
    watermark_photos BOOLEAN DEFAULT FALSE,

    updated_at TIMESTAMP DEFAULT NOW()
);

-- ì¸í”Œë£¨ì–¸ì„œ ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê·¸
CREATE TABLE influencer_security_events (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    influencer_id UUID REFERENCES users(id),
    event_type VARCHAR(50), -- stalking_attempt, mass_follow, location_leak
    severity VARCHAR(20), -- low, medium, high, critical
    details JSONB,
    ip_address INET,
    created_at TIMESTAMP DEFAULT NOW()
);

-- ì¸í”Œë£¨ì–¸ì„œ ì „ìš© ì°¨ë‹¨ ë¦¬ìŠ¤íŠ¸ (IP ë ˆë²¨)
CREATE TABLE influencer_ip_blocks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    influencer_id UUID REFERENCES users(id),
    blocked_ip INET,
    reason TEXT,
    blocked_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP
);
```

### [í•„ìˆ˜] ì¸í”Œë£¨ì–¸ì„œ ë³´í˜¸ ì„œë¹„ìŠ¤

```python
# íŒŒì¼: backend/core/security/influencer_protection.py
class InfluencerProtectionService:
    """ì¸í”Œë£¨ì–¸ì„œ íŠ¹ë³„ ë³´í˜¸ ê¸°ëŠ¥"""

    @staticmethod
    async def protect_location(influencer_id: str, location: dict) -> dict:
        """ì¸í”Œë£¨ì–¸ì„œ ìœ„ì¹˜ ë³´í˜¸"""

        # ë³´í˜¸ ì„¤ì • ì¡°íšŒ
        settings = await g.supabase.table('influencer_protection_settings')\
            .select('*')\
            .eq('user_id', influencer_id)\
            .single()\
            .execute()

        if not settings.data:
            return location

        protection = settings.data

        # 1. ìœ„ì¹˜ ë¸”ëŸ¬ ì²˜ë¦¬
        blur_radius = protection['location_blur_radius']
        blurred_location = LocationAnonymizer.add_random_offset(
            location['latitude'],
            location['longitude'],
            blur_radius
        )

        # 2. ì‹œê°„ëŒ€ë³„ ê³µìœ  í™•ì¸
        current_hour = datetime.utcnow().hour
        schedule = protection.get('location_share_schedule', {})

        if str(current_hour) not in schedule.get('allowed_hours', []):
            # ì´ ì‹œê°„ëŒ€ëŠ” ìœ„ì¹˜ ê³µìœ  ì•ˆ í•¨
            return None

        # 3. ìŠ¤í† í‚¹ íŒ¨í„´ ê°ì§€
        if await InfluencerProtectionService._detect_stalking_pattern(influencer_id):
            await SecurityAlert.notify_influencer_stalking(influencer_id)
            return None

        return {
            'latitude': blurred_location[0],
            'longitude': blurred_location[1],
            'accuracy': blur_radius,
            'is_approximate': True
        }

    @staticmethod
    async def _detect_stalking_pattern(influencer_id: str) -> bool:
        """ìŠ¤í† í‚¹ íŒ¨í„´ ê°ì§€"""

        # ìµœê·¼ 1ì‹œê°„ ë™ì•ˆ ê°™ì€ ì‚¬ìš©ìê°€ ë°˜ë³µì ìœ¼ë¡œ ìœ„ì¹˜ ì¡°íšŒ
        suspicious_patterns = await g.supabase.rpc(
            'detect_location_stalking',
            {'influencer_id': influencer_id}
        ).execute()

        return len(suspicious_patterns.data) > 0

    @staticmethod
    async def enhanced_comment_moderation(
        influencer_id: str,
        comment: dict
    ) -> dict:
        """ì¸í”Œë£¨ì–¸ì„œ ëŒ€ìƒ ëŒ“ê¸€ ê°•í™” ê²€ì—´"""

        settings = await InfluencerProtectionService._get_protection_settings(
            influencer_id
        )

        # ì—„ê²©í•œ ê²€ì—´ ëª¨ë“œ
        if settings['comment_moderation_level'] == 'strict':
            # ì‹ ê·œ ê³„ì • ì°¨ë‹¨
            commenter = await UserService.get_user(comment['user_id'])
            if commenter['created_at'] > datetime.utcnow() - timedelta(days=7):
                return {'allowed': False, 'reason': 'new_account'}

            # ë‚®ì€ ë“±ê¸‰ ì‚¬ìš©ì ì°¨ë‹¨
            if commenter['user_level'] < 3:  # ì‚¼ê²¹ì‚´ ë¯¸ë§Œ
                return {'allowed': False, 'reason': 'low_level'}

        # AI ê²€ì—´ ê°•í™”
        toxicity_threshold = 0.3 if settings['comment_moderation_level'] == 'strict' else 0.5

        moderation = await ContentModerationFilter().moderate_comment(
            comment['content'],
            comment['user_id'],
            threshold=toxicity_threshold
        )

        # ìŠ¹ì¸ ëŒ€ê¸°
        if settings['require_comment_approval'] and moderation['score'] > 0.2:
            comment['status'] = 'pending_approval'
            await NotificationService.notify_comment_approval(influencer_id, comment)

        return moderation
```

### [í•„ìˆ˜] ì¸í”Œë£¨ì–¸ì„œ ë³´í˜¸ UI

```dart
// íŒŒì¼: lib/features/influencer/protection_settings.dart
class InfluencerProtectionSettings extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settings = ref.watch(protectionSettingsProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('ğŸ›¡ï¸ ë³´í˜¸ ì„¤ì •'),
        actions: [
          IconButton(
            icon: const Icon(Icons.info),
            onPressed: () => _showProtectionGuide(context),
          ),
        ],
      ),
      body: settings.when(
        data: (data) => ListView(
          children: [
            // ìœ„ì¹˜ ë³´í˜¸
            _buildLocationProtection(context, ref, data),

            // ëŒ“ê¸€ ë³´í˜¸
            _buildCommentProtection(context, ref, data),

            // íŒ”ë¡œì›Œ ê´€ë¦¬
            _buildFollowerProtection(context, ref, data),

            // ê°œì¸ì •ë³´ ë³´í˜¸
            _buildPrivacyProtection(context, ref, data),

            // ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê·¸
            _buildSecurityEvents(context, ref),
          ],
        ),
        loading: () => const CircularProgressIndicator(),
        error: (e, s) => ErrorWidget(e),
      ),
    );
  }

  Widget _buildLocationProtection(
    BuildContext context,
    WidgetRef ref,
    ProtectionSettings settings,
  ) {
    return Card(
      margin: const EdgeInsets.all(8),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'ğŸ“ ìœ„ì¹˜ ë³´í˜¸',
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),

            // ìœ„ì¹˜ ë¸”ëŸ¬ ë°˜ê²½
            ListTile(
              title: const Text('ìœ„ì¹˜ ì •í™•ë„ ì¡°ì •'),
              subtitle: Text('í˜„ì¬: ${settings.locationBlurRadius}m ë²”ìœ„'),
              trailing: IconButton(
                icon: const Icon(Icons.edit),
                onPressed: () => _showBlurRadiusDialog(context, ref),
              ),
            ),

            // ì‹œê°„ëŒ€ë³„ ê³µìœ 
            SwitchListTile(
              title: const Text('ì‹œê°„ëŒ€ë³„ ìœ„ì¹˜ ê³µìœ '),
              subtitle: const Text('íŠ¹ì • ì‹œê°„ì—ë§Œ ìœ„ì¹˜ ê³µê°œ'),
              value: settings.hasLocationSchedule,
              onChanged: (value) {
                if (value) {
                  _showScheduleDialog(context, ref);
                } else {
                  ref.read(protectionSettingsProvider.notifier)
                      .clearLocationSchedule();
                }
              },
            ),

            // ìŠ¤í† í‚¹ ë°©ì§€
            ListTile(
              title: const Text('ìŠ¤í† í‚¹ ë°©ì§€ ëª¨ë“œ'),
              subtitle: const Text('ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´ ìë™ ê°ì§€'),
              trailing: const Icon(Icons.check_circle, color: Colors.green),
            ),
          ],
        ),
      ),
    );
  }
}

// ë³´ì•ˆ ì´ë²¤íŠ¸ ì•Œë¦¼
class SecurityEventNotification extends StatelessWidget {
  final SecurityEvent event;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: _getColorBySeverity(event.severity),
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(
                _getIconByType(event.type),
                color: Colors.white,
              ),
              const SizedBox(width: 8),
              Text(
                _getTitleByType(event.type),
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            event.details,
            style: const TextStyle(color: Colors.white),
          ),
          const SizedBox(height: 8),
          Text(
            'ë°œìƒ ì‹œê°: ${event.createdAt}',
            style: const TextStyle(color: Colors.white70, fontSize: 12),
          ),
        ],
      ),
    );
  }
}
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] íŒ”ë¡œìš°/ì°¨ë‹¨ í…Œì´ë¸” ìƒì„±
- [ ] RLS ì •ì±… ì ìš©
- [ ] ì½˜í…ì¸  í•„í„°ë§ ëª¨ë¸ ì¤€ë¹„
- [ ] ì¸í”Œë£¨ì–¸ì„œ ë³´í˜¸ ì„¤ì • êµ¬í˜„
- [ ] ë³´ì•ˆ ì´ë²¤íŠ¸ ëª¨ë‹ˆí„°ë§ ì„¤ì •
- [ ] ìŠ¤í† í‚¹ íŒ¨í„´ ê°ì§€ ë¡œì§ í…ŒìŠ¤íŠ¸
