# ğŸ”’ 11.5 ë©€í‹°ë¯¸ë””ì–´ ë³´ì•ˆ ê°€ì´ë“œ

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ì´ë¯¸ì§€ ì—…ë¡œë“œ ë³´ì•ˆ ê²€ì¦](#2-ì´ë¯¸ì§€-ì—…ë¡œë“œ-ë³´ì•ˆ-ê²€ì¦)
3. [EXIF ë°ì´í„° ì²˜ë¦¬ ì •ì±…](#3-exif-ë°ì´í„°-ì²˜ë¦¬-ì •ì±…)
4. [ì•…ì„± ì½”ë“œ ìŠ¤ìºë‹](#4-ì•…ì„±-ì½”ë“œ-ìŠ¤ìºë‹)
5. [ë¶€ì ì ˆí•œ ì½˜í…ì¸  í•„í„°ë§](#5-ë¶€ì ì ˆí•œ-ì½˜í…ì¸ -í•„í„°ë§)

## 1. ê°œìš”

Fallingoì˜ ì´ë¯¸ì§€ ì—…ë¡œë“œ ì‹œìŠ¤í…œì„ ì•ˆì „í•˜ê²Œ ë³´í˜¸í•˜ê³  ì‚¬ìš©ì í”„ë¼ì´ë²„ì‹œë¥¼ ì§€í‚µë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ì•…ì„± íŒŒì¼ ì°¨ë‹¨ 100%
- âœ… ê°œì¸ì •ë³´ ìë™ ì œê±°
- âœ… ë¶€ì ì ˆí•œ ì½˜í…ì¸  ì‹¤ì‹œê°„ ì°¨ë‹¨
- âœ… ì €ì¥ ìš©ëŸ‰ ìµœì í™”

## 2. ì´ë¯¸ì§€ ì—…ë¡œë“œ ë³´ì•ˆ ê²€ì¦

### [í•„ìˆ˜] í´ë¼ì´ì–¸íŠ¸ ê²€ì¦
```dart
// íŒŒì¼: lib/data/services/image_security_service.dart
class ImageSecurityService {
  // í—ˆìš© íŒŒì¼ í˜•ì‹
  static const allowedFormats = ['jpg', 'jpeg', 'png', 'webp'];
  static const maxFileSize = 10 * 1024 * 1024; // 10MB
  static const maxImageDimension = 4096; // 4K
  
  // ì´ë¯¸ì§€ ê²€ì¦
  static Future<ImageValidationResult> validateImage(File imageFile) async {
    try {
      // 1. íŒŒì¼ í¬ê¸° ê²€ì¦
      final fileSize = await imageFile.length();
      if (fileSize > maxFileSize) {
        return ImageValidationResult(
          isValid: false,
          error: 'íŒŒì¼ í¬ê¸°ëŠ” 10MBë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
        );
      }
      
      // 2. íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ ê²€ì¦ (Magic Number)
      final bytes = await imageFile.openRead(0, 12).first;
      if (!_isValidImageSignature(bytes)) {
        return ImageValidationResult(
          isValid: false,
          error: 'ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë¯¸ì§€ íŒŒì¼ì…ë‹ˆë‹¤',
        );
      }
      
      // 3. ì´ë¯¸ì§€ ë””ì½”ë”© ê²€ì¦
      final image = await decodeImageFromList(await imageFile.readAsBytes());
      if (image.width > maxImageDimension || image.height > maxImageDimension) {
        return ImageValidationResult(
          isValid: false,
          error: 'ì´ë¯¸ì§€ í¬ê¸°ëŠ” 4096x4096ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
        );
      }
      
      // 4. íŒŒì¼ëª… ê²€ì¦
      final fileName = path.basename(imageFile.path);
      if (!_isValidFileName(fileName)) {
        return ImageValidationResult(
          isValid: false,
          error: 'íŒŒì¼ëª…ì— íŠ¹ìˆ˜ë¬¸ìë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
        );
      }
      
      return ImageValidationResult(
        isValid: true,
        width: image.width,
        height: image.height,
        fileSize: fileSize,
      );
      
    } catch (e) {
      return ImageValidationResult(
        isValid: false,
        error: 'ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
      );
    }
  }
  
  // íŒŒì¼ ì‹œê·¸ë‹ˆì²˜ ê²€ì¦
  static bool _isValidImageSignature(Uint8List bytes) {
    // JPEG
    if (bytes[0] == 0xFF && bytes[1] == 0xD8 && bytes[2] == 0xFF) {
      return true;
    }
    // PNG
    if (bytes[0] == 0x89 && bytes[1] == 0x50 && bytes[2] == 0x4E && 
        bytes[3] == 0x47 && bytes[4] == 0x0D && bytes[5] == 0x0A && 
        bytes[6] == 0x1A && bytes[7] == 0x0A) {
      return true;
    }
    // WebP
    if (bytes[0] == 0x52 && bytes[1] == 0x49 && bytes[2] == 0x46 && 
        bytes[3] == 0x46 && bytes[8] == 0x57 && bytes[9] == 0x45 && 
        bytes[10] == 0x42 && bytes[11] == 0x50) {
      return true;
    }
    return false;
  }
  
  // íŒŒì¼ëª… ê²€ì¦
  static bool _isValidFileName(String fileName) {
    final validPattern = RegExp(r'^[a-zA-Z0-9_\-\.]+$');
    return validPattern.hasMatch(fileName);
  }
}
```

### [í•„ìˆ˜] ì„œë²„ ê²€ì¦
```python
# íŒŒì¼: backend/services/image_security.py
from PIL import Image
import magic
import hashlib
import re

class ImageSecurityValidator:
    ALLOWED_MIMES = {
        'image/jpeg': ['.jpg', '.jpeg'],
        'image/png': ['.png'],
        'image/webp': ['.webp']
    }
    MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
    MAX_DIMENSION = 4096
    
    @staticmethod
    async def validate_upload(file_data: bytes, filename: str) -> dict:
        """ì´ë¯¸ì§€ ì—…ë¡œë“œ ì¢…í•© ê²€ì¦"""
        try:
            # 1. íŒŒì¼ í¬ê¸° ê²€ì¦
            if len(file_data) > ImageSecurityValidator.MAX_FILE_SIZE:
                raise ValueError("íŒŒì¼ í¬ê¸° ì´ˆê³¼ (ìµœëŒ€ 10MB)")
            
            # 2. MIME íƒ€ì… ê²€ì¦ (libmagic)
            mime = magic.from_buffer(file_data, mime=True)
            if mime not in ImageSecurityValidator.ALLOWED_MIMES:
                raise ValueError(f"í—ˆìš©ë˜ì§€ ì•Šì€ íŒŒì¼ í˜•ì‹: {mime}")
            
            # 3. ì‹¤ì œ ì´ë¯¸ì§€ ê²€ì¦
            image = Image.open(io.BytesIO(file_data))
            
            # ì´ë¯¸ì§€ ëª¨ë“œ ê²€ì¦
            if image.mode not in ['RGB', 'RGBA', 'L']:
                image = image.convert('RGB')
            
            # í¬ê¸° ê²€ì¦
            if image.width > ImageSecurityValidator.MAX_DIMENSION or \
               image.height > ImageSecurityValidator.MAX_DIMENSION:
                raise ValueError("ì´ë¯¸ì§€ í¬ê¸° ì´ˆê³¼ (ìµœëŒ€ 4096x4096)")
            
            # 4. íŒŒì¼ëª… ê²€ì¦
            if not ImageSecurityValidator._validate_filename(filename):
                raise ValueError("ìœ íš¨í•˜ì§€ ì•Šì€ íŒŒì¼ëª…")
            
            # 5. ì²´í¬ì„¬ ìƒì„±
            checksum = hashlib.sha256(file_data).hexdigest()
            
            return {
                'valid': True,
                'mime_type': mime,
                'width': image.width,
                'height': image.height,
                'size': len(file_data),
                'checksum': checksum,
                'format': image.format
            }
            
        except Exception as e:
            return {
                'valid': False,
                'error': str(e)
            }
    
    @staticmethod
    def _validate_filename(filename: str) -> bool:
        """íŒŒì¼ëª… ë³´ì•ˆ ê²€ì¦"""
        # Path traversal ë°©ì§€
        if '..' in filename or '/' in filename or '\\' in filename:
            return False
        
        # íŠ¹ìˆ˜ë¬¸ì ê²€ì¦
        pattern = re.compile(r'^[a-zA-Z0-9_\-\.]+$')
        return bool(pattern.match(filename))
```

## 3. EXIF ë°ì´í„° ì²˜ë¦¬ ì •ì±…

### [í•„ìˆ˜] EXIF ë°ì´í„° ì œê±°
```dart
// íŒŒì¼: lib/data/services/exif_removal_service.dart
import 'package:exif/exif.dart';
import 'package:image/image.dart' as img;

class ExifRemovalService {
  // ë¯¼ê°í•œ EXIF íƒœê·¸
  static const sensitiveExifTags = [
    'GPS Latitude',
    'GPS Longitude',
    'GPS Altitude',
    'GPS Date/Time',
    'Camera Serial Number',
    'Lens Serial Number',
    'Owner Name',
    'Copyright',
    'Artist',
    'Software',
  ];
  
  // EXIF ë°ì´í„° ì •ë¦¬
  static Future<Uint8List> removeExifData(
    Uint8List imageBytes, {
    bool preserveOrientation = true,
  }) async {
    try {
      // 1. í˜„ì¬ EXIF ë°ì´í„° ì½ê¸°
      final exifData = await readExifFromBytes(imageBytes);
      
      // 2. ë°©í–¥ ì •ë³´ ë³´ì¡´ (í•„ìš”ì‹œ)
      int? orientation;
      if (preserveOrientation && exifData.containsKey('Orientation')) {
        orientation = exifData['Orientation']?.values.firstAsInt();
      }
      
      // 3. ì´ë¯¸ì§€ ë””ì½”ë”©
      final image = img.decodeImage(imageBytes);
      if (image == null) throw Exception('ì´ë¯¸ì§€ ë””ì½”ë”© ì‹¤íŒ¨');
      
      // 4. ë°©í–¥ ë³´ì •
      if (orientation != null && orientation != 1) {
        _applyOrientation(image, orientation);
      }
      
      // 5. EXIF ì—†ì´ ì¬ì¸ì½”ë”©
      final cleanImage = img.encodeJpg(image, quality: 90);
      
      // 6. ë¡œê¹… (ê°œë°œ í™˜ê²½ì—ì„œë§Œ)
      if (kDebugMode) {
        _logRemovedExif(exifData);
      }
      
      return Uint8List.fromList(cleanImage);
      
    } catch (e) {
      print('EXIF ì œê±° ì˜¤ë¥˜: $e');
      // ì˜¤ë¥˜ ì‹œ ì›ë³¸ ë°˜í™˜ (ë³´ì•ˆìƒ ìœ„í—˜í•˜ë¯€ë¡œ ì£¼ì˜)
      return imageBytes;
    }
  }
  
  // ì„ íƒì  EXIF ë³´ì¡´
  static Future<Uint8List> sanitizeExifData(
    Uint8List imageBytes, {
    List<String> preserveTags = const ['Make', 'Model', 'DateTime'],
  }) async {
    try {
      final exifData = await readExifFromBytes(imageBytes);
      final image = img.decodeImage(imageBytes)!;
      
      // ë³´ì¡´í•  ë°ì´í„°ë§Œ ì¶”ì¶œ
      final sanitizedExif = <String, dynamic>{};
      for (final tag in preserveTags) {
        if (exifData.containsKey(tag) && !sensitiveExifTags.contains(tag)) {
          sanitizedExif[tag] = exifData[tag]?.values.first;
        }
      }
      
      // ìƒˆ ì´ë¯¸ì§€ ìƒì„± (êµ¬í˜„ í•„ìš”)
      // í˜„ì¬ëŠ” ëª¨ë“  EXIF ì œê±° í›„ ë°˜í™˜
      return Uint8List.fromList(img.encodeJpg(image, quality: 90));
      
    } catch (e) {
      return imageBytes;
    }
  }
  
  // ê°œì¸ì •ë³´ ê°ì§€
  static Future<PrivacyCheckResult> checkPrivacyRisk(
    Map<String, IfdTag> exifData,
  ) async {
    final risks = <PrivacyRisk>[];
    
    // GPS ì •ë³´ í™•ì¸
    if (exifData.containsKey('GPS Latitude') || 
        exifData.containsKey('GPS Longitude')) {
      risks.add(PrivacyRisk(
        type: 'location',
        severity: 'high',
        description: 'ì •í™•í•œ ìœ„ì¹˜ ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤',
      ));
    }
    
    // ê°œì¸ ì‹ë³„ ì •ë³´ í™•ì¸
    for (final tag in ['Owner Name', 'Artist', 'Copyright']) {
      if (exifData.containsKey(tag)) {
        final value = exifData[tag]?.values.first.toString() ?? '';
        if (value.isNotEmpty) {
          risks.add(PrivacyRisk(
            type: 'personal_info',
            severity: 'medium',
            description: '$tag ì •ë³´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤',
          ));
        }
      }
    }
    
    // ê¸°ê¸° ì •ë³´ í™•ì¸
    if (exifData.containsKey('Camera Serial Number')) {
      risks.add(PrivacyRisk(
        type: 'device_id',
        severity: 'low',
        description: 'ì¹´ë©”ë¼ ì¼ë ¨ë²ˆí˜¸ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤',
      ));
    }
    
    return PrivacyCheckResult(
      hasRisks: risks.isNotEmpty,
      risks: risks,
      recommendation: risks.isEmpty 
          ? 'ê°œì¸ì •ë³´ ìœ„í—˜ì´ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'
          : 'EXIF ë°ì´í„° ì œê±°ë¥¼ ê¶Œì¥í•©ë‹ˆë‹¤',
    );
  }
}
```

### [í•„ìˆ˜] ìœ„ì¹˜ ì •ë³´ ë‚œë…í™”
```dart
// íŒŒì¼: lib/data/services/location_obfuscation_service.dart
class LocationObfuscationService {
  // ìœ„ì¹˜ ì •ë³´ ë‚œë…í™” ë ˆë²¨
  static const obfuscationLevels = {
    'none': 0,      // ì›ë³¸ ìœ ì§€
    'building': 3,  // ê±´ë¬¼ ë‹¨ìœ„ (ì•½ 10m)
    'block': 4,     // ë¸”ë¡ ë‹¨ìœ„ (ì•½ 100m)
    'district': 5,  // êµ¬ì—­ ë‹¨ìœ„ (ì•½ 1km)
  };
  
  // GPS ì¢Œí‘œ ë‚œë…í™”
  static LatLng obfuscateLocation(
    LatLng original, {
    String level = 'building',
  }) {
    final precision = obfuscationLevels[level] ?? 3;
    
    // ì†Œìˆ˜ì  ìë¦¬ìˆ˜ ì œí•œ
    final lat = _roundToPrecision(original.latitude, precision);
    final lng = _roundToPrecision(original.longitude, precision);
    
    // ëœë¤ ë…¸ì´ì¦ˆ ì¶”ê°€ (ì„ íƒì )
    final noise = _generateNoise(precision);
    
    return LatLng(
      lat + noise.latitude,
      lng + noise.longitude,
    );
  }
  
  static double _roundToPrecision(double value, int precision) {
    final multiplier = pow(10, precision);
    return (value * multiplier).round() / multiplier;
  }
  
  static LatLng _generateNoise(int precision) {
    final random = Random();
    final maxNoise = pow(10, -precision) / 2;
    
    return LatLng(
      (random.nextDouble() - 0.5) * maxNoise,
      (random.nextDouble() - 0.5) * maxNoise,
    );
  }
}
```

## 4. ì•…ì„± ì½”ë“œ ìŠ¤ìºë‹

### [í•„ìˆ˜] ì•…ì„± ì½”ë“œ ê²€ì‚¬
```python
# íŒŒì¼: backend/services/malware_scanner.py
import yara
import tempfile
import subprocess
from typing import Optional

class MalwareScanner:
    def __init__(self):
        # YARA ê·œì¹™ ë¡œë“œ
        self.rules = self._load_yara_rules()
        
    def _load_yara_rules(self):
        """ì•…ì„± ì½”ë“œ íƒì§€ ê·œì¹™ ë¡œë“œ"""
        rules_content = '''
        rule ImageMalwareGeneric {
            meta:
                description = "Generic image-based malware"
            strings:
                $php = "<?php"
                $asp = "<%@ "
                $jsp = "<%@ page"
                $script = "<script"
                $iframe = "<iframe"
                $eval = "eval("
                $base64 = "base64_decode"
            condition:
                any of them
        }
        
        rule PolyglotFile {
            meta:
                description = "Polyglot file detection"
            strings:
                $jpg_header = { FF D8 FF }
                $png_header = { 89 50 4E 47 }
                $pdf_magic = "%PDF"
                $zip_magic = "PK"
            condition:
                #jpg_header > 1 or #png_header > 1 or
                ($jpg_header and $pdf_magic) or
                ($png_header and $zip_magic)
        }
        '''
        return yara.compile(source=rules_content)
    
    async def scan_file(self, file_data: bytes) -> dict:
        """íŒŒì¼ ì•…ì„± ì½”ë“œ ìŠ¤ìº”"""
        try:
            # 1. YARA ìŠ¤ìº”
            yara_matches = self.rules.match(data=file_data)
            if yara_matches:
                return {
                    'safe': False,
                    'threat': 'malware_detected',
                    'details': [match.rule for match in yara_matches]
                }
            
            # 2. íŒŒì¼ êµ¬ì¡° ê²€ì¦
            structure_check = await self._check_file_structure(file_data)
            if not structure_check['valid']:
                return {
                    'safe': False,
                    'threat': 'invalid_structure',
                    'details': structure_check['errors']
                }
            
            # 3. ì—”íŠ¸ë¡œí”¼ ë¶„ì„ (ì•”í˜¸í™”ëœ í˜ì´ë¡œë“œ íƒì§€)
            entropy = self._calculate_entropy(file_data)
            if entropy > 7.5:  # ë†’ì€ ì—”íŠ¸ë¡œí”¼ëŠ” ì˜ì‹¬ìŠ¤ëŸ¬ì›€
                return {
                    'safe': False,
                    'threat': 'high_entropy',
                    'details': f'Entropy: {entropy:.2f}'
                }
            
            # 4. ClamAV ìŠ¤ìº” (ì„¤ì¹˜ëœ ê²½ìš°)
            if self._has_clamav():
                clamav_result = await self._scan_with_clamav(file_data)
                if not clamav_result['safe']:
                    return clamav_result
            
            return {
                'safe': True,
                'threat': None,
                'scan_time': datetime.now().isoformat()
            }
            
        except Exception as e:
            return {
                'safe': False,
                'threat': 'scan_error',
                'details': str(e)
            }
    
    async def _check_file_structure(self, file_data: bytes) -> dict:
        """íŒŒì¼ êµ¬ì¡° ë¬´ê²°ì„± ê²€ì¦"""
        errors = []
        
        # JPEG ê²€ì¦
        if file_data[:3] == b'\xff\xd8\xff':
            if not file_data.endswith(b'\xff\xd9'):
                errors.append('Invalid JPEG ending')
            
            # JPEG ì„¸ê·¸ë¨¼íŠ¸ ê²€ì¦
            if b'<?php' in file_data or b'<%' in file_data:
                errors.append('Suspicious code in JPEG')
        
        # PNG ê²€ì¦
        elif file_data[:8] == b'\x89PNG\r\n\x1a\n':
            # PNG ì²­í¬ ê²€ì¦
            if not self._validate_png_chunks(file_data):
                errors.append('Invalid PNG chunk structure')
        
        return {
            'valid': len(errors) == 0,
            'errors': errors
        }
    
    def _calculate_entropy(self, data: bytes) -> float:
        """íŒŒì¼ ì—”íŠ¸ë¡œí”¼ ê³„ì‚°"""
        if not data:
            return 0
        
        entropy = 0
        for i in range(256):
            p_i = data.count(i) / len(data)
            if p_i > 0:
                entropy -= p_i * math.log2(p_i)
        
        return entropy
```

### [í•„ìˆ˜] ì‹¤ì‹œê°„ ìœ„í˜‘ ì°¨ë‹¨
```dart
// íŒŒì¼: lib/data/services/realtime_threat_blocker.dart
class RealtimeThreatBlocker {
  static final _blacklistPatterns = [
    RegExp(r'<\?php', caseSensitive: false),
    RegExp(r'<%\s*@', caseSensitive: false),
    RegExp(r'<script', caseSensitive: false),
    RegExp(r'javascript:', caseSensitive: false),
    RegExp(r'onerror\s*=', caseSensitive: false),
  ];
  
  // ë¹ ë¥¸ ìœ„í˜‘ ìŠ¤ìº”
  static Future<ThreatScanResult> quickScan(Uint8List fileData) async {
    // 1. íŒŒì¼ í—¤ë” ê²€ì¦
    if (!_hasValidImageHeader(fileData)) {
      return ThreatScanResult(
        isSafe: false,
        threatType: 'invalid_header',
        action: 'block',
      );
    }
    
    // 2. ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´ ê²€ìƒ‰
    final fileString = String.fromCharCodes(fileData.take(1024));
    for (final pattern in _blacklistPatterns) {
      if (pattern.hasMatch(fileString)) {
        return ThreatScanResult(
          isSafe: false,
          threatType: 'malicious_pattern',
          action: 'block',
          details: pattern.pattern,
        );
      }
    }
    
    // 3. íŒŒì¼ í¬ê¸° ì´ìƒ íƒì§€
    if (_hasAnomalousSize(fileData)) {
      return ThreatScanResult(
        isSafe: false,
        threatType: 'size_anomaly',
        action: 'quarantine',
      );
    }
    
    return ThreatScanResult(isSafe: true);
  }
  
  static bool _hasValidImageHeader(Uint8List data) {
    if (data.length < 12) return false;
    
    // JPEG
    if (data[0] == 0xFF && data[1] == 0xD8) return true;
    // PNG
    if (data[0] == 0x89 && data[1] == 0x50) return true;
    // WebP
    if (data[0] == 0x52 && data[1] == 0x49) return true;
    
    return false;
  }
}
```

## 5. ë¶€ì ì ˆí•œ ì½˜í…ì¸  í•„í„°ë§

### [í•„ìˆ˜] AI ê¸°ë°˜ ì½˜í…ì¸  ëª¨ë”ë ˆì´ì…˜
```dart
// íŒŒì¼: lib/data/services/content_moderation_service.dart
class ContentModerationService {
  static const _moderationEndpoint = '/api/moderation/check';
  
  // Cloud Vision API Safe Search
  static Future<ModerationResult> moderateImage(
    Uint8List imageBytes,
  ) async {
    try {
      // 1. Google Cloud Vision API í˜¸ì¶œ
      final visionResponse = await _callVisionAPI(imageBytes);
      
      // 2. ì•ˆì „ ê²€ìƒ‰ ê²°ê³¼ ë¶„ì„
      final safeSearch = visionResponse['safeSearchAnnotation'];
      
      final result = ModerationResult(
        adult: _convertLikelihood(safeSearch['adult']),
        violence: _convertLikelihood(safeSearch['violence']),
        medical: _convertLikelihood(safeSearch['medical']),
        spoof: _convertLikelihood(safeSearch['spoof']),
        racy: _convertLikelihood(safeSearch['racy']),
      );
      
      // 3. ì •ì±… ì ìš©
      if (result.shouldBlock()) {
        return result.copyWith(
          action: 'block',
          reason: result.getBlockReason(),
        );
      }
      
      if (result.shouldReview()) {
        return result.copyWith(
          action: 'review',
          reason: 'ìˆ˜ë™ ê²€í† ê°€ í•„ìš”í•©ë‹ˆë‹¤',
        );
      }
      
      return result.copyWith(action: 'allow');
      
    } catch (e) {
      // ì˜¤ë¥˜ ì‹œ ì•ˆì „í•œ ê¸°ë³¸ê°’
      return ModerationResult(
        action: 'review',
        reason: 'ìë™ ê²€ì‚¬ ì‹¤íŒ¨',
      );
    }
  }
  
  // ê°€ëŠ¥ì„± ìˆ˜ì¤€ ë³€í™˜
  static double _convertLikelihood(String? likelihood) {
    switch (likelihood) {
      case 'VERY_UNLIKELY': return 0.0;
      case 'UNLIKELY': return 0.25;
      case 'POSSIBLE': return 0.5;
      case 'LIKELY': return 0.75;
      case 'VERY_LIKELY': return 1.0;
      default: return 0.0;
    }
  }
}

// ëª¨ë”ë ˆì´ì…˜ ì •ì±…
class ModerationPolicy {
  // ì°¨ë‹¨ ì„ê³„ê°’
  static const blockThresholds = {
    'adult': 0.75,      // LIKELY ì´ìƒ
    'violence': 0.75,   // LIKELY ì´ìƒ
    'medical': 1.0,     // VERY_LIKELYë§Œ
    'spoof': 0.5,       // POSSIBLE ì´ìƒ
    'racy': 0.75,       // LIKELY ì´ìƒ
  };
  
  // ê²€í†  ì„ê³„ê°’
  static const reviewThresholds = {
    'adult': 0.5,       // POSSIBLE ì´ìƒ
    'violence': 0.5,    // POSSIBLE ì´ìƒ
    'medical': 0.75,    // LIKELY ì´ìƒ
    'spoof': 0.25,      // UNLIKELY ì´ìƒ
    'racy': 0.5,        // POSSIBLE ì´ìƒ
  };
}
```

### [í•„ìˆ˜] ì‚¬ìš©ì ì‹ ê³  ì‹œìŠ¤í…œ
```dart
// íŒŒì¼: lib/features/report/data/services/content_report_service.dart
class ContentReportService {
  // ì‹ ê³  ìœ í˜•
  static const reportTypes = {
    'inappropriate': 'ë¶€ì ì ˆí•œ ì½˜í…ì¸ ',
    'spam': 'ìŠ¤íŒ¸/ê´‘ê³ ',
    'fake': 'í—ˆìœ„ ì •ë³´',
    'copyright': 'ì €ì‘ê¶Œ ì¹¨í•´',
    'privacy': 'ê°œì¸ì •ë³´ ë…¸ì¶œ',
    'other': 'ê¸°íƒ€',
  };
  
  // ì½˜í…ì¸  ì‹ ê³ 
  static Future<void> reportContent({
    required String contentId,
    required String contentType,
    required String reportType,
    String? description,
    List<String>? evidenceUrls,
  }) async {
    try {
      // 1. ì‹ ê³  ë°ì´í„° ìƒì„±
      final report = ContentReport(
        id: const Uuid().v4(),
        contentId: contentId,
        contentType: contentType,
        reportType: reportType,
        description: description,
        evidenceUrls: evidenceUrls,
        reporterId: Supabase.instance.client.auth.currentUser!.id,
        reportedAt: DateTime.now(),
        status: 'pending',
      );
      
      // 2. ì‹ ê³  ì €ì¥
      await Supabase.instance.client
          .from('content_reports')
          .insert(report.toJson());
      
      // 3. ìë™ ì¡°ì¹˜ (ì„ê³„ê°’ ë„ë‹¬ ì‹œ)
      await _checkAutoModeration(contentId, contentType);
      
      // 4. ê´€ë¦¬ì ì•Œë¦¼
      if (_isUrgentReport(reportType)) {
        await _notifyModerators(report);
      }
      
    } catch (e) {
      throw ContentReportException('ì‹ ê³  ì²˜ë¦¬ ì‹¤íŒ¨: $e');
    }
  }
  
  // ìë™ ì¡°ì¹˜ í™•ì¸
  static Future<void> _checkAutoModeration(
    String contentId,
    String contentType,
  ) async {
    // ì‹ ê³  íšŸìˆ˜ ì¡°íšŒ
    final response = await Supabase.instance.client
        .from('content_reports')
        .select('count')
        .eq('content_id', contentId)
        .eq('status', 'pending');
    
    final reportCount = response.data?['count'] ?? 0;
    
    // ì„ê³„ê°’ ë„ë‹¬ ì‹œ ìë™ ìˆ¨ê¹€
    if (reportCount >= 3) {
      await _hideContent(contentId, contentType);
    }
  }
}
```

### [ì„ íƒ] í•´ì‹œ ê¸°ë°˜ ì°¨ë‹¨ ëª©ë¡
```python
# íŒŒì¼: backend/services/content_blocklist.py
import hashlib
from typing import Set

class ContentBlocklist:
    def __init__(self):
        self.blocked_hashes: Set[str] = set()
        self._load_blocklist()
    
    def _load_blocklist(self):
        """ì°¨ë‹¨ í•´ì‹œ ëª©ë¡ ë¡œë“œ"""
        # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì°¨ë‹¨ëœ ì´ë¯¸ì§€ í•´ì‹œ ë¡œë“œ
        blocked = supabase.table('blocked_content_hashes').select('*').execute()
        self.blocked_hashes = {item['hash'] for item in blocked.data}
    
    def check_image(self, image_data: bytes) -> bool:
        """ì´ë¯¸ì§€ ì°¨ë‹¨ ì—¬ë¶€ í™•ì¸"""
        # ì—¬ëŸ¬ í•´ì‹œ ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
        hashes = {
            'md5': hashlib.md5(image_data).hexdigest(),
            'sha1': hashlib.sha1(image_data).hexdigest(),
            'sha256': hashlib.sha256(image_data).hexdigest(),
        }
        
        # perceptual hash (ì´ë¯¸ì§€ ìœ ì‚¬ë„)
        phash = self._calculate_phash(image_data)
        
        # ì°¨ë‹¨ ëª©ë¡ í™•ì¸
        for hash_value in hashes.values():
            if hash_value in self.blocked_hashes:
                return True
        
        # ìœ ì‚¬ ì´ë¯¸ì§€ í™•ì¸
        if self._check_similar_blocked(phash):
            return True
        
        return False
    
    def add_to_blocklist(self, image_data: bytes, reason: str):
        """ì°¨ë‹¨ ëª©ë¡ì— ì¶”ê°€"""
        hashes = {
            'md5': hashlib.md5(image_data).hexdigest(),
            'sha256': hashlib.sha256(image_data).hexdigest(),
            'phash': self._calculate_phash(image_data),
        }
        
        supabase.table('blocked_content_hashes').insert({
            'hashes': hashes,
            'reason': reason,
            'blocked_at': datetime.now().isoformat()
        }).execute()
        
        # ë©”ëª¨ë¦¬ ìºì‹œ ì—…ë°ì´íŠ¸
        self.blocked_hashes.update(hashes.values())
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì´ë¯¸ì§€ ê²€ì¦ ë¡œì§ êµ¬í˜„
- [ ] EXIF ì œê±° ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
- [ ] ì•…ì„± ì½”ë“œ ìŠ¤ìºë„ˆ ì„¤ì •
- [ ] Cloud Vision API ì—°ë™