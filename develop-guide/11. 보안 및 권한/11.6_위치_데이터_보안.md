# ğŸ” 11.6 ìœ„ì¹˜ ë°ì´í„° ë³´ì•ˆ

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ì‹¤ì‹œê°„ ìœ„ì¹˜ ì•”í˜¸í™”](#2-ì‹¤ì‹œê°„-ìœ„ì¹˜-ì•”í˜¸í™”)
3. [ìœ„ì¹˜ ì •ë³´ ìµëª…í™”](#3-ìœ„ì¹˜-ì •ë³´-ìµëª…í™”)
4. [ì ‘ê·¼ ê¶Œí•œ ì„¸ë¶„í™”](#4-ì ‘ê·¼-ê¶Œí•œ-ì„¸ë¶„í™”)
5. [ê°ì‚¬ ë¡œê·¸ ê´€ë¦¬](#5-ê°ì‚¬-ë¡œê·¸-ê´€ë¦¬)

## 1. ê°œìš”

Fallingoì˜ í•µì‹¬ ê¸°ëŠ¥ì¸ ìœ„ì¹˜ ê¸°ë°˜ ì„œë¹„ìŠ¤ë¥¼ ì•ˆì „í•˜ê²Œ ìš´ì˜í•˜ê¸° ìœ„í•œ ë³´ì•ˆ ì „ëµì„ ì •ì˜í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ì—”ë“œíˆ¬ì—”ë“œ ìœ„ì¹˜ ë°ì´í„° ì•”í˜¸í™”
- âœ… ê°œì¸ì •ë³´ë³´í˜¸ë¥¼ ìœ„í•œ ìœ„ì¹˜ ìµëª…í™”
- âœ… ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´(RBAC)
- âœ… ëª¨ë“  ìœ„ì¹˜ ë°ì´í„° ì ‘ê·¼ ê¸°ë¡ ì¶”ì 

## 2. ì‹¤ì‹œê°„ ìœ„ì¹˜ ì•”í˜¸í™”

### [í•„ìˆ˜] í´ë¼ì´ì–¸íŠ¸ ì¸¡ ì•”í˜¸í™”
```dart
// íŒŒì¼: lib/core/security/location_encryption.dart
import 'dart:convert';
import 'package:crypto/crypto.dart';
import 'package:encrypt/encrypt.dart';

class LocationEncryption {
  static final _key = Key.fromBase64(
    String.fromEnvironment('LOCATION_ENCRYPTION_KEY')
  );
  static final _iv = IV.fromSecureRandom(16);
  static final _encrypter = Encrypter(AES(_key));
  
  // ìœ„ì¹˜ ë°ì´í„° ì•”í˜¸í™”
  static Map<String, dynamic> encryptLocation({
    required double latitude,
    required double longitude,
    required DateTime timestamp,
  }) {
    // ìœ„ì¹˜ ë°ì´í„°ë¥¼ JSONìœ¼ë¡œ ë³€í™˜
    final locationData = {
      'lat': latitude,
      'lng': longitude,
      'ts': timestamp.millisecondsSinceEpoch,
      'accuracy': _addNoise(latitude, longitude),
    };
    
    // ì•”í˜¸í™”
    final encrypted = _encrypter.encrypt(
      jsonEncode(locationData),
      iv: _iv,
    );
    
    // ì„œëª… ìƒì„±
    final signature = _generateSignature(locationData);
    
    return {
      'data': encrypted.base64,
      'iv': _iv.base64,
      'signature': signature,
      'version': '1.0',
    };
  }
  
  // ìœ„ì¹˜ ë…¸ì´ì¦ˆ ì¶”ê°€ (í”„ë¼ì´ë²„ì‹œ ë³´í˜¸)
  static double _addNoise(double lat, double lng) {
    // ì•½ 10-50m ë²”ìœ„ì˜ ë…¸ì´ì¦ˆ ì¶”ê°€
    final random = Random.secure();
    final noise = 0.0001 + (random.nextDouble() * 0.0004);
    return noise;
  }
  
  // HMAC ì„œëª… ìƒì„±
  static String _generateSignature(Map<String, dynamic> data) {
    final key = utf8.encode(
      String.fromEnvironment('LOCATION_HMAC_KEY')
    );
    final bytes = utf8.encode(jsonEncode(data));
    final hmac = Hmac(sha256, key);
    final digest = hmac.convert(bytes);
    return digest.toString();
  }
}
```

### [í•„ìˆ˜] ì„œë²„ ì¸¡ ë³µí˜¸í™” ë° ê²€ì¦
```python
# íŒŒì¼: backend/core/security/location_decryption.py
import os
import json
import hmac
import hashlib
from base64 import b64decode
from datetime import datetime
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

class LocationDecryption:
    def __init__(self):
        self.key = b64decode(os.environ['LOCATION_ENCRYPTION_KEY'])
        self.hmac_key = os.environ['LOCATION_HMAC_KEY'].encode()
    
    def decrypt_location(self, encrypted_data: dict) -> dict:
        """ì•”í˜¸í™”ëœ ìœ„ì¹˜ ë°ì´í„° ë³µí˜¸í™” ë° ê²€ì¦"""
        try:
            # ë²„ì „ í™•ì¸
            if encrypted_data.get('version') != '1.0':
                raise ValueError("Unsupported encryption version")
            
            # ë³µí˜¸í™”
            iv = b64decode(encrypted_data['iv'])
            cipher = AES.new(self.key, AES.MODE_CBC, iv)
            decrypted = unpad(
                cipher.decrypt(b64decode(encrypted_data['data'])),
                AES.block_size
            )
            
            # JSON íŒŒì‹±
            location_data = json.loads(decrypted.decode())
            
            # ì„œëª… ê²€ì¦
            if not self._verify_signature(location_data, encrypted_data['signature']):
                raise ValueError("Invalid signature")
            
            # íƒ€ì„ìŠ¤íƒ¬í”„ ê²€ì¦ (5ë¶„ ì´ë‚´)
            timestamp = datetime.fromtimestamp(location_data['ts'] / 1000)
            if (datetime.utcnow() - timestamp).seconds > 300:
                raise ValueError("Location data expired")
            
            return {
                'latitude': location_data['lat'],
                'longitude': location_data['lng'],
                'timestamp': timestamp,
                'accuracy': location_data.get('accuracy', 0.0005)
            }
            
        except Exception as e:
            # ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§
            self._log_decryption_failure(str(e))
            raise
    
    def _verify_signature(self, data: dict, signature: str) -> bool:
        """HMAC ì„œëª… ê²€ì¦"""
        expected = hmac.new(
            self.hmac_key,
            json.dumps(data, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        return hmac.compare_digest(expected, signature)
```

### [í•„ìˆ˜] ì „ì†¡ ì¤‘ ë³´ì•ˆ
```dart
// íŒŒì¼: lib/core/security/secure_api_client.dart
class SecureApiClient {
  static final _dio = Dio()
    ..interceptors.addAll([
      CertificatePinningInterceptor(),
      EncryptionInterceptor(),
    ]);
  
  // ìœ„ì¹˜ ë°ì´í„° ì „ì†¡
  static Future<void> sendLocation(Map<String, dynamic> encryptedLocation) async {
    try {
      await _dio.post(
        '${Environment.apiBaseUrl}/location/update',
        data: encryptedLocation,
        options: Options(
          headers: {
            'X-Location-Version': '1.0',
            'X-Request-ID': const Uuid().v4(),
          },
        ),
      );
    } catch (e) {
      // ì¬ì‹œë„ ë¡œì§
      if (e is DioError && e.response?.statusCode == 401) {
        await _refreshTokenAndRetry();
      }
    }
  }
}

// ì¸ì¦ì„œ ê³ ì •(Certificate Pinning)
class CertificatePinningInterceptor extends Interceptor {
  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) {
    // ìš´ì˜ í™˜ê²½ì—ì„œë§Œ ì ìš©
    if (Environment.isProduction) {
      options.extra['certificatePins'] = [
        'sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',
      ];
    }
    handler.next(options);
  }
}
```

## 3. ìœ„ì¹˜ ì •ë³´ ìµëª…í™”

### [í•„ìˆ˜] ìœ„ì¹˜ ê·¸ë¦¬ë“œ ì‹œìŠ¤í…œ
```python
# íŒŒì¼: backend/core/privacy/location_anonymizer.py
import hashlib
from typing import Tuple, List
from dataclasses import dataclass

@dataclass
class GridCell:
    """ìœ„ì¹˜ ê·¸ë¦¬ë“œ ì…€"""
    x: int
    y: int
    level: int  # 0: 1km, 1: 100m, 2: 10m
    
class LocationAnonymizer:
    """ìœ„ì¹˜ ì •ë³´ ìµëª…í™” ì²˜ë¦¬"""
    
    # ê·¸ë¦¬ë“œ ë ˆë²¨ë³„ ì •ë°€ë„ (ë¯¸í„°)
    GRID_PRECISION = {
        0: 1000,   # ê³µê°œ ë°ì´í„°ìš©
        1: 100,    # ì¼ë°˜ ì‚¬ìš©ììš©
        2: 10,     # ì¸ì¦ëœ ì‚¬ìš©ììš©
        3: 1,      # ì›ë³¸ (ì €ì¥í•˜ì§€ ì•ŠìŒ)
    }
    
    @staticmethod
    def anonymize_location(
        latitude: float,
        longitude: float,
        privacy_level: int = 1
    ) -> Tuple[float, float]:
        """ìœ„ì¹˜ë¥¼ í”„ë¼ì´ë²„ì‹œ ë ˆë²¨ì— ë”°ë¼ ìµëª…í™”"""
        
        # ê·¸ë¦¬ë“œ ì…€ ê³„ì‚°
        grid_cell = LocationAnonymizer._get_grid_cell(
            latitude, longitude, privacy_level
        )
        
        # ì…€ ì¤‘ì‹¬ì  ë°˜í™˜
        return LocationAnonymizer._get_cell_center(grid_cell)
    
    @staticmethod
    def _get_grid_cell(lat: float, lng: float, level: int) -> GridCell:
        """ì¢Œí‘œë¥¼ ê·¸ë¦¬ë“œ ì…€ë¡œ ë³€í™˜"""
        precision = LocationAnonymizer.GRID_PRECISION[level]
        
        # ë¯¸í„° ë‹¨ìœ„ë¥¼ ë„(degree) ë‹¨ìœ„ë¡œ ë³€í™˜
        lat_precision = precision / 111111  # 1ë„ â‰ˆ 111km
        lng_precision = precision / (111111 * abs(cos(radians(lat))))
        
        x = int(lat / lat_precision)
        y = int(lng / lng_precision)
        
        return GridCell(x=x, y=y, level=level)
    
    @staticmethod
    def create_location_hash(lat: float, lng: float, user_id: str) -> str:
        """ì¶”ì  ë¶ˆê°€ëŠ¥í•œ ìœ„ì¹˜ í•´ì‹œ ìƒì„±"""
        # ì¼ì¼ saltë¡œ ê°™ì€ ìœ„ì¹˜ë„ ë§¤ì¼ ë‹¤ë¥¸ í•´ì‹œ ìƒì„±
        daily_salt = datetime.utcnow().strftime('%Y%m%d')
        
        data = f"{lat:.6f},{lng:.6f},{user_id},{daily_salt}"
        return hashlib.sha256(data.encode()).hexdigest()[:16]
```

### [í•„ìˆ˜] K-ìµëª…ì„± ë³´ì¥
```python
# íŒŒì¼: backend/core/privacy/k_anonymity.py
class KAnonymityManager:
    """K-ìµëª…ì„± ë³´ì¥ì„ ìœ„í•œ ê´€ë¦¬ì"""
    
    MIN_K_VALUE = 5  # ìµœì†Œ 5ëª… ì´ìƒì¼ ë•Œë§Œ ê³µê°œ
    
    @staticmethod
    async def get_anonymized_locations(
        supabase,
        grid_cell: GridCell,
        time_window: int = 3600  # 1ì‹œê°„
    ) -> List[dict]:
        """K-ìµëª…ì„±ì´ ë³´ì¥ëœ ìœ„ì¹˜ ë°ì´í„°ë§Œ ë°˜í™˜"""
        
        # ê·¸ë¦¬ë“œ ì…€ ë‚´ ì‚¬ìš©ì ìˆ˜ í™•ì¸
        result = await supabase.rpc(
            'count_users_in_grid',
            {
                'grid_x': grid_cell.x,
                'grid_y': grid_cell.y,
                'grid_level': grid_cell.level,
                'time_window': time_window
            }
        ).execute()
        
        user_count = result.data[0]['count']
        
        # K-ìµëª…ì„± ë¯¸ì¶©ì¡± ì‹œ ìƒìœ„ ë ˆë²¨ë¡œ í™•ëŒ€
        if user_count < KAnonymityManager.MIN_K_VALUE:
            if grid_cell.level > 0:
                # ë” í° ê·¸ë¦¬ë“œë¡œ ì¬ì‹œë„
                grid_cell.level -= 1
                return await KAnonymityManager.get_anonymized_locations(
                    supabase, grid_cell, time_window
                )
            else:
                # ìµœìƒìœ„ ë ˆë²¨ì—ì„œë„ ë¯¸ì¶©ì¡± ì‹œ ë¹ˆ ê²°ê³¼
                return []
        
        # K-ìµëª…ì„± ì¶©ì¡± ì‹œ ìµëª…í™”ëœ ë°ì´í„° ë°˜í™˜
        locations = await supabase.table('anonymous_locations')\
            .select('*')\
            .eq('grid_x', grid_cell.x)\
            .eq('grid_y', grid_cell.y)\
            .eq('grid_level', grid_cell.level)\
            .gte('timestamp', datetime.utcnow() - timedelta(seconds=time_window))\
            .execute()
        
        return locations.data
```

### [ì„ íƒ] ì°¨ë¶„ í”„ë¼ì´ë²„ì‹œ
```python
# íŒŒì¼: backend/core/privacy/differential_privacy.py
import numpy as np

class DifferentialPrivacy:
    """ì°¨ë¶„ í”„ë¼ì´ë²„ì‹œ ì ìš©"""
    
    @staticmethod
    def add_laplace_noise(
        value: float,
        sensitivity: float = 0.001,
        epsilon: float = 1.0
    ) -> float:
        """ë¼í”Œë¼ìŠ¤ ë…¸ì´ì¦ˆ ì¶”ê°€"""
        scale = sensitivity / epsilon
        noise = np.random.laplace(0, scale)
        return value + noise
    
    @staticmethod
    def anonymize_coordinates(lat: float, lng: float) -> Tuple[float, float]:
        """ì¢Œí‘œì— ì°¨ë¶„ í”„ë¼ì´ë²„ì‹œ ì ìš©"""
        # ì•½ 100m ë²”ìœ„ì˜ ë…¸ì´ì¦ˆ
        noisy_lat = DifferentialPrivacy.add_laplace_noise(lat)
        noisy_lng = DifferentialPrivacy.add_laplace_noise(lng)
        
        # ì†Œìˆ˜ì  4ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼ (ì•½ 11m ì •ë°€ë„)
        return round(noisy_lat, 4), round(noisy_lng, 4)
```

## 4. ì ‘ê·¼ ê¶Œí•œ ì„¸ë¶„í™”

### [í•„ìˆ˜] ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
```sql
-- íŒŒì¼: backend/migrations/location_rbac.sql

-- ìœ„ì¹˜ ì ‘ê·¼ ê¶Œí•œ í…Œì´ë¸”
CREATE TABLE location_permissions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id),
    role VARCHAR(50) NOT NULL,
    permission_type VARCHAR(50) NOT NULL,
    granted_at TIMESTAMP DEFAULT NOW(),
    granted_by UUID REFERENCES users(id),
    expires_at TIMESTAMP,
    
    UNIQUE(user_id, role, permission_type)
);

-- ì—­í•  ì •ì˜
CREATE TYPE location_role AS ENUM (
    'viewer',        -- ìµëª…í™”ëœ ìœ„ì¹˜ë§Œ ì¡°íšŒ
    'member',        -- ìì‹ ì˜ ìœ„ì¹˜ + ê³µê°œ ìœ„ì¹˜ ì¡°íšŒ
    'influencer',    -- ì‹¤ì‹œê°„ ìœ„ì¹˜ ê³µìœ  ê°€ëŠ¥
    'moderator',     -- ì‹ ê³ ëœ ìœ„ì¹˜ ë°ì´í„° ì¡°íšŒ
    'admin'          -- ëª¨ë“  ìœ„ì¹˜ ë°ì´í„° ì ‘ê·¼
);

-- ê¶Œí•œ íƒ€ì…
CREATE TYPE location_permission AS ENUM (
    'read_public',       -- ê³µê°œ ìœ„ì¹˜ ì½ê¸°
    'read_anonymized',   -- ìµëª…í™” ìœ„ì¹˜ ì½ê¸°
    'read_precise',      -- ì •í™•í•œ ìœ„ì¹˜ ì½ê¸°
    'write_own',         -- ìì‹ ì˜ ìœ„ì¹˜ ì“°ê¸°
    'share_realtime',    -- ì‹¤ì‹œê°„ ìœ„ì¹˜ ê³µìœ 
    'delete_own',        -- ìì‹ ì˜ ìœ„ì¹˜ ì‚­ì œ
    'moderate',          -- ìœ„ì¹˜ ë°ì´í„° ê´€ë¦¬
    'audit'              -- ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ
);

-- RLS ì •ì±…
ALTER TABLE user_locations ENABLE ROW LEVEL SECURITY;

-- ìì‹ ì˜ ìœ„ì¹˜ë§Œ ì“°ê¸°
CREATE POLICY "Users can write own location"
ON user_locations FOR INSERT
TO authenticated
USING (auth.uid() = user_id);

-- ìµëª…í™”ëœ ìœ„ì¹˜ ì½ê¸°
CREATE POLICY "Users can read anonymized locations"
ON user_locations FOR SELECT
TO authenticated
USING (
    -- ìì‹ ì˜ ìœ„ì¹˜
    auth.uid() = user_id
    OR
    -- ê³µê°œëœ ìµëª… ìœ„ì¹˜
    EXISTS (
        SELECT 1 FROM location_permissions
        WHERE user_id = auth.uid()
        AND permission_type = 'read_anonymized'
        AND (expires_at IS NULL OR expires_at > NOW())
    )
);
```

### [í•„ìˆ˜] API ë ˆë²¨ ê¶Œí•œ ê²€ì¦
```python
# íŒŒì¼: backend/core/auth/location_permissions.py
from functools import wraps
from flask import g, abort

class LocationPermissionChecker:
    """ìœ„ì¹˜ ë°ì´í„° ì ‘ê·¼ ê¶Œí•œ ê²€ì¦"""
    
    @staticmethod
    def require_permission(permission_type: str):
        """ë°ì½”ë ˆì´í„°: íŠ¹ì • ê¶Œí•œ í•„ìš”"""
        def decorator(f):
            @wraps(f)
            async def decorated_function(*args, **kwargs):
                user = g.current_user
                
                # ê¶Œí•œ í™•ì¸
                has_permission = await LocationPermissionChecker._check_permission(
                    user.id,
                    permission_type
                )
                
                if not has_permission:
                    # ê°ì‚¬ ë¡œê·¸ ê¸°ë¡
                    await AuditLogger.log_access_denied(
                        user_id=user.id,
                        resource='location',
                        permission=permission_type
                    )
                    abort(403, "Insufficient permissions")
                
                return await f(*args, **kwargs)
            return decorated_function
        return decorator
    
    @staticmethod
    async def _check_permission(user_id: str, permission_type: str) -> bool:
        """ì‚¬ìš©ì ê¶Œí•œ í™•ì¸"""
        result = await g.supabase.table('location_permissions')\
            .select('*')\
            .eq('user_id', user_id)\
            .eq('permission_type', permission_type)\
            .gte('expires_at', datetime.utcnow())\
            .execute()
        
        return len(result.data) > 0

# API ì—”ë“œí¬ì¸íŠ¸ì— ì ìš©
@app.route('/api/locations/realtime', methods=['POST'])
@require_auth
@LocationPermissionChecker.require_permission('share_realtime')
async def share_realtime_location():
    """ì‹¤ì‹œê°„ ìœ„ì¹˜ ê³µìœ  (ì¸í”Œë£¨ì–¸ì„œë§Œ)"""
    # êµ¬í˜„...
```

### [í•„ìˆ˜] í”„ë¡ íŠ¸ì—”ë“œ ê¶Œí•œ ì²´í¬
```dart
// íŒŒì¼: lib/core/permissions/location_permission_manager.dart
class LocationPermissionManager {
  static final _supabase = Supabase.instance.client;
  
  // ê¶Œí•œ ìºì‹œ (5ë¶„)
  static final _permissionCache = <String, CachedPermission>{};
  
  static Future<bool> hasPermission(String permissionType) async {
    final userId = _supabase.auth.currentUser?.id;
    if (userId == null) return false;
    
    // ìºì‹œ í™•ì¸
    final cacheKey = '$userId:$permissionType';
    final cached = _permissionCache[cacheKey];
    if (cached != null && !cached.isExpired) {
      return cached.hasPermission;
    }
    
    // DB ì¡°íšŒ
    try {
      final result = await _supabase
          .from('location_permissions')
          .select()
          .eq('user_id', userId)
          .eq('permission_type', permissionType)
          .gte('expires_at', DateTime.now().toIso8601String())
          .single();
      
      final hasPermission = result != null;
      
      // ìºì‹œ ì—…ë°ì´íŠ¸
      _permissionCache[cacheKey] = CachedPermission(
        hasPermission: hasPermission,
        cachedAt: DateTime.now(),
      );
      
      return hasPermission;
    } catch (e) {
      return false;
    }
  }
  
  // UIì—ì„œ ê¸°ëŠ¥ í‘œì‹œ/ìˆ¨ê¹€
  static Widget buildPermissionGated({
    required String permission,
    required Widget child,
    Widget? fallback,
  }) {
    return FutureBuilder<bool>(
      future: hasPermission(permission),
      builder: (context, snapshot) {
        if (snapshot.data == true) {
          return child;
        }
        return fallback ?? const SizedBox.shrink();
      },
    );
  }
}
```

## 5. ê°ì‚¬ ë¡œê·¸ ê´€ë¦¬

### [í•„ìˆ˜] ê°ì‚¬ ë¡œê·¸ í…Œì´ë¸”
```sql
-- íŒŒì¼: backend/migrations/location_audit_logs.sql

CREATE TABLE location_audit_logs (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    timestamp TIMESTAMP DEFAULT NOW(),
    user_id UUID REFERENCES users(id),
    action_type VARCHAR(50) NOT NULL,
    resource_type VARCHAR(50) DEFAULT 'location',
    resource_id UUID,
    ip_address INET,
    user_agent TEXT,
    
    -- ìƒì„¸ ì •ë³´
    request_data JSONB,
    response_status INTEGER,
    error_message TEXT,
    
    -- ìœ„ì¹˜ ê´€ë ¨
    location_grid JSONB,  -- ìµëª…í™”ëœ ê·¸ë¦¬ë“œ ì •ë³´ë§Œ
    privacy_level INTEGER,
    
    -- ì¸ë±ìŠ¤
    created_at TIMESTAMP DEFAULT NOW()
);

-- ì¸ë±ìŠ¤ ìƒì„±
CREATE INDEX idx_audit_logs_user_timestamp 
ON location_audit_logs(user_id, timestamp DESC);

CREATE INDEX idx_audit_logs_action_timestamp 
ON location_audit_logs(action_type, timestamp DESC);

-- 30ì¼ í›„ ìë™ ì‚­ì œë¥¼ ìœ„í•œ íŒŒí‹°ì…”ë‹
CREATE TABLE location_audit_logs_y2025m01 
PARTITION OF location_audit_logs 
FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
```

### [í•„ìˆ˜] ê°ì‚¬ ë¡œê±° êµ¬í˜„
```python
# íŒŒì¼: backend/core/security/audit_logger.py
import json
from datetime import datetime
from flask import request, g
from typing import Optional, Dict, Any

class LocationAuditLogger:
    """ìœ„ì¹˜ ë°ì´í„° ì ‘ê·¼ ê°ì‚¬ ë¡œê±°"""
    
    @staticmethod
    async def log_location_access(
        action: str,
        resource_id: Optional[str] = None,
        location_data: Optional[Dict[str, Any]] = None,
        success: bool = True,
        error: Optional[str] = None
    ):
        """ìœ„ì¹˜ ë°ì´í„° ì ‘ê·¼ ë¡œê·¸ ê¸°ë¡"""
        
        # ë¯¼ê° ì •ë³´ ì œê±°
        safe_location = None
        if location_data:
            safe_location = {
                'grid_x': location_data.get('grid_x'),
                'grid_y': location_data.get('grid_y'),
                'privacy_level': location_data.get('privacy_level'),
                # ì‹¤ì œ ì¢Œí‘œëŠ” ê¸°ë¡í•˜ì§€ ì•ŠìŒ
            }
        
        audit_entry = {
            'user_id': g.current_user.id if hasattr(g, 'current_user') else None,
            'action_type': action,
            'resource_id': resource_id,
            'ip_address': request.remote_addr,
            'user_agent': request.headers.get('User-Agent'),
            'request_data': {
                'method': request.method,
                'path': request.path,
                'query': dict(request.args),
                # bodyëŠ” ë¯¼ê°ì •ë³´ ì œì™¸
            },
            'response_status': 200 if success else 403,
            'error_message': error,
            'location_grid': safe_location,
            'privacy_level': location_data.get('privacy_level') if location_data else None
        }
        
        try:
            await g.supabase.table('location_audit_logs')\
                .insert(audit_entry)\
                .execute()
        except Exception as e:
            # ë¡œê¹… ì‹¤íŒ¨ëŠ” ìš”ì²­ì„ ë§‰ì§€ ì•ŠìŒ
            print(f"Audit logging failed: {e}")
    
    @staticmethod
    async def analyze_suspicious_patterns(user_id: str) -> Dict[str, Any]:
        """ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ì ‘ê·¼ íŒ¨í„´ ë¶„ì„"""
        
        # ìµœê·¼ 1ì‹œê°„ ë™ì•ˆì˜ ì ‘ê·¼ íŒ¨í„´
        one_hour_ago = datetime.utcnow() - timedelta(hours=1)
        
        result = await g.supabase.table('location_audit_logs')\
            .select('action_type, count')\
            .eq('user_id', user_id)\
            .gte('timestamp', one_hour_ago)\
            .execute()
        
        # ë¹„ì •ìƒ íŒ¨í„´ ê°ì§€
        patterns = {
            'rapid_requests': len(result.data) > 100,  # ì‹œê°„ë‹¹ 100íšŒ ì´ìƒ
            'failed_attempts': sum(1 for r in result.data if r['response_status'] != 200) > 10,
            'different_ips': len(set(r['ip_address'] for r in result.data)) > 5,
        }
        
        if any(patterns.values()):
            # ë³´ì•ˆ íŒ€ì— ì•Œë¦¼
            await SecurityAlert.notify_suspicious_activity(user_id, patterns)
        
        return patterns
```

### [í•„ìˆ˜] ë¡œê·¸ ë¶„ì„ ë° ëª¨ë‹ˆí„°ë§
```python
# íŒŒì¼: backend/core/monitoring/location_audit_monitor.py
class LocationAuditMonitor:
    """ê°ì‚¬ ë¡œê·¸ ëª¨ë‹ˆí„°ë§ ë° ë¶„ì„"""
    
    @staticmethod
    async def daily_audit_report():
        """ì¼ì¼ ê°ì‚¬ ë³´ê³ ì„œ ìƒì„±"""
        yesterday = datetime.utcnow() - timedelta(days=1)
        
        # ì£¼ìš” ì§€í‘œ ì§‘ê³„
        stats = await g.supabase.rpc(
            'aggregate_location_audit_stats',
            {
                'start_date': yesterday.date(),
                'end_date': datetime.utcnow().date()
            }
        ).execute()
        
        report = {
            'date': yesterday.date(),
            'total_accesses': stats.data['total_count'],
            'unique_users': stats.data['unique_users'],
            'failed_attempts': stats.data['failed_count'],
            'suspicious_patterns': stats.data['suspicious_count'],
            'top_actions': stats.data['top_actions'],
            'privacy_levels': stats.data['privacy_level_distribution']
        }
        
        # ì´ë©”ì¼ ë˜ëŠ” Slackìœ¼ë¡œ ì „ì†¡
        await NotificationService.send_audit_report(report)
    
    @staticmethod
    async def realtime_anomaly_detection():
        """ì‹¤ì‹œê°„ ì´ìƒ ì§•í›„ ê°ì§€"""
        # Supabase Realtime êµ¬ë…
        channel = g.supabase.channel('audit_logs')
        
        async def on_new_log(payload):
            log_entry = payload['new']
            
            # ì´ìƒ íŒ¨í„´ í™•ì¸
            if await LocationAuditMonitor._is_anomalous(log_entry):
                await SecurityAlert.trigger_immediate_response(log_entry)
        
        channel.on('INSERT', on_new_log).subscribe()
```

### [ì„ íƒ] ë¡œê·¸ ë³´ê´€ ë° ì••ì¶•
```python
# íŒŒì¼: backend/scripts/archive_audit_logs.py
import gzip
import shutil
from datetime import datetime, timedelta

async def archive_old_logs():
    """30ì¼ ì´ìƒ ëœ ë¡œê·¸ ì••ì¶• ë³´ê´€"""
    cutoff_date = datetime.utcnow() - timedelta(days=30)
    
    # ì˜¤ë˜ëœ ë¡œê·¸ ì¶”ì¶œ
    old_logs = await supabase.table('location_audit_logs')\
        .select('*')\
        .lt('timestamp', cutoff_date)\
        .execute()
    
    if old_logs.data:
        # JSON íŒŒì¼ë¡œ ì €ì¥
        filename = f"audit_logs_{cutoff_date.strftime('%Y%m')}.json"
        with open(filename, 'w') as f:
            json.dump(old_logs.data, f)
        
        # ì••ì¶•
        with open(filename, 'rb') as f_in:
            with gzip.open(f"{filename}.gz", 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        
        # ì›ë³¸ ì‚­ì œ
        os.remove(filename)
        
        # DBì—ì„œ ì‚­ì œ
        await supabase.table('location_audit_logs')\
            .delete()\
            .lt('timestamp', cutoff_date)\
            .execute()
        
        # í´ë¼ìš°ë“œ ìŠ¤í† ë¦¬ì§€ì— ì—…ë¡œë“œ
        await upload_to_storage(f"{filename}.gz")
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ìœ„ì¹˜ ì•”í˜¸í™” í‚¤ í™˜ê²½ë³€ìˆ˜ ì„¤ì •
- [ ] RLS ì •ì±… ì ìš© í™•ì¸
- [ ] ê°ì‚¬ ë¡œê·¸ í…Œì´ë¸” ìƒì„±
- [ ] ê¶Œí•œ ê´€ë¦¬ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
- [ ] ìµëª…í™” ë ˆë²¨ ê²€ì¦
- [ ] ë¡œê·¸ ë³´ê´€ ì •ì±… ìˆ˜ë¦½