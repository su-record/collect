# ğŸ† 11.8 ì ìˆ˜ ì‹œìŠ¤í…œ ë³´ì•ˆ

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ì ìˆ˜ ì¡°ì‘ ë°©ì§€](#2-ì ìˆ˜-ì¡°ì‘-ë°©ì§€)
3. [í™œë™ ê²€ì¦ ì‹œìŠ¤í…œ](#3-í™œë™-ê²€ì¦-ì‹œìŠ¤í…œ)
4. [ì´ìƒ íŒ¨í„´ ê°ì§€](#4-ì´ìƒ-íŒ¨í„´-ê°ì§€)
5. [ì ìˆ˜ ë¡¤ë°± ë° ë³µêµ¬](#5-ì ìˆ˜-ë¡¤ë°±-ë°-ë³µêµ¬)

## 1. ê°œìš”

Fallingoì˜ ì‚¬ìš©ì ë“±ê¸‰ ì‹œìŠ¤í…œì˜ ë¬´ê²°ì„±ì„ ë³´í˜¸í•˜ê³  ë¶€ì •í–‰ìœ„ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•œ ë³´ì•ˆ ì „ëµì„ ì •ì˜í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ë¸”ë¡ì²´ì¸ ë°©ì‹ì˜ ì ìˆ˜ ê¸°ë¡
- âœ… ì‹¤ì‹œê°„ ë¶€ì •í–‰ìœ„ ê°ì§€
- âœ… ìë™í™”ëœ íŒ¨í„´ ë¶„ì„
- âœ… íˆ¬ëª…í•œ ì ìˆ˜ ì´ë ¥ ê´€ë¦¬

## 2. ì ìˆ˜ ì¡°ì‘ ë°©ì§€

### [í•„ìˆ˜] ì ìˆ˜ íŠ¸ëœì­ì…˜ í…Œì´ë¸”
```sql
-- íŒŒì¼: backend/migrations/secure_point_system.sql

-- ì ìˆ˜ íŠ¸ëœì­ì…˜ í…Œì´ë¸” (ë¶ˆë³€ì„± ë³´ì¥)
CREATE TABLE point_transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id),
    transaction_type VARCHAR(50) NOT NULL,
    points INTEGER NOT NULL,
    
    -- íŠ¸ëœì­ì…˜ ìƒì„¸
    source_type VARCHAR(50) NOT NULL, -- feed, like, follow, etc
    source_id UUID, -- ê´€ë ¨ ì—”í‹°í‹° ID
    description TEXT,
    
    -- ê²€ì¦ ì •ë³´
    previous_balance INTEGER NOT NULL,
    new_balance INTEGER NOT NULL,
    hash VARCHAR(64) NOT NULL, -- ì´ì „ íŠ¸ëœì­ì…˜ê³¼ì˜ ì²´ì¸
    
    -- ë©”íƒ€ë°ì´í„°
    ip_address INET,
    user_agent TEXT,
    location_verified BOOLEAN DEFAULT FALSE,
    
    -- ìƒíƒœ
    status VARCHAR(20) DEFAULT 'pending', -- pending, confirmed, reversed
    confirmed_at TIMESTAMP,
    
    created_at TIMESTAMP DEFAULT NOW(),
    
    -- ë¶ˆë³€ì„± ë³´ì¥
    CONSTRAINT points_immutable CHECK (false) NO INHERIT
);

-- íŠ¸ëœì­ì…˜ í•´ì‹œ ê²€ì¦ í•¨ìˆ˜
CREATE OR REPLACE FUNCTION verify_transaction_hash()
RETURNS TRIGGER AS $$
DECLARE
    prev_hash VARCHAR(64);
    calculated_hash VARCHAR(64);
BEGIN
    -- ì´ì „ íŠ¸ëœì­ì…˜ì˜ í•´ì‹œ ì¡°íšŒ
    SELECT hash INTO prev_hash
    FROM point_transactions
    WHERE user_id = NEW.user_id
    ORDER BY created_at DESC
    LIMIT 1;
    
    -- í•´ì‹œ ê³„ì‚°
    calculated_hash := encode(
        sha256(
            (COALESCE(prev_hash, '') || 
             NEW.user_id::text || 
             NEW.points::text || 
             NEW.created_at::text)::bytea
        ),
        'hex'
    );
    
    -- ê²€ì¦
    IF NEW.hash != calculated_hash THEN
        RAISE EXCEPTION 'Invalid transaction hash';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER verify_hash_before_insert
BEFORE INSERT ON point_transactions
FOR EACH ROW
EXECUTE FUNCTION verify_transaction_hash();

-- 2ì‹œê°„ ì ê¸ˆ ì‹œìŠ¤í…œì„ ìœ„í•œ í…Œì´ë¸”
CREATE TABLE point_locks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    transaction_id UUID REFERENCES point_transactions(id),
    locked_until TIMESTAMP NOT NULL,
    unlock_key VARCHAR(32) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
```

### [í•„ìˆ˜] ì ìˆ˜ íŠ¸ëœì­ì…˜ ì„œë¹„ìŠ¤
```python
# íŒŒì¼: backend/core/points/secure_point_service.py
import hashlib
import secrets
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

class SecurePointService:
    """ë³´ì•ˆ ê°•í™”ëœ ì ìˆ˜ ì‹œìŠ¤í…œ"""
    
    @staticmethod
    async def create_transaction(
        user_id: str,
        points: int,
        source_type: str,
        source_id: Optional[str] = None,
        request_context: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """ì ìˆ˜ íŠ¸ëœì­ì…˜ ìƒì„±"""
        
        # 1. ì‚¬ì „ ê²€ì¦
        validation = await SecurePointService._validate_transaction(
            user_id, points, source_type, source_id
        )
        
        if not validation['valid']:
            raise ValueError(f"Invalid transaction: {validation['reason']}")
        
        # 2. í˜„ì¬ ì”ì•¡ ì¡°íšŒ
        current_balance = await SecurePointService._get_user_balance(user_id)
        new_balance = current_balance + points
        
        # 3. í•´ì‹œ ìƒì„±
        transaction_hash = await SecurePointService._generate_hash(
            user_id, points, current_balance
        )
        
        # 4. íŠ¸ëœì­ì…˜ ìƒì„±
        transaction = {
            'user_id': user_id,
            'transaction_type': 'earn' if points > 0 else 'spend',
            'points': points,
            'source_type': source_type,
            'source_id': source_id,
            'previous_balance': current_balance,
            'new_balance': new_balance,
            'hash': transaction_hash,
            'ip_address': request_context.get('ip') if request_context else None,
            'user_agent': request_context.get('user_agent') if request_context else None,
            'location_verified': validation.get('location_verified', False),
            'status': 'pending'
        }
        
        result = await g.supabase.table('point_transactions')\
            .insert(transaction)\
            .execute()
        
        transaction_id = result.data[0]['id']
        
        # 5. 2ì‹œê°„ ì ê¸ˆ ìƒì„±
        if source_type in ['feed_create', 'feed_like']:
            await SecurePointService._create_lock(transaction_id)
        
        # 6. ì‹¤ì‹œê°„ ê²€ì¦
        asyncio.create_task(
            SecurePointService._async_verification(transaction_id)
        )
        
        return result.data[0]
    
    @staticmethod
    async def _validate_transaction(
        user_id: str,
        points: int,
        source_type: str,
        source_id: Optional[str]
    ) -> Dict[str, Any]:
        """íŠ¸ëœì­ì…˜ ìœ íš¨ì„± ê²€ì¦"""
        
        # ì¤‘ë³µ ë°©ì§€
        if source_id:
            existing = await g.supabase.table('point_transactions')\
                .select('id')\
                .eq('user_id', user_id)\
                .eq('source_type', source_type)\
                .eq('source_id', source_id)\
                .execute()
            
            if existing.data:
                return {'valid': False, 'reason': 'duplicate_transaction'}
        
        # ì¼ì¼ í•œë„ í™•ì¸
        daily_limit = await SecurePointService._check_daily_limit(
            user_id, source_type
        )
        
        if not daily_limit['allowed']:
            return {'valid': False, 'reason': 'daily_limit_exceeded'}
        
        # ìœ„ì¹˜ ê¸°ë°˜ í™œë™ ê²€ì¦
        if source_type == 'feed_create':
            location_valid = await LocationVerifier.verify_current_location(
                user_id
            )
            return {
                'valid': location_valid,
                'reason': 'invalid_location' if not location_valid else None,
                'location_verified': location_valid
            }
        
        return {'valid': True}
    
    @staticmethod
    async def _create_lock(transaction_id: str):
        """2ì‹œê°„ ì ê¸ˆ ìƒì„±"""
        unlock_key = secrets.token_urlsafe(24)
        lock_until = datetime.utcnow() + timedelta(hours=2)
        
        await g.supabase.table('point_locks').insert({
            'transaction_id': transaction_id,
            'locked_until': lock_until,
            'unlock_key': unlock_key
        }).execute()
        
        # 2ì‹œê°„ í›„ ìë™ í™•ì •
        asyncio.create_task(
            SecurePointService._auto_confirm_after_lock(
                transaction_id, lock_until
            )
        )
```

### [í•„ìˆ˜] í”„ë¡ íŠ¸ì—”ë“œ ì ìˆ˜ ë³´ì•ˆ
```dart
// íŒŒì¼: lib/core/points/secure_point_manager.dart
class SecurePointManager {
  static final _supabase = Supabase.instance.client;
  
  // ì ìˆ˜ íŠ¸ëœì­ì…˜ ìƒì„± (ë³´ì•ˆ ê°•í™”)
  static Future<PointTransaction?> createTransaction({
    required int points,
    required String sourceType,
    String? sourceId,
  }) async {
    try {
      // ë””ë°”ì´ìŠ¤ ì •ë³´ ìˆ˜ì§‘
      final deviceInfo = await _collectDeviceInfo();
      
      // ìœ„ì¹˜ ê²€ì¦ (í•„ìš”ì‹œ)
      Map<String, dynamic>? locationData;
      if (sourceType == 'feed_create') {
        locationData = await _verifyLocation();
        if (locationData == null) {
          throw Exception('ìœ„ì¹˜ í™•ì¸ ì‹¤íŒ¨');
        }
      }
      
      // API í˜¸ì¶œ
      final response = await _supabase.functions.invoke(
        'create-point-transaction',
        body: {
          'points': points,
          'source_type': sourceType,
          'source_id': sourceId,
          'device_info': deviceInfo,
          'location': locationData,
        },
      );
      
      if (response.error != null) {
        throw response.error!;
      }
      
      // ë¡œì»¬ ìºì‹œ ì—…ë°ì´íŠ¸
      await _updateLocalCache(response.data);
      
      return PointTransaction.fromJson(response.data);
      
    } catch (e) {
      // ì˜¤ë¥˜ ë¡œê¹…
      await _logTransactionError(e, sourceType);
      return null;
    }
  }
  
  // ì ìˆ˜ ì´ë ¥ ê²€ì¦
  static Future<bool> verifyPointHistory() async {
    try {
      final transactions = await _supabase
          .from('point_transactions')
          .select()
          .eq('user_id', _supabase.auth.currentUser!.id)
          .order('created_at', ascending: true);
      
      // í•´ì‹œ ì²´ì¸ ê²€ì¦
      String? previousHash;
      for (final tx in transactions) {
        final calculatedHash = _calculateHash(
          tx['user_id'],
          tx['points'],
          tx['created_at'],
          previousHash,
        );
        
        if (tx['hash'] != calculatedHash) {
          // ë¬´ê²°ì„± ì˜¤ë¥˜ ê°ì§€
          await _reportIntegrityError(tx['id']);
          return false;
        }
        
        previousHash = tx['hash'];
      }
      
      return true;
    } catch (e) {
      return false;
    }
  }
  
  // ì‹¤ì‹œê°„ ì ìˆ˜ ëª¨ë‹ˆí„°ë§
  static void startPointMonitoring() {
    _supabase
        .from('point_transactions')
        .stream(primaryKey: ['id'])
        .eq('user_id', _supabase.auth.currentUser!.id)
        .listen((event) {
          
      if (event.eventType == 'INSERT') {
        final transaction = PointTransaction.fromJson(event.newRecord!);
        
        // ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ê°ì§€
        if (_isSuspiciousTransaction(transaction)) {
          _showSecurityAlert(transaction);
        }
        
        // UI ì—…ë°ì´íŠ¸
        _updatePointDisplay(transaction);
      }
    });
  }
  
  static bool _isSuspiciousTransaction(PointTransaction tx) {
    // ë¹„ì •ìƒì ìœ¼ë¡œ í° ì ìˆ˜
    if (tx.points > 100) return true;
    
    // ì§§ì€ ì‹œê°„ ë‚´ ë°˜ë³µ
    if (_recentTransactions.where((t) => 
      t.sourceType == tx.sourceType &&
      tx.createdAt.difference(t.createdAt).inMinutes < 1
    ).isNotEmpty) return true;
    
    return false;
  }
}
```

## 3. í™œë™ ê²€ì¦ ì‹œìŠ¤í…œ

### [í•„ìˆ˜] ìë™í™” ë°©ì§€ ì‹œìŠ¤í…œ
```python
# íŒŒì¼: backend/core/security/anti_automation.py
import cv2
import numpy as np
from typing import Dict, Tuple, Optional

class AntiAutomationSystem:
    """ìë™í™”/ë´‡ ë°©ì§€ ì‹œìŠ¤í…œ"""
    
    @staticmethod
    async def verify_human_activity(
        user_id: str,
        activity_type: str,
        metadata: Dict
    ) -> Tuple[bool, Optional[str]]:
        """ì¸ê°„ í™œë™ ê²€ì¦"""
        
        # 1. í–‰ë™ íŒ¨í„´ ë¶„ì„
        pattern_check = await AntiAutomationSystem._analyze_behavior_pattern(
            user_id, activity_type
        )
        
        if not pattern_check['human_like']:
            return False, pattern_check['reason']
        
        # 2. ë””ë°”ì´ìŠ¤ í•‘ê±°í”„ë¦°íŒ…
        device_check = await AntiAutomationSystem._verify_device_fingerprint(
            user_id, metadata.get('device_info')
        )
        
        if not device_check['valid']:
            return False, 'suspicious_device'
        
        # 3. ìº¡ì°¨ í•„ìš” ì—¬ë¶€ í™•ì¸
        if pattern_check['confidence'] < 0.7:
            # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ê²½ìš° ìº¡ì°¨ ìš”êµ¬
            captcha_result = await AntiAutomationSystem._request_captcha(
                user_id, activity_type
            )
            
            if not captcha_result['passed']:
                return False, 'captcha_failed'
        
        # 4. ì´ë¯¸ì§€ ê¸°ë°˜ í™œë™ì˜ ê²½ìš° ì¶”ê°€ ê²€ì¦
        if activity_type == 'feed_create' and 'image_data' in metadata:
            image_check = await AntiAutomationSystem._verify_original_image(
                metadata['image_data']
            )
            
            if not image_check['original']:
                return False, 'recycled_image'
        
        return True, None
    
    @staticmethod
    async def _analyze_behavior_pattern(
        user_id: str,
        activity_type: str
    ) -> Dict[str, Any]:
        """ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„"""
        
        # ìµœê·¼ í™œë™ ì¡°íšŒ
        recent_activities = await g.supabase.table('user_activities')\
            .select('*')\
            .eq('user_id', user_id)\
            .gte('created_at', datetime.utcnow() - timedelta(hours=24))\
            .order('created_at', desc=False)\
            .execute()
        
        if not recent_activities.data:
            return {'human_like': True, 'confidence': 1.0}
        
        activities = recent_activities.data
        
        # íŒ¨í„´ ë¶„ì„
        intervals = []
        for i in range(1, len(activities)):
            interval = (activities[i]['created_at'] - activities[i-1]['created_at']).seconds
            intervals.append(interval)
        
        if intervals:
            # ë„ˆë¬´ ê·œì¹™ì ì¸ ê°„ê²© ê°ì§€
            std_dev = np.std(intervals)
            mean_interval = np.mean(intervals)
            
            # ë´‡ì€ ì¼ì •í•œ ê°„ê²©ìœ¼ë¡œ í™œë™
            if std_dev < 5:  # 5ì´ˆ ë¯¸ë§Œì˜ í‘œì¤€í¸ì°¨
                return {
                    'human_like': False,
                    'confidence': 0.2,
                    'reason': 'too_regular_pattern'
                }
            
            # ë„ˆë¬´ ë¹ ë¥¸ í™œë™
            if mean_interval < 10:  # í‰ê·  10ì´ˆ ë¯¸ë§Œ
                return {
                    'human_like': False,
                    'confidence': 0.3,
                    'reason': 'too_fast_activity'
                }
        
        # ë§ˆìš°ìŠ¤/í„°ì¹˜ íŒ¨í„´ ë¶„ì„ (ì €ì¥ëœ ê²½ìš°)
        if 'interaction_data' in activities[-1]:
            interaction_score = AntiAutomationSystem._analyze_interaction_pattern(
                activities[-1]['interaction_data']
            )
            
            return {
                'human_like': interaction_score > 0.6,
                'confidence': interaction_score
            }
        
        return {'human_like': True, 'confidence': 0.8}
    
    @staticmethod
    async def _verify_original_image(image_data: bytes) -> Dict[str, bool]:
        """ì´ë¯¸ì§€ ì›ë³¸ì„± ê²€ì¦"""
        
        # ì´ë¯¸ì§€ í•´ì‹œ ê³„ì‚°
        image_hash = hashlib.sha256(image_data).hexdigest()
        
        # ê¸°ì¡´ ì´ë¯¸ì§€ì™€ ë¹„êµ
        existing = await g.supabase.table('image_hashes')\
            .select('id')\
            .eq('hash', image_hash)\
            .execute()
        
        if existing.data:
            return {'original': False, 'reason': 'duplicate_image'}
        
        # EXIF ë°ì´í„° ê²€ì¦
        try:
            image = Image.open(io.BytesIO(image_data))
            exif = image._getexif()
            
            if exif:
                # ì´¬ì˜ ì‹œê°„ í™•ì¸
                date_taken = exif.get(36867)  # DateTimeOriginal
                if date_taken:
                    taken_time = datetime.strptime(date_taken, '%Y:%m:%d %H:%M:%S')
                    # ë„ˆë¬´ ì˜¤ë˜ëœ ì‚¬ì§„ ê±°ë¶€
                    if datetime.now() - taken_time > timedelta(days=1):
                        return {'original': False, 'reason': 'old_photo'}
            
        except Exception:
            pass
        
        # ì´ë¯¸ì§€ í•´ì‹œ ì €ì¥
        await g.supabase.table('image_hashes').insert({
            'hash': image_hash,
            'first_seen': datetime.utcnow()
        }).execute()
        
        return {'original': True}
```

### [í•„ìˆ˜] ì‹¤ì‹œê°„ í™œë™ ëª¨ë‹ˆí„°ë§
```python
# íŒŒì¼: backend/core/monitoring/activity_monitor.py
class RealTimeActivityMonitor:
    """ì‹¤ì‹œê°„ í™œë™ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self):
        self.redis_client = redis.Redis(
            host=os.environ['REDIS_HOST'],
            decode_responses=True
        )
        
    async def track_activity(
        self,
        user_id: str,
        activity_type: str,
        metadata: Dict
    ):
        """í™œë™ ì¶”ì  ë° ë¶„ì„"""
        
        # í™œë™ ê¸°ë¡
        activity_key = f"activity:{user_id}:{activity_type}"
        timestamp = datetime.utcnow().timestamp()
        
        # Redisì— ì‹œê³„ì—´ ë°ì´í„° ì €ì¥
        self.redis_client.zadd(
            activity_key,
            {json.dumps(metadata): timestamp}
        )
        
        # 1ì‹œê°„ í›„ ìë™ ë§Œë£Œ
        self.redis_client.expire(activity_key, 3600)
        
        # ì‹¤ì‹œê°„ ë¶„ì„
        anomaly_score = await self._calculate_anomaly_score(
            user_id, activity_type
        )
        
        if anomaly_score > 0.8:
            await self._trigger_security_alert(
                user_id, activity_type, anomaly_score
            )
    
    async def _calculate_anomaly_score(
        self,
        user_id: str,
        activity_type: str
    ) -> float:
        """ì´ìƒ ì ìˆ˜ ê³„ì‚°"""
        
        # ìµœê·¼ 1ì‹œê°„ í™œë™ ì¡°íšŒ
        activity_key = f"activity:{user_id}:{activity_type}"
        recent_activities = self.redis_client.zrange(
            activity_key,
            0, -1,
            withscores=True
        )
        
        if len(recent_activities) < 2:
            return 0.0
        
        # í™œë™ ë¹ˆë„ ê³„ì‚°
        timestamps = [score for _, score in recent_activities]
        frequency = len(timestamps) / 3600  # ì‹œê°„ë‹¹ íšŸìˆ˜
        
        # ì´ìƒ ì ìˆ˜ ê³„ì‚°
        anomaly_score = 0.0
        
        # ë„ˆë¬´ ë†’ì€ ë¹ˆë„
        if frequency > 30:  # ì‹œê°„ë‹¹ 30íšŒ ì´ˆê³¼
            anomaly_score += 0.5
        
        # ì¼ì •í•œ ê°„ê²©
        if len(timestamps) > 5:
            intervals = np.diff(timestamps)
            cv = np.std(intervals) / np.mean(intervals)  # ë³€ë™ê³„ìˆ˜
            
            if cv < 0.1:  # ë§¤ìš° ì¼ì •í•œ ê°„ê²©
                anomaly_score += 0.3
        
        # ë™ì¼ íŒ¨í„´ ë°˜ë³µ
        if self._detect_pattern_repetition(recent_activities):
            anomaly_score += 0.2
        
        return min(anomaly_score, 1.0)
```

## 4. ì´ìƒ íŒ¨í„´ ê°ì§€

### [í•„ìˆ˜] ML ê¸°ë°˜ ì´ìƒ ê°ì§€
```python
# íŒŒì¼: backend/core/ml/anomaly_detection.py
import joblib
from sklearn.ensemble import IsolationForest

class PointAnomalyDetector:
    """ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ì ìˆ˜ ì´ìƒ ê°ì§€"""
    
    def __init__(self):
        # ì‚¬ì „ í›ˆë ¨ëœ ëª¨ë¸ ë¡œë“œ
        self.model = joblib.load('models/point_anomaly_detector.pkl')
        self.scaler = joblib.load('models/point_scaler.pkl')
        
    async def detect_anomalies(self, user_id: str) -> Dict[str, Any]:
        """ì‚¬ìš©ìì˜ ì ìˆ˜ íšë“ íŒ¨í„´ ì´ìƒ ê°ì§€"""
        
        # íŠ¹ì§• ì¶”ì¶œ
        features = await self._extract_user_features(user_id)
        
        if features is None:
            return {'anomaly': False, 'score': 0.0}
        
        # ì •ê·œí™”
        features_scaled = self.scaler.transform([features])
        
        # ì´ìƒ ê°ì§€
        anomaly_score = self.model.decision_function(features_scaled)[0]
        is_anomaly = self.model.predict(features_scaled)[0] == -1
        
        if is_anomaly:
            # ìƒì„¸ ë¶„ì„
            details = await self._analyze_anomaly_details(user_id, features)
            
            # ìë™ ëŒ€ì‘
            if details['severity'] == 'high':
                await self._take_automated_action(user_id, details)
            
            return {
                'anomaly': True,
                'score': float(anomaly_score),
                'details': details
            }
        
        return {
            'anomaly': False,
            'score': float(anomaly_score)
        }
    
    async def _extract_user_features(self, user_id: str) -> Optional[List[float]]:
        """ì‚¬ìš©ì íŠ¹ì§• ì¶”ì¶œ"""
        
        # ìµœê·¼ 7ì¼ ë°ì´í„°
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=7)
        
        # ì ìˆ˜ íŠ¸ëœì­ì…˜ í†µê³„
        stats = await g.supabase.rpc(
            'get_user_point_statistics',
            {
                'user_id': user_id,
                'start_date': start_date,
                'end_date': end_date
            }
        ).execute()
        
        if not stats.data:
            return None
        
        data = stats.data[0]
        
        # íŠ¹ì§• ë²¡í„° ìƒì„±
        features = [
            data['total_points'],           # ì´ íšë“ ì ìˆ˜
            data['transaction_count'],       # íŠ¸ëœì­ì…˜ ìˆ˜
            data['unique_days'],            # í™œë™ ì¼ìˆ˜
            data['avg_points_per_day'],     # ì¼í‰ê·  ì ìˆ˜
            data['max_points_per_day'],     # ì¼ ìµœëŒ€ ì ìˆ˜
            data['feed_count'],             # í”¼ë“œ ìˆ˜
            data['like_count'],             # ì¶”ì²œ ìˆ˜
            data['like_received_count'],    # ë°›ì€ ì¶”ì²œ ìˆ˜
            data['time_concentration'],     # ì‹œê°„ ì§‘ì¤‘ë„ (0-1)
            data['activity_diversity'],     # í™œë™ ë‹¤ì–‘ì„± (0-1)
            data['location_diversity'],     # ìœ„ì¹˜ ë‹¤ì–‘ì„± (0-1)
            data['interaction_ratio'],      # ìƒí˜¸ì‘ìš© ë¹„ìœ¨
        ]
        
        return features
    
    async def _analyze_anomaly_details(
        self,
        user_id: str,
        features: List[float]
    ) -> Dict[str, Any]:
        """ì´ìƒ íŒ¨í„´ ìƒì„¸ ë¶„ì„"""
        
        details = {
            'patterns': [],
            'severity': 'low',
            'recommendations': []
        }
        
        # íŒ¨í„´ 1: ë‹¨ê¸°ê°„ ëŒ€ëŸ‰ ì ìˆ˜ íšë“
        if features[0] > 1000 and features[2] < 3:  # 3ì¼ ë¯¸ë§Œì— 1000ì  ì´ìƒ
            details['patterns'].append('rapid_point_accumulation')
            details['severity'] = 'high'
        
        # íŒ¨í„´ 2: ë¹„ì •ìƒì  í™œë™ ì§‘ì¤‘
        if features[8] > 0.9:  # 90% ì´ìƒ íŠ¹ì • ì‹œê°„ëŒ€ ì§‘ì¤‘
            details['patterns'].append('time_concentration')
            details['severity'] = 'medium'
        
        # íŒ¨í„´ 3: ë‚®ì€ ìƒí˜¸ì‘ìš©
        if features[11] < 0.1:  # 10% ë¯¸ë§Œ ìƒí˜¸ì‘ìš©
            details['patterns'].append('low_interaction')
            details['severity'] = 'medium'
        
        # ê¶Œì¥ ì¡°ì¹˜
        if 'rapid_point_accumulation' in details['patterns']:
            details['recommendations'].append('manual_review_required')
            details['recommendations'].append('temporary_restriction')
        
        return details
```

### [í•„ìˆ˜] íŒ¨í„´ ê¸°ë°˜ ê·œì¹™ ì—”ì§„
```python
# íŒŒì¼: backend/core/rules/point_rules_engine.py
class PointRulesEngine:
    """ê·œì¹™ ê¸°ë°˜ ì ìˆ˜ ê²€ì¦ ì—”ì§„"""
    
    RULES = [
        {
            'id': 'MAX_DAILY_FEED',
            'description': 'ì¼ì¼ ìµœëŒ€ í”¼ë“œ ë“±ë¡ ìˆ˜',
            'condition': lambda stats: stats['daily_feed_count'] > 10,
            'action': 'restrict_feed_creation',
            'severity': 'medium'
        },
        {
            'id': 'LIKE_FARMING',
            'description': 'ì¶”ì²œ íŒŒë° ê°ì§€',
            'condition': lambda stats: (
                stats['like_given_count'] > 50 and
                stats['like_received_ratio'] > 0.8
            ),
            'action': 'review_like_pattern',
            'severity': 'high'
        },
        {
            'id': 'LOCATION_SPOOFING',
            'description': 'ìœ„ì¹˜ ì¡°ì‘ ì˜ì‹¬',
            'condition': lambda stats: stats['location_jump_distance'] > 1000,  # 1km
            'action': 'verify_location',
            'severity': 'critical'
        },
        {
            'id': 'FOLLOW_UNFOLLOW',
            'description': 'íŒ”ë¡œìš°/ì–¸íŒ”ë¡œìš° ë‚¨ìš©',
            'condition': lambda stats: (
                stats['follow_count'] > 30 and
                stats['unfollow_count'] > 20
            ),
            'action': 'restrict_follow',
            'severity': 'medium'
        }
    ]
    
    @staticmethod
    async def evaluate_user(user_id: str) -> List[Dict[str, Any]]:
        """ì‚¬ìš©ì í™œë™ ê·œì¹™ í‰ê°€"""
        
        # í†µê³„ ìˆ˜ì§‘
        stats = await PointRulesEngine._collect_user_stats(user_id)
        
        violations = []
        
        # ê° ê·œì¹™ í‰ê°€
        for rule in PointRulesEngine.RULES:
            try:
                if rule['condition'](stats):
                    violation = {
                        'rule_id': rule['id'],
                        'description': rule['description'],
                        'severity': rule['severity'],
                        'action': rule['action'],
                        'detected_at': datetime.utcnow()
                    }
                    
                    violations.append(violation)
                    
                    # ì¦‰ì‹œ ì¡°ì¹˜
                    await PointRulesEngine._take_action(
                        user_id,
                        rule['action'],
                        violation
                    )
                    
            except Exception as e:
                logger.error(f"Rule evaluation error: {rule['id']}, {e}")
        
        # ìœ„ë°˜ ì‚¬í•­ ê¸°ë¡
        if violations:
            await PointRulesEngine._record_violations(user_id, violations)
        
        return violations
    
    @staticmethod
    async def _take_action(
        user_id: str,
        action: str,
        violation: Dict
    ):
        """ê·œì¹™ ìœ„ë°˜ ì‹œ ì¡°ì¹˜"""
        
        if action == 'restrict_feed_creation':
            # 24ì‹œê°„ í”¼ë“œ ìƒì„± ì œí•œ
            await g.supabase.table('user_restrictions').insert({
                'user_id': user_id,
                'restriction_type': 'feed_creation',
                'reason': violation['description'],
                'expires_at': datetime.utcnow() + timedelta(hours=24)
            }).execute()
            
        elif action == 'review_like_pattern':
            # ê´€ë¦¬ì ê²€í†  ëŒ€ìƒ ë“±ë¡
            await AdminNotification.create({
                'type': 'suspicious_activity',
                'user_id': user_id,
                'details': violation,
                'priority': 'high'
            })
            
        elif action == 'verify_location':
            # ìœ„ì¹˜ ì¬ê²€ì¦ ìš”êµ¬
            await g.supabase.table('location_verification_required').insert({
                'user_id': user_id,
                'reason': violation['description']
            }).execute()
```

## 5. ì ìˆ˜ ë¡¤ë°± ë° ë³µêµ¬

### [í•„ìˆ˜] ì ìˆ˜ ë¡¤ë°± ì‹œìŠ¤í…œ
```sql
-- íŒŒì¼: backend/migrations/point_rollback_system.sql

-- ë¡¤ë°± ìš”ì²­ í…Œì´ë¸”
CREATE TABLE point_rollback_requests (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id),
    requested_by UUID REFERENCES users(id), -- ê´€ë¦¬ì ë˜ëŠ” ì‹œìŠ¤í…œ
    reason TEXT NOT NULL,
    rollback_type VARCHAR(50), -- full, partial, specific_period
    
    -- ë¡¤ë°± ë²”ìœ„
    start_date TIMESTAMP,
    end_date TIMESTAMP,
    transaction_ids UUID[], -- íŠ¹ì • íŠ¸ëœì­ì…˜ë§Œ ë¡¤ë°±
    
    -- ìƒíƒœ
    status VARCHAR(20) DEFAULT 'pending',
    approved_by UUID REFERENCES users(id),
    executed_at TIMESTAMP,
    
    -- ê²°ê³¼
    affected_transactions INTEGER,
    points_reversed INTEGER,
    
    created_at TIMESTAMP DEFAULT NOW()
);

-- ë¡¤ë°± ì‹¤í–‰ í•¨ìˆ˜
CREATE OR REPLACE FUNCTION execute_point_rollback(
    rollback_request_id UUID
) RETURNS TABLE (
    success BOOLEAN,
    affected_count INTEGER,
    total_points_reversed INTEGER
) AS $$
DECLARE
    request RECORD;
    current_balance INTEGER;
    points_to_reverse INTEGER := 0;
    affected INTEGER := 0;
BEGIN
    -- ìš”ì²­ ì¡°íšŒ
    SELECT * INTO request
    FROM point_rollback_requests
    WHERE id = rollback_request_id
    AND status = 'approved';
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT FALSE, 0, 0;
        RETURN;
    END IF;
    
    -- í˜„ì¬ ì”ì•¡ ì¡°íšŒ
    SELECT COALESCE(SUM(points), 0) INTO current_balance
    FROM point_transactions
    WHERE user_id = request.user_id
    AND status = 'confirmed';
    
    -- íŠ¸ëœì­ì…˜ ì‹œì‘
    BEGIN
        -- ë¡¤ë°± ëŒ€ìƒ íŠ¸ëœì­ì…˜ ì²˜ë¦¬
        IF request.rollback_type = 'specific_transactions' THEN
            UPDATE point_transactions
            SET status = 'reversed'
            WHERE id = ANY(request.transaction_ids)
            AND user_id = request.user_id
            AND status = 'confirmed';
            
        ELSIF request.rollback_type = 'period' THEN
            UPDATE point_transactions
            SET status = 'reversed'
            WHERE user_id = request.user_id
            AND created_at BETWEEN request.start_date AND request.end_date
            AND status = 'confirmed';
            
        ELSIF request.rollback_type = 'full' THEN
            UPDATE point_transactions
            SET status = 'reversed'
            WHERE user_id = request.user_id
            AND status = 'confirmed';
        END IF;
        
        -- ì˜í–¥ë°›ì€ íŠ¸ëœì­ì…˜ ìˆ˜ ê³„ì‚°
        GET DIAGNOSTICS affected = ROW_COUNT;
        
        -- ë˜ëŒë¦° í¬ì¸íŠ¸ ê³„ì‚°
        SELECT COALESCE(SUM(points), 0) INTO points_to_reverse
        FROM point_transactions
        WHERE user_id = request.user_id
        AND status = 'reversed';
        
        -- ë³´ì • íŠ¸ëœì­ì…˜ ìƒì„±
        INSERT INTO point_transactions (
            user_id,
            transaction_type,
            points,
            source_type,
            description,
            previous_balance,
            new_balance,
            hash,
            status
        ) VALUES (
            request.user_id,
            'rollback',
            -points_to_reverse,
            'system_rollback',
            'Rollback: ' || request.reason,
            current_balance,
            current_balance - points_to_reverse,
            encode(sha256((request.user_id::text || now()::text)::bytea), 'hex'),
            'confirmed'
        );
        
        -- ìš”ì²­ ì—…ë°ì´íŠ¸
        UPDATE point_rollback_requests
        SET 
            status = 'executed',
            executed_at = NOW(),
            affected_transactions = affected,
            points_reversed = points_to_reverse
        WHERE id = rollback_request_id;
        
        RETURN QUERY SELECT TRUE, affected, points_to_reverse;
        
    EXCEPTION WHEN OTHERS THEN
        -- ë¡¤ë°±
        ROLLBACK;
        RETURN QUERY SELECT FALSE, 0, 0;
    END;
END;
$$ LANGUAGE plpgsql;
```

### [í•„ìˆ˜] ìë™ ë³µêµ¬ ì‹œìŠ¤í…œ
```python
# íŒŒì¼: backend/core/recovery/point_recovery_system.py
class PointRecoverySystem:
    """ì ìˆ˜ ìë™ ë³µêµ¬ ì‹œìŠ¤í…œ"""
    
    @staticmethod
    async def auto_detect_and_recover():
        """ë¬´ê²°ì„± ì˜¤ë¥˜ ìë™ ê°ì§€ ë° ë³µêµ¬"""
        
        # 1. í•´ì‹œ ì²´ì¸ ê²€ì¦
        broken_chains = await PointRecoverySystem._find_broken_hash_chains()
        
        for user_id in broken_chains:
            await PointRecoverySystem._repair_hash_chain(user_id)
        
        # 2. ì”ì•¡ ë¶ˆì¼ì¹˜ ê²€ì‚¬
        balance_errors = await PointRecoverySystem._check_balance_consistency()
        
        for error in balance_errors:
            await PointRecoverySystem._fix_balance_error(error)
        
        # 3. ê³ ì•„ íŠ¸ëœì­ì…˜ ì²˜ë¦¬
        orphans = await PointRecoverySystem._find_orphan_transactions()
        
        for orphan in orphans:
            await PointRecoverySystem._handle_orphan_transaction(orphan)
    
    @staticmethod
    async def _find_broken_hash_chains() -> List[str]:
        """ê¹¨ì§„ í•´ì‹œ ì²´ì¸ ì°¾ê¸°"""
        
        result = await g.supabase.rpc(
            'find_broken_hash_chains'
        ).execute()
        
        return [r['user_id'] for r in result.data]
    
    @staticmethod
    async def _repair_hash_chain(user_id: str):
        """í•´ì‹œ ì²´ì¸ ë³µêµ¬"""
        
        # ëª¨ë“  íŠ¸ëœì­ì…˜ ì¡°íšŒ
        transactions = await g.supabase.table('point_transactions')\
            .select('*')\
            .eq('user_id', user_id)\
            .order('created_at')\
            .execute()
        
        # í•´ì‹œ ì¬ê³„ì‚° ë° ì—…ë°ì´íŠ¸
        previous_hash = ''
        for tx in transactions.data:
            correct_hash = hashlib.sha256(
                f"{previous_hash}{tx['user_id']}{tx['points']}{tx['created_at']}".encode()
            ).hexdigest()
            
            if tx['hash'] != correct_hash:
                # ë³µêµ¬ ë¡œê·¸
                await AuditLogger.log_recovery({
                    'type': 'hash_chain_repair',
                    'user_id': user_id,
                    'transaction_id': tx['id'],
                    'old_hash': tx['hash'],
                    'new_hash': correct_hash
                })
                
                # í•´ì‹œ ì—…ë°ì´íŠ¸ (íŠ¹ë³„ ê¶Œí•œ í•„ìš”)
                await g.supabase.rpc(
                    'admin_update_transaction_hash',
                    {
                        'transaction_id': tx['id'],
                        'new_hash': correct_hash
                    }
                ).execute()
            
            previous_hash = correct_hash
    
    @staticmethod
    async def create_recovery_checkpoint(user_id: str):
        """ë³µêµ¬ ì²´í¬í¬ì¸íŠ¸ ìƒì„±"""
        
        # í˜„ì¬ ìƒíƒœ ìŠ¤ëƒ…ìƒ·
        snapshot = {
            'user_id': user_id,
            'timestamp': datetime.utcnow(),
            'total_points': await PointService.get_user_balance(user_id),
            'transaction_count': await PointService.get_transaction_count(user_id),
            'last_transaction_hash': await PointService.get_last_transaction_hash(user_id)
        }
        
        # ì•ˆì „í•œ ì €ì¥ì†Œì— ë°±ì—…
        await g.supabase.table('point_recovery_checkpoints')\
            .insert(snapshot)\
            .execute()
        
        return snapshot
```

### [í•„ìˆ˜] í”„ë¡ íŠ¸ì—”ë“œ ì ìˆ˜ ë³´í˜¸
```dart
// íŒŒì¼: lib/features/points/point_protection_ui.dart
class PointProtectionUI extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final pointSecurity = ref.watch(pointSecurityProvider);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('ğŸ”’ ì ìˆ˜ ë³´ì•ˆ'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () => _verifyIntegrity(context, ref),
          ),
        ],
      ),
      body: ListView(
        children: [
          // ë³´ì•ˆ ìƒíƒœ ì¹´ë“œ
          _buildSecurityStatusCard(pointSecurity),
          
          // ìµœê·¼ ì´ìƒ í™œë™
          _buildAnomalyCard(pointSecurity.anomalies),
          
          // ì ìˆ˜ ì´ë ¥ ê²€ì¦
          _buildHistoryVerification(context, ref),
          
          // ë³´ì•ˆ ì„¤ì •
          _buildSecuritySettings(context, ref),
        ],
      ),
    );
  }
  
  Widget _buildSecurityStatusCard(PointSecurity security) {
    return Card(
      margin: const EdgeInsets.all(16),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  security.isSecure ? Icons.shield : Icons.warning,
                  color: security.isSecure ? Colors.green : Colors.orange,
                  size: 32,
                ),
                const SizedBox(width: 16),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      security.isSecure ? 'ë³´ì•ˆ ìƒíƒœ: ì•ˆì „' : 'ì£¼ì˜ í•„ìš”',
                      style: const TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    Text(
                      'ë§ˆì§€ë§‰ ê²€ì¦: ${security.lastVerified}',
                      style: const TextStyle(color: Colors.grey),
                    ),
                  ],
                ),
              ],
            ),
            if (!security.isSecure) ...[
              const SizedBox(height: 16),
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.orange.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  security.warningMessage ?? 'ë³´ì•ˆ ê²€ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤',
                  style: const TextStyle(color: Colors.orange),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
  
  Future<void> _verifyIntegrity(BuildContext context, WidgetRef ref) async {
    final scaffold = ScaffoldMessenger.of(context);
    
    // ë¡œë”© í‘œì‹œ
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(
        child: CircularProgressIndicator(),
      ),
    );
    
    try {
      // ë¬´ê²°ì„± ê²€ì¦
      final result = await SecurePointManager.verifyPointHistory();
      
      if (context.mounted) {
        Navigator.pop(context);
        
        scaffold.showSnackBar(
          SnackBar(
            content: Text(
              result ? 'âœ… ì ìˆ˜ ì´ë ¥ì´ ì•ˆì „í•©ë‹ˆë‹¤' : 'âš ï¸ ë¬¸ì œê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤',
            ),
            backgroundColor: result ? Colors.green : Colors.orange,
          ),
        );
        
        if (!result) {
          // ë¬¸ì œ ìƒì„¸ í‘œì‹œ
          _showIntegrityIssueDialog(context);
        }
      }
    } catch (e) {
      if (context.mounted) {
        Navigator.pop(context);
        scaffold.showSnackBar(
          const SnackBar(
            content: Text('ê²€ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
```

## âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì ìˆ˜ íŠ¸ëœì­ì…˜ í…Œì´ë¸” ìƒì„±
- [ ] í•´ì‹œ ì²´ì¸ ê²€ì¦ êµ¬í˜„
- [ ] ìë™í™” ë°©ì§€ ì‹œìŠ¤í…œ ì„¤ì •
- [ ] ML ëª¨ë¸ í›ˆë ¨ ë° ë°°í¬
- [ ] ë¡¤ë°± ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
- [ ] ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ êµ¬ì¶•