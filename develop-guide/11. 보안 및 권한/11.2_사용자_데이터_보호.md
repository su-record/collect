# ğŸ›¡ï¸ 11.2 ì‚¬ìš©ì ë°ì´í„° ë³´í˜¸

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ê¸€ë¡œë²Œ ê°œì¸ì •ë³´ë³´í˜¸ ê·œì • ì¤€ìˆ˜](#2-ê¸€ë¡œë²Œ-ê°œì¸ì •ë³´ë³´í˜¸-ê·œì •-ì¤€ìˆ˜)
3. [ê°œì¸ì •ë³´ ì•”í˜¸í™”](#3-ê°œì¸ì •ë³´-ì•”í˜¸í™”)
4. [êµ­ê°€ë³„ ë°ì´í„° ì €ì¥](#4-êµ­ê°€ë³„-ë°ì´í„°-ì €ì¥)
5. [ë°ì´í„° ì²˜ë¦¬ ì •ì±…](#5-ë°ì´í„°-ì²˜ë¦¬-ì •ì±…)
6. [ê²€ì¦](#6-ê²€ì¦)

## 1. ê°œìš”
FallingoëŠ” ê¸€ë¡œë²Œ ì„œë¹„ìŠ¤ë¡œì„œ ê°êµ­ì˜ ê°œì¸ì •ë³´ë³´í˜¸ë²•ì„ ì¤€ìˆ˜í•˜ë©°, ì‚¬ìš©ì ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ë³´í˜¸í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… GDPR, CCPA, í•œêµ­ ê°œì¸ì •ë³´ë³´í˜¸ë²• ì¤€ìˆ˜
- âœ… êµ­ê°€ë³„ ë°ì´í„° ì§€ì—­í™”
- âœ… íˆ¬ëª…í•œ ë°ì´í„° ì²˜ë¦¬ ì •ì±…
- âœ… ì‚¬ìš©ì ê¶Œë¦¬ ë³´ì¥

## 2. ê¸€ë¡œë²Œ ê°œì¸ì •ë³´ë³´í˜¸ ê·œì • ì¤€ìˆ˜

### [í•„ìˆ˜] GDPR ì¤€ìˆ˜ (ìœ ëŸ½)
```python
# íŒŒì¼: backend/compliance/gdpr_compliance.py
from datetime import datetime, timedelta
from enum import Enum
import json

class GDPRRights(Enum):
    """GDPR ê¶Œë¦¬ ìœ í˜•"""
    ACCESS = "access"              # ì—´ëŒê¶Œ
    RECTIFICATION = "rectification" # ì •ì •ê¶Œ
    ERASURE = "erasure"           # ì‚­ì œê¶Œ (ìŠí˜€ì§ˆ ê¶Œë¦¬)
    PORTABILITY = "portability"    # ì´ë™ê¶Œ
    RESTRICTION = "restriction"    # ì²˜ë¦¬ ì œí•œê¶Œ
    OBJECTION = "objection"       # ë°˜ëŒ€ê¶Œ

class GDPRCompliance:
    """GDPR ì¤€ìˆ˜ ê´€ë¦¬"""
    
    def __init__(self, supabase_client):
        self.supabase = supabase_client
    
    async def handle_data_request(self, user_id: str, request_type: GDPRRights):
        """GDPR ë°ì´í„° ìš”ì²­ ì²˜ë¦¬"""
        
        # ìš”ì²­ ê¸°ë¡
        await self._log_gdpr_request(user_id, request_type)
        
        if request_type == GDPRRights.ACCESS:
            return await self._handle_access_request(user_id)
        elif request_type == GDPRRights.RECTIFICATION:
            return await self._handle_rectification_request(user_id)
        elif request_type == GDPRRights.ERASURE:
            return await self._handle_erasure_request(user_id)
        elif request_type == GDPRRights.PORTABILITY:
            return await self._handle_portability_request(user_id)
        elif request_type == GDPRRights.RESTRICTION:
            return await self._handle_restriction_request(user_id)
        elif request_type == GDPRRights.OBJECTION:
            return await self._handle_objection_request(user_id)
    
    async def _handle_access_request(self, user_id: str):
        """ê°œì¸ì •ë³´ ì—´ëŒ ìš”ì²­ ì²˜ë¦¬ (30ì¼ ì´ë‚´)"""
        # ëª¨ë“  ê°œì¸ì •ë³´ ìˆ˜ì§‘
        user_data = {
            'profile': await self._get_user_profile(user_id),
            'feeds': await self._get_user_feeds(user_id),
            'comments': await self._get_user_comments(user_id),
            'activities': await self._get_user_activities(user_id),
            'location_history': await self._get_location_history(user_id),
            'processing_purposes': self._get_processing_purposes()
        }
        
        # PDF ë¦¬í¬íŠ¸ ìƒì„±
        report_url = await self._generate_data_report(user_id, user_data)
        
        # ì´ë©”ì¼ ì „ì†¡
        await self._send_gdpr_report(user_id, report_url)
        
        return {
            'status': 'completed',
            'report_url': report_url,
            'expires_at': (datetime.now() + timedelta(days=7)).isoformat()
        }
    
    async def _handle_erasure_request(self, user_id: str):
        """ì‚­ì œê¶Œ ìš”ì²­ ì²˜ë¦¬ (ìŠí˜€ì§ˆ ê¶Œë¦¬)"""
        # ë²•ì  ë³´ì¡´ ì˜ë¬´ í™•ì¸
        if await self._has_legal_obligation(user_id):
            return {
                'status': 'rejected',
                'reason': 'legal_obligation',
                'details': 'ë²•ì  ë³´ì¡´ ì˜ë¬´ê°€ ìˆëŠ” ë°ì´í„°ì…ë‹ˆë‹¤'
            }
        
        # ì‚­ì œ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
        deletion_plan = {
            'immediate': [
                'personal_identifiers',  # ê°œì¸ ì‹ë³„ ì •ë³´
                'contact_info',         # ì—°ë½ì²˜ ì •ë³´
                'location_data',        # ìœ„ì¹˜ ì •ë³´
                'activity_logs'         # í™œë™ ë¡œê·¸
            ],
            'anonymized': [
                'feeds',               # í”¼ë“œ (ìµëª…í™”)
                'comments',            # ëŒ“ê¸€ (ìµëª…í™”)
                'reviews'              # ë¦¬ë·° (ìµëª…í™”)
            ],
            'retained': [
                'transaction_logs',    # ê±°ë˜ ë¡œê·¸ (ë²•ì  ì˜ë¬´)
                'security_logs'        # ë³´ì•ˆ ë¡œê·¸ (ë³´ì•ˆ ëª©ì )
            ]
        }
        
        # ë‹¨ê³„ë³„ ì‚­ì œ ì‹¤í–‰
        await self._execute_deletion_plan(user_id, deletion_plan)
        
        return {
            'status': 'completed',
            'deletion_plan': deletion_plan,
            'completed_at': datetime.now().isoformat()
        }
    
    async def _handle_portability_request(self, user_id: str):
        """ë°ì´í„° ì´ë™ê¶Œ ìš”ì²­ ì²˜ë¦¬"""
        # êµ¬ì¡°í™”ëœ ë°ì´í„° ìˆ˜ì§‘
        portable_data = {
            'format': 'JSON',
            'version': '1.0',
            'created_at': datetime.now().isoformat(),
            'user_data': {
                'profile': await self._get_portable_profile(user_id),
                'content': await self._get_portable_content(user_id),
                'preferences': await self._get_portable_preferences(user_id)
            }
        }
        
        # í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ë‚´ë³´ë‚´ê¸°
        export_file = await self._export_to_standard_format(
            user_id, 
            portable_data
        )
        
        return {
            'status': 'completed',
            'download_url': export_file['url'],
            'format': 'JSON',
            'expires_at': (datetime.now() + timedelta(days=30)).isoformat()
        }
    
    def _get_processing_purposes(self):
        """ë°ì´í„° ì²˜ë¦¬ ëª©ì  ëª…ì‹œ"""
        return {
            'service_provision': {
                'description': 'ì„œë¹„ìŠ¤ ì œê³µ',
                'legal_basis': 'contract',
                'data_types': ['profile', 'feeds', 'location']
            },
            'service_improvement': {
                'description': 'ì„œë¹„ìŠ¤ ê°œì„ ',
                'legal_basis': 'legitimate_interest',
                'data_types': ['usage_analytics', 'feedback']
            },
            'marketing': {
                'description': 'ë§ˆì¼€íŒ… ì»¤ë®¤ë‹ˆì¼€ì´ì…˜',
                'legal_basis': 'consent',
                'data_types': ['contact_info', 'preferences']
            }
        }
```

### [í•„ìˆ˜] CCPA ì¤€ìˆ˜ (ìº˜ë¦¬í¬ë‹ˆì•„)
```python
# íŒŒì¼: backend/compliance/ccpa_compliance.py
class CCPACompliance:
    """CCPA (ìº˜ë¦¬í¬ë‹ˆì•„ ì†Œë¹„ì ê°œì¸ì •ë³´ë³´í˜¸ë²•) ì¤€ìˆ˜"""
    
    def __init__(self, supabase_client):
        self.supabase = supabase_client
    
    async def handle_opt_out_request(self, user_id: str):
        """ê°œì¸ì •ë³´ íŒë§¤ ê±°ë¶€ê¶Œ ì²˜ë¦¬"""
        # FallingoëŠ” ê°œì¸ì •ë³´ë¥¼ íŒë§¤í•˜ì§€ ì•ŠìŒ
        await self.supabase.table('privacy_preferences').upsert({
            'user_id': user_id,
            'do_not_sell': True,
            'updated_at': datetime.now().isoformat()
        }).execute()
        
        return {
            'status': 'confirmed',
            'message': 'FallingoëŠ” ì‚¬ìš©ìì˜ ê°œì¸ì •ë³´ë¥¼ íŒë§¤í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤'
        }
    
    async def provide_privacy_rights_info(self):
        """CCPA ê¶Œë¦¬ ì •ë³´ ì œê³µ"""
        return {
            'rights': {
                'right_to_know': {
                    'title': 'ì•Œ ê¶Œë¦¬',
                    'description': 'ìˆ˜ì§‘ëœ ê°œì¸ì •ë³´ ë²”ì£¼ì™€ ì‚¬ìš© ëª©ì ì„ ì•Œ ê¶Œë¦¬'
                },
                'right_to_delete': {
                    'title': 'ì‚­ì œ ìš”ì²­ê¶Œ',
                    'description': 'ê°œì¸ì •ë³´ ì‚­ì œë¥¼ ìš”ì²­í•  ê¶Œë¦¬'
                },
                'right_to_opt_out': {
                    'title': 'íŒë§¤ ê±°ë¶€ê¶Œ',
                    'description': 'ê°œì¸ì •ë³´ íŒë§¤ë¥¼ ê±°ë¶€í•  ê¶Œë¦¬'
                },
                'right_to_non_discrimination': {
                    'title': 'ì°¨ë³„ë°›ì§€ ì•Šì„ ê¶Œë¦¬',
                    'description': 'ê¶Œë¦¬ í–‰ì‚¬ë¡œ ì¸í•œ ì°¨ë³„ì„ ë°›ì§€ ì•Šì„ ê¶Œë¦¬'
                }
            },
            'contact': {
                'email': 'privacy@fallingo.com',
                'phone': '1-800-FALLINGO',
                'response_time': '45ì¼ ì´ë‚´'
            }
        }
    
    async def generate_annual_report(self, year: int):
        """ì—°ê°„ íˆ¬ëª…ì„± ë³´ê³ ì„œ ìƒì„±"""
        report = {
            'year': year,
            'requests': {
                'access_requests': await self._count_requests('access', year),
                'deletion_requests': await self._count_requests('deletion', year),
                'opt_out_requests': await self._count_requests('opt_out', year)
            },
            'compliance_rate': '100%',
            'average_response_time': '15 days',
            'data_categories_collected': [
                'identifiers',
                'commercial_information',
                'internet_activity',
                'geolocation_data',
                'inferences'
            ]
        }
        
        return report
```

### [í•„ìˆ˜] í•œêµ­ ê°œì¸ì •ë³´ë³´í˜¸ë²• ì¤€ìˆ˜
```python
# íŒŒì¼: backend/compliance/kpipa_compliance.py
class KPIPACompliance:
    """í•œêµ­ ê°œì¸ì •ë³´ë³´í˜¸ë²• ì¤€ìˆ˜"""
    
    def __init__(self, supabase_client):
        self.supabase = supabase_client
    
    async def collect_consent(self, user_id: str, consent_items: dict):
        """ê°œì¸ì •ë³´ ìˆ˜ì§‘ ë™ì˜ íšë“"""
        required_consents = {
            'service_terms': 'ì„œë¹„ìŠ¤ ì´ìš©ì•½ê´€ (í•„ìˆ˜)',
            'privacy_policy': 'ê°œì¸ì •ë³´ ì²˜ë¦¬ë°©ì¹¨ (í•„ìˆ˜)',
            'location_data': 'ìœ„ì¹˜ì •ë³´ ìˆ˜ì§‘ ë° ì´ìš© (í•„ìˆ˜)',
            'marketing': 'ë§ˆì¼€íŒ… ì •ë³´ ìˆ˜ì‹  (ì„ íƒ)',
            'third_party_sharing': 'ì œ3ì ì œê³µ (ì„ íƒ)'
        }
        
        # í•„ìˆ˜ í•­ëª© ê²€ì¦
        for key, desc in required_consents.items():
            if '(í•„ìˆ˜)' in desc and not consent_items.get(key, False):
                raise ValueError(f"í•„ìˆ˜ ë™ì˜ í•­ëª© ëˆ„ë½: {desc}")
        
        # ë™ì˜ ë‚´ì—­ ì €ì¥
        consent_record = {
            'user_id': user_id,
            'consents': consent_items,
            'ip_address': self._hash_ip(request.remote_addr),
            'timestamp': datetime.now().isoformat(),
            'version': '2.0'  # ë™ì˜ ì–‘ì‹ ë²„ì „
        }
        
        await self.supabase.table('consent_records').insert(
            consent_record
        ).execute()
        
        return {'status': 'success', 'record_id': consent_record['id']}
    
    async def handle_data_subject_rights(self, user_id: str, right_type: str):
        """ì •ë³´ì£¼ì²´ ê¶Œë¦¬ í–‰ì‚¬ ì²˜ë¦¬"""
        rights_handlers = {
            'access': self._handle_access_right,      # ì—´ëŒê¶Œ
            'correction': self._handle_correction_right, # ì •ì •ê¶Œ
            'deletion': self._handle_deletion_right,   # ì‚­ì œê¶Œ
            'suspension': self._handle_suspension_right, # ì²˜ë¦¬ì •ì§€ê¶Œ
        }
        
        if right_type not in rights_handlers:
            raise ValueError(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ê¶Œë¦¬ ìœ í˜•: {right_type}")
        
        # ì‹ ì› í™•ì¸
        if not await self._verify_identity(user_id):
            return {'status': 'failed', 'reason': 'ì‹ ì› í™•ì¸ ì‹¤íŒ¨'}
        
        # ê¶Œë¦¬ í–‰ì‚¬ ì²˜ë¦¬
        result = await rights_handlers[right_type](user_id)
        
        # ì²˜ë¦¬ ê²°ê³¼ í†µì§€ (10ì¼ ì´ë‚´)
        await self._notify_result(user_id, right_type, result)
        
        return result
    
    async def manage_sensitive_info(self, user_id: str):
        """ë¯¼ê°ì •ë³´ ê´€ë¦¬"""
        # ë¯¼ê°ì •ë³´ ì •ì˜
        sensitive_categories = {
            'health': 'ê±´ê°• ì •ë³´',
            'religion': 'ì¢…êµ ì •ë³´',
            'political': 'ì •ì¹˜ì  ê²¬í•´',
            'biometric': 'ìƒì²´ì¸ì‹ ì •ë³´'
        }
        
        # FallingoëŠ” ë¯¼ê°ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ì§€ ì•ŠìŒ
        return {
            'collected': False,
            'categories': [],
            'policy': 'ì„œë¹„ìŠ¤ íŠ¹ì„±ìƒ ë¯¼ê°ì •ë³´ë¥¼ ìˆ˜ì§‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤'
        }
    
    def get_retention_periods(self):
        """ê°œì¸ì •ë³´ ë³´ìœ ê¸°ê°„ ëª…ì‹œ"""
        return {
            'user_profile': {
                'period': 'íšŒì› íƒˆí‡´ ì‹œê¹Œì§€',
                'legal_basis': 'ì •ë³´í†µì‹ ë§ë²•'
            },
            'service_usage': {
                'period': '3ë…„',
                'legal_basis': 'ì „ììƒê±°ë˜ë²•'
            },
            'location_data': {
                'period': '1ë…„',
                'legal_basis': 'ìœ„ì¹˜ì •ë³´ë²•'
            },
            'marketing_consent': {
                'period': 'ë™ì˜ ì² íšŒ ì‹œê¹Œì§€',
                'legal_basis': 'ì •ë³´í†µì‹ ë§ë²•'
            }
        }
```

## 3. ê°œì¸ì •ë³´ ì•”í˜¸í™”

### [í•„ìˆ˜] ë‹¤ì¸µ ì•”í˜¸í™” ì‹œìŠ¤í…œ
```python
# íŒŒì¼: backend/security/multi_layer_encryption.py
import os
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from cryptography.hazmat.primitives.kdf.scrypt import Scrypt
import secrets
import json

class MultiLayerEncryption:
    """ë‹¤ì¸µ ì•”í˜¸í™” ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        # ë§ˆìŠ¤í„° í‚¤ (HSM ë˜ëŠ” KMSì—ì„œ ê´€ë¦¬)
        self.master_key = os.getenv('MASTER_KEY_ID')
        
        # ì•”í˜¸í™” ë ˆì´ì–´ ì •ì˜
        self.layers = {
            'application': self._get_app_key(),
            'database': self._get_db_key(),
            'field': self._get_field_key()
        }
    
    def encrypt_pii(self, data: dict, user_id: str):
        """ê°œì¸ì‹ë³„ì •ë³´(PII) ì•”í˜¸í™”"""
        # PII í•„ë“œ ì •ì˜
        pii_fields = [
            'email', 'phone', 'real_name', 'birth_date',
            'national_id', 'passport_number', 'credit_card'
        ]
        
        encrypted_data = data.copy()
        
        for field in pii_fields:
            if field in data and data[field]:
                # í•„ë“œë³„ ì•”í˜¸í™” í‚¤ ìƒì„±
                field_key = self._derive_field_key(user_id, field)
                
                # AES-GCM ì•”í˜¸í™”
                aesgcm = AESGCM(field_key)
                nonce = secrets.token_bytes(12)
                
                plaintext = json.dumps(data[field]).encode()
                ciphertext = aesgcm.encrypt(nonce, plaintext, None)
                
                # ì•”í˜¸í™”ëœ ë°ì´í„° ì €ì¥
                encrypted_data[field] = {
                    'ciphertext': ciphertext.hex(),
                    'nonce': nonce.hex(),
                    'version': 1
                }
        
        return encrypted_data
    
    def tokenize_sensitive_data(self, sensitive_value: str, data_type: str):
        """ë¯¼ê°í•œ ë°ì´í„° í† í°í™”"""
        # í† í° ìƒì„±
        token = secrets.token_urlsafe(32)
        
        # í† í°-ì‹¤ì œê°’ ë§¤í•‘ ì €ì¥ (ë³„ë„ì˜ ì•ˆì „í•œ ì €ì¥ì†Œ)
        self._store_token_mapping(token, sensitive_value, data_type)
        
        # ë§ˆìŠ¤í‚¹ëœ í‘œì‹œê°’ ìƒì„±
        if data_type == 'email':
            parts = sensitive_value.split('@')
            masked = f"{parts[0][:2]}***@{parts[1]}"
        elif data_type == 'phone':
            masked = f"{sensitive_value[:3]}****{sensitive_value[-4:]}"
        else:
            masked = "****"
        
        return {
            'token': token,
            'masked_display': masked,
            'type': data_type
        }
```

## 4. êµ­ê°€ë³„ ë°ì´í„° ì €ì¥

### [í•„ìˆ˜] ë°ì´í„° ì§€ì—­í™” ì •ì±…
```python
# íŒŒì¼: backend/compliance/data_localization.py
from enum import Enum

class DataRegion(Enum):
    """ë°ì´í„° ì €ì¥ ì§€ì—­"""
    KOREA = "asia-northeast3"      # ì„œìš¸
    JAPAN = "asia-northeast1"      # ë„ì¿„
    EU = "europe-west1"           # ë²¨ê¸°ì—
    US = "us-central1"            # ì•„ì´ì˜¤ì™€
    SINGAPORE = "asia-southeast1"  # ì‹±ê°€í¬ë¥´

class DataLocalization:
    """êµ­ê°€ë³„ ë°ì´í„° ì§€ì—­í™” ê´€ë¦¬"""
    
    # êµ­ê°€ë³„ ë°ì´í„° ì €ì¥ ì •ì±…
    LOCALIZATION_RULES = {
        'KR': {
            'region': DataRegion.KOREA,
            'required_by_law': True,
            'data_types': ['personal_info', 'location', 'financial']
        },
        'CN': {
            'region': DataRegion.KOREA,  # ì¤‘êµ­ì€ ë³„ë„ ì²˜ë¦¬ í•„ìš”
            'required_by_law': True,
            'data_types': ['all']
        },
        'EU': {
            'region': DataRegion.EU,
            'required_by_law': True,
            'data_types': ['personal_info']
        },
        'JP': {
            'region': DataRegion.JAPAN,
            'required_by_law': False,
            'data_types': ['personal_info', 'location']
        },
        'US': {
            'region': DataRegion.US,
            'required_by_law': False,
            'data_types': ['all']
        },
        'DEFAULT': {
            'region': DataRegion.SINGAPORE,
            'required_by_law': False,
            'data_types': ['all']
        }
    }
    
    def get_storage_region(self, user_country: str, data_type: str):
        """ì‚¬ìš©ì êµ­ê°€ì™€ ë°ì´í„° ìœ í˜•ì— ë”°ë¥¸ ì €ì¥ ì§€ì—­ ê²°ì •"""
        rules = self.LOCALIZATION_RULES.get(
            user_country, 
            self.LOCALIZATION_RULES['DEFAULT']
        )
        
        # ë²•ì  ìš”êµ¬ì‚¬í•­ í™•ì¸
        if rules['required_by_law']:
            if 'all' in rules['data_types'] or data_type in rules['data_types']:
                return rules['region']
        
        # ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•œ ì§€ì—­ ì„ íƒ
        return self._get_optimal_region(user_country)
    
    async def migrate_user_data(self, user_id: str, from_region: str, to_region: str):
        """ì‚¬ìš©ì ë°ì´í„° ì§€ì—­ ê°„ ë§ˆì´ê·¸ë ˆì´ì…˜"""
        migration_plan = {
            'user_id': user_id,
            'from_region': from_region,
            'to_region': to_region,
            'started_at': datetime.now().isoformat(),
            'steps': []
        }
        
        try:
            # 1. ë°ì´í„° ë³µì‚¬
            migration_plan['steps'].append({
                'step': 'copy_data',
                'status': 'started'
            })
            await self._copy_data_to_region(user_id, to_region)
            
            # 2. ë°ì´í„° ê²€ì¦
            migration_plan['steps'].append({
                'step': 'verify_data',
                'status': 'started'
            })
            if not await self._verify_data_integrity(user_id, to_region):
                raise Exception("ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦ ì‹¤íŒ¨")
            
            # 3. ë¼ìš°íŒ… ì—…ë°ì´íŠ¸
            migration_plan['steps'].append({
                'step': 'update_routing',
                'status': 'started'
            })
            await self._update_user_routing(user_id, to_region)
            
            # 4. ì´ì „ ë°ì´í„° ì‚­ì œ
            migration_plan['steps'].append({
                'step': 'cleanup_old_data',
                'status': 'started'
            })
            await self._cleanup_old_region_data(user_id, from_region)
            
            migration_plan['completed_at'] = datetime.now().isoformat()
            migration_plan['status'] = 'completed'
            
        except Exception as e:
            migration_plan['status'] = 'failed'
            migration_plan['error'] = str(e)
            
        return migration_plan
```

### [í•„ìˆ˜] Supabase ë©€í‹° ë¦¬ì „ ì„¤ì •
```python
# íŒŒì¼: backend/config/supabase_regions.py
import os
from supabase import create_client

class SupabaseRegionalClients:
    """ì§€ì—­ë³„ Supabase í´ë¼ì´ì–¸íŠ¸ ê´€ë¦¬"""
    
    def __init__(self):
        self.clients = {}
        self._initialize_regional_clients()
    
    def _initialize_regional_clients(self):
        """ì§€ì—­ë³„ í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”"""
        regions = {
            'korea': {
                'url': os.getenv('SUPABASE_URL_KR'),
                'key': os.getenv('SUPABASE_ANON_KEY_KR')
            },
            'japan': {
                'url': os.getenv('SUPABASE_URL_JP'),
                'key': os.getenv('SUPABASE_ANON_KEY_JP')
            },
            'eu': {
                'url': os.getenv('SUPABASE_URL_EU'),
                'key': os.getenv('SUPABASE_ANON_KEY_EU')
            },
            'us': {
                'url': os.getenv('SUPABASE_URL_US'),
                'key': os.getenv('SUPABASE_ANON_KEY_US')
            }
        }
        
        for region, config in regions.items():
            if config['url'] and config['key']:
                self.clients[region] = create_client(
                    config['url'],
                    config['key']
                )
    
    def get_client_for_user(self, user_id: str):
        """ì‚¬ìš©ìì— ì í•©í•œ ì§€ì—­ í´ë¼ì´ì–¸íŠ¸ ë°˜í™˜"""
        # ì‚¬ìš©ì ì§€ì—­ ì •ë³´ ì¡°íšŒ
        user_region = self._get_user_region(user_id)
        
        # í•´ë‹¹ ì§€ì—­ í´ë¼ì´ì–¸íŠ¸ ë°˜í™˜
        return self.clients.get(user_region, self.clients['us'])
    
    async def replicate_across_regions(self, table: str, data: dict):
        """ì¤‘ìš” ë°ì´í„°ì˜ ì§€ì—­ ê°„ ë³µì œ"""
        results = {}
        
        for region, client in self.clients.items():
            try:
                result = await client.table(table).insert(data).execute()
                results[region] = {'status': 'success', 'data': result.data}
            except Exception as e:
                results[region] = {'status': 'failed', 'error': str(e)}
        
        return results
```

## 5. ë°ì´í„° ì²˜ë¦¬ ì •ì±…

### [í•„ìˆ˜] íšŒì› íƒˆí‡´ ì‹œ ë°ì´í„° ì²˜ë¦¬
```python
# íŒŒì¼: backend/services/account_deletion_service.py
class AccountDeletionService:
    """íšŒì› íƒˆí‡´ ì‹œ ë°ì´í„° ì²˜ë¦¬ ì„œë¹„ìŠ¤"""
    
    def __init__(self, supabase_client):
        self.supabase = supabase_client
    
    async def process_account_deletion(self, user_id: str, deletion_request: dict):
        """ë‹¨ê³„ë³„ ê³„ì • ì‚­ì œ ì²˜ë¦¬"""
        
        deletion_log = {
            'user_id': user_id,
            'requested_at': datetime.now().isoformat(),
            'request_reason': deletion_request.get('reason'),
            'steps': []
        }
        
        try:
            # 1. ì¦‰ì‹œ ì‚­ì œ ë°ì´í„°
            await self._delete_immediate_data(user_id)
            deletion_log['steps'].append({
                'type': 'immediate_deletion',
                'data_types': [
                    'personal_identifiers',
                    'contact_information',
                    'authentication_data',
                    'payment_methods',
                    'precise_location_history'
                ],
                'status': 'completed'
            })
            
            # 2. ìµëª…í™” ì²˜ë¦¬ ë°ì´í„°
            await self._anonymize_content(user_id)
            deletion_log['steps'].append({
                'type': 'anonymization',
                'data_types': [
                    'feeds',
                    'comments',
                    'reviews',
                    'recommendations'
                ],
                'status': 'completed',
                'method': 'user_id_replacement'
            })
            
            # 3. ë²•ì  ë³´ì¡´ ë°ì´í„°
            legal_retention = await self._process_legal_retention(user_id)
            deletion_log['steps'].append({
                'type': 'legal_retention',
                'data_types': legal_retention['retained_types'],
                'retention_period': legal_retention['period'],
                'legal_basis': legal_retention['basis']
            })
            
            # 4. ë°±ì—… ë°ì´í„° ì²˜ë¦¬
            await self._mark_backups_for_deletion(user_id)
            deletion_log['steps'].append({
                'type': 'backup_deletion',
                'scheduled_deletion': '30_days',
                'status': 'scheduled'
            })
            
            # 5. ì œ3ì ë°ì´í„° ì²˜ë¦¬
            await self._notify_third_parties(user_id)
            deletion_log['steps'].append({
                'type': 'third_party_notification',
                'notified': ['google_maps', 'cloud_vision'],
                'status': 'notified'
            })
            
            deletion_log['completed_at'] = datetime.now().isoformat()
            deletion_log['status'] = 'completed'
            
        except Exception as e:
            deletion_log['status'] = 'failed'
            deletion_log['error'] = str(e)
        
        # ì‚­ì œ ë¡œê·¸ ë³´ê´€ (ê·œì • ì¤€ìˆ˜ ì¦ëª…ìš©)
        await self._store_deletion_log(deletion_log)
        
        return deletion_log
    
    async def _anonymize_content(self, user_id: str):
        """ì½˜í…ì¸  ìµëª…í™” ì²˜ë¦¬"""
        anonymous_user = {
            'user_id': 'deleted_user',
            'nickname': 'íƒˆí‡´í•œ ì‚¬ìš©ì',
            'profile_image': None,
            'level': 0
        }
        
        # í”¼ë“œ ìµëª…í™”
        await self.supabase.table('feeds').update({
            'user_id': anonymous_user['user_id'],
            'user_nickname': anonymous_user['nickname'],
            'user_profile_image': anonymous_user['profile_image']
        }).eq('user_id', user_id).execute()
        
        # ëŒ“ê¸€ ìµëª…í™”
        await self.supabase.table('comments').update({
            'user_id': anonymous_user['user_id'],
            'user_nickname': anonymous_user['nickname']
        }).eq('user_id', user_id).execute()
    
    def _get_legal_retention_requirements(self, user_country: str):
        """êµ­ê°€ë³„ ë²•ì  ë³´ì¡´ ìš”êµ¬ì‚¬í•­"""
        retention_rules = {
            'KR': {
                'transaction_logs': {
                    'period': '5ë…„',
                    'law': 'ì „ììƒê±°ë˜ë²•'
                },
                'access_logs': {
                    'period': '3ê°œì›”',
                    'law': 'ì •ë³´í†µì‹ ë§ë²•'
                },
                'consent_records': {
                    'period': '3ë…„',
                    'law': 'ê°œì¸ì •ë³´ë³´í˜¸ë²•'
                }
            },
            'EU': {
                'financial_records': {
                    'period': '7ë…„',
                    'law': 'EU Accounting Directive'
                },
                'consent_records': {
                    'period': 'ì¦ëª… í•„ìš”ì‹œê¹Œì§€',
                    'law': 'GDPR'
                }
            },
            'US': {
                'tax_records': {
                    'period': '7ë…„',
                    'law': 'IRS Requirements'
                }
            }
        }
        
        return retention_rules.get(user_country, {})
```

## 6. ê²€ì¦

### âœ… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] GDPR ë°ì´í„° ìš”ì²­ 30ì¼ ì´ë‚´ ì²˜ë¦¬
- [ ] CCPA ê¶Œë¦¬ í–‰ì‚¬ 45ì¼ ì´ë‚´ ì‘ë‹µ
- [ ] í•œêµ­ ê°œì¸ì •ë³´ë³´í˜¸ë²• 10ì¼ ì´ë‚´ ì²˜ë¦¬
- [ ] êµ­ê°€ë³„ ë°ì´í„° ì €ì¥ ìœ„ì¹˜ ì •í™•ì„±
- [ ] íšŒì› íƒˆí‡´ ì‹œ ì¦‰ì‹œ ì‚­ì œ/ìµëª…í™” ì²˜ë¦¬
- [ ] ë²•ì  ë³´ì¡´ ê¸°ê°„ ì¤€ìˆ˜

### ğŸ§ª ì»´í”Œë¼ì´ì–¸ìŠ¤ í…ŒìŠ¤íŠ¸
```python
# íŒŒì¼: backend/tests/test_compliance.py
import pytest
from datetime import datetime, timedelta

class TestPrivacyCompliance:
    
    @pytest.mark.asyncio
    async def test_gdpr_data_request_timeline(self):
        """GDPR ë°ì´í„° ìš”ì²­ ì²˜ë¦¬ ì‹œê°„ í…ŒìŠ¤íŠ¸"""
        # ë°ì´í„° ìš”ì²­ ìƒì„±
        request_id = await create_gdpr_request(
            user_id='test_user',
            type='access'
        )
        
        # ì²˜ë¦¬ ì™„ë£Œ í™•ì¸
        result = await process_gdpr_request(request_id)
        
        # 30ì¼ ì´ë‚´ ì²˜ë¦¬ í™•ì¸
        processing_time = result['completed_at'] - result['created_at']
        assert processing_time.days <= 30
    
    @pytest.mark.asyncio
    async def test_data_localization(self):
        """ë°ì´í„° ì§€ì—­í™” í…ŒìŠ¤íŠ¸"""
        test_cases = [
            ('KR', 'personal_info', 'asia-northeast3'),
            ('JP', 'location', 'asia-northeast1'),
            ('DE', 'personal_info', 'europe-west1'),
            ('US', 'feeds', 'us-central1')
        ]
        
        for country, data_type, expected_region in test_cases:
            region = get_storage_region(country, data_type)
            assert region == expected_region
    
    @pytest.mark.asyncio
    async def test_account_deletion_anonymization(self):
        """ê³„ì • ì‚­ì œ ì‹œ ìµëª…í™” í…ŒìŠ¤íŠ¸"""
        # í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ìƒì„±
        user_id = await create_test_user()
        feed_id = await create_test_feed(user_id)
        
        # ê³„ì • ì‚­ì œ ì²˜ë¦¬
        await process_account_deletion(user_id)
        
        # í”¼ë“œ ìµëª…í™” í™•ì¸
        feed = await get_feed(feed_id)
        assert feed['user_id'] == 'deleted_user'
        assert feed['user_nickname'] == 'íƒˆí‡´í•œ ì‚¬ìš©ì'
        
        # ê°œì¸ì •ë³´ ì‚­ì œ í™•ì¸
        user = await get_user(user_id)
        assert user is None
```