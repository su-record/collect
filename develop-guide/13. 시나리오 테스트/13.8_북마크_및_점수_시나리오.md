# ğŸ”– 13.8 ë¶ë§ˆí¬ ë° ì ìˆ˜ ì‹œë‚˜ë¦¬ì˜¤

## ğŸ“‹ ëª©ì°¨
1. [ê°œìš”](#1-ê°œìš”)
2. [ë¶ë§ˆí¬ ê¸°ëŠ¥ ì‹œë‚˜ë¦¬ì˜¤](#2-ë¶ë§ˆí¬-ê¸°ëŠ¥-ì‹œë‚˜ë¦¬ì˜¤)
3. [2ì‹œê°„ ì ê¸ˆ ì‹œìŠ¤í…œ](#3-2ì‹œê°„-ì ê¸ˆ-ì‹œìŠ¤í…œ)
4. [ì ìˆ˜ ê³„ì‚° ì‹œë‚˜ë¦¬ì˜¤](#4-ì ìˆ˜-ê³„ì‚°-ì‹œë‚˜ë¦¬ì˜¤)
5. [ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸](#5-ê²€ì¦-ì²´í¬ë¦¬ìŠ¤íŠ¸)

## 1. ê°œìš”

ë¶ë§ˆí¬ ê¸°ëŠ¥ê³¼ í™œë™ ì ìˆ˜ ì‹œìŠ¤í…œì˜ ì •ìƒ ì‘ë™ì„ ê²€ì¦í•˜ëŠ” í†µí•© ì‹œë‚˜ë¦¬ì˜¤ì…ë‹ˆë‹¤. ì‚¬ìš©ì í™œë™ì— ëŒ€í•œ ì ì ˆí•œ ë³´ìƒê³¼ ì–´ë·°ì§• ë°©ì§€ ë©”ì»¤ë‹ˆì¦˜ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.

### ğŸ“Œ í•µì‹¬ í¬ì¸íŠ¸
- âœ… ë¶ë§ˆí¬ë¡œ ê´€ì‹¬ ì¥ì†Œ íš¨ìœ¨ì  ê´€ë¦¬
- âœ… 2ì‹œê°„ ì ê¸ˆìœ¼ë¡œ ì‹ ì¤‘í•œ í™œë™ ìœ ë„
- âœ… ê³µì •í•˜ê³  íˆ¬ëª…í•œ ì ìˆ˜ ì‹œìŠ¤í…œ

## 2. ë¶ë§ˆí¬ ê¸°ëŠ¥ ì‹œë‚˜ë¦¬ì˜¤

### [í•„ìˆ˜] ë¶ë§ˆí¬ ê¸°ëŠ¥ êµ¬í˜„

```dart
// íŒŒì¼: lib/features/bookmark/bookmark_service.dart
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class BookmarkService {
  final SupabaseClient _supabase;
  
  BookmarkService(this._supabase);
  
  // ë¶ë§ˆí¬ ì¶”ê°€/ì œê±° í† ê¸€
  Future<bool> toggleBookmark(String feedId) async {
    final userId = _supabase.auth.currentUser!.id;
    
    try {
      // ê¸°ì¡´ ë¶ë§ˆí¬ í™•ì¸
      final existing = await _supabase
          .from('bookmarks')
          .select()
          .eq('user_id', userId)
          .eq('feed_id', feedId)
          .maybeSingle();
      
      if (existing != null) {
        // ë¶ë§ˆí¬ ì œê±°
        await _supabase
            .from('bookmarks')
            .delete()
            .eq('id', existing['id']);
        
        // ì ìˆ˜ ì°¨ê° (-1ì )
        await _updateActivityPoints(userId, -1, 'bookmark_removed');
        
        return false; // ë¶ë§ˆí¬ í•´ì œë¨
      } else {
        // ë¶ë§ˆí¬ ì¶”ê°€
        await _supabase.from('bookmarks').insert({
          'user_id': userId,
          'feed_id': feedId,
          'created_at': DateTime.now().toIso8601String(),
        });
        
        // ì ìˆ˜ ì¶”ê°€ (+1ì )
        await _updateActivityPoints(userId, 1, 'bookmark_added');
        
        // í”¼ë“œ ì‘ì„±ìì—ê²Œ ì•Œë¦¼
        await _notifyFeedOwner(feedId);
        
        return true; // ë¶ë§ˆí¬ ì¶”ê°€ë¨
      }
    } catch (e) {
      throw Exception('ë¶ë§ˆí¬ ì²˜ë¦¬ ì‹¤íŒ¨: $e');
    }
  }
  
  // ì‚¬ìš©ìì˜ ë¶ë§ˆí¬ ëª©ë¡ ì¡°íšŒ
  Future<List<BookmarkedFeed>> getUserBookmarks({
    required int page,
    int limit = 20,
  }) async {
    final userId = _supabase.auth.currentUser!.id;
    final offset = page * limit;
    
    final response = await _supabase
        .from('bookmarks')
        .select('''
          id,
          created_at,
          feeds!inner(
            id,
            menu_name,
            store_name,
            location,
            images,
            recommendation_count
          )
        ''')
        .eq('user_id', userId)
        .order('created_at', ascending: false)
        .range(offset, offset + limit - 1);
    
    return (response as List)
        .map((item) => BookmarkedFeed.fromJson(item))
        .toList();
  }
  
  // í™œë™ ì ìˆ˜ ì—…ë°ì´íŠ¸
  Future<void> _updateActivityPoints(
    String userId,
    int points,
    String reason,
  ) async {
    await _supabase.from('activity_points').insert({
      'user_id': userId,
      'points': points,
      'reason': reason,
      'created_at': DateTime.now().toIso8601String(),
    });
  }
  
  // í”¼ë“œ ì‘ì„±ìì—ê²Œ ì•Œë¦¼
  Future<void> _notifyFeedOwner(String feedId) async {
    final feed = await _supabase
        .from('feeds')
        .select('user_id')
        .eq('id', feedId)
        .single();
    
    if (feed['user_id'] != 'deleted_user') {
      await _supabase.from('notifications').insert({
        'user_id': feed['user_id'],
        'type': 'bookmark_received',
        'feed_id': feedId,
        'created_at': DateTime.now().toIso8601String(),
      });
    }
  }
}

// ë¶ë§ˆí¬ ìƒíƒœ ê´€ë¦¬
final bookmarkServiceProvider = Provider((ref) {
  return BookmarkService(Supabase.instance.client);
});

// íŠ¹ì • í”¼ë“œì˜ ë¶ë§ˆí¬ ìƒíƒœ
final isBookmarkedProvider = FutureProvider.family<bool, String>((ref, feedId) async {
  final supabase = Supabase.instance.client;
  final userId = supabase.auth.currentUser?.id;
  
  if (userId == null) return false;
  
  final result = await supabase
      .from('bookmarks')
      .select('id')
      .eq('user_id', userId)
      .eq('feed_id', feedId)
      .maybeSingle();
  
  return result != null;
});
```

### [í•„ìˆ˜] ë¶ë§ˆí¬ UI êµ¬í˜„

```dart
// íŒŒì¼: lib/features/bookmark/bookmark_button.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class BookmarkButton extends ConsumerWidget {
  final String feedId;
  final VoidCallback? onToggled;
  
  const BookmarkButton({
    required this.feedId,
    this.onToggled,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isBookmarkedAsync = ref.watch(isBookmarkedProvider(feedId));
    
    return isBookmarkedAsync.when(
      data: (isBookmarked) => IconButton(
        icon: Icon(
          isBookmarked ? Icons.bookmark : Icons.bookmark_border,
          color: isBookmarked ? Colors.orange : Colors.grey,
        ),
        onPressed: () async {
          try {
            // í–…í‹± í”¼ë“œë°±
            HapticFeedback.lightImpact();
            
            // ë¶ë§ˆí¬ í† ê¸€
            final newState = await ref
                .read(bookmarkServiceProvider)
                .toggleBookmark(feedId);
            
            // ìƒíƒœ ìƒˆë¡œê³ ì¹¨
            ref.invalidate(isBookmarkedProvider(feedId));
            
            // ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
            if (context.mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(
                  content: Text(
                    newState ? 'ë¶ë§ˆí¬ì— ì¶”ê°€í–ˆì–´ìš”! ğŸ”–' : 'ë¶ë§ˆí¬ë¥¼ í•´ì œí–ˆì–´ìš”',
                  ),
                  duration: const Duration(seconds: 1),
                  behavior: SnackBarBehavior.floating,
                ),
              );
            }
            
            onToggled?.call();
          } catch (e) {
            if (context.mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: $e')),
              );
            }
          }
        },
      ),
      loading: () => const IconButton(
        icon: Icon(Icons.bookmark_border, color: Colors.grey),
        onPressed: null,
      ),
      error: (_, __) => const IconButton(
        icon: Icon(Icons.bookmark_border, color: Colors.grey),
        onPressed: null,
      ),
    );
  }
}

// ë¶ë§ˆí¬ ëª©ë¡ í™”ë©´
class BookmarkListScreen extends ConsumerStatefulWidget {
  const BookmarkListScreen({Key? key}) : super(key: key);
  
  @override
  ConsumerState<BookmarkListScreen> createState() => _BookmarkListScreenState();
}

class _BookmarkListScreenState extends ConsumerState<BookmarkListScreen> {
  final ScrollController _scrollController = ScrollController();
  int _currentPage = 0;
  List<BookmarkedFeed> _bookmarks = [];
  bool _isLoading = false;
  bool _hasMore = true;
  
  @override
  void initState() {
    super.initState();
    _loadBookmarks();
    _scrollController.addListener(_onScroll);
  }
  
  Future<void> _loadBookmarks() async {
    if (_isLoading || !_hasMore) return;
    
    setState(() => _isLoading = true);
    
    try {
      final service = ref.read(bookmarkServiceProvider);
      final newBookmarks = await service.getUserBookmarks(page: _currentPage);
      
      setState(() {
        _bookmarks.addAll(newBookmarks);
        _currentPage++;
        _hasMore = newBookmarks.length >= 20;
        _isLoading = false;
      });
    } catch (e) {
      setState(() => _isLoading = false);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('ë¶ë§ˆí¬ ë¡œë“œ ì‹¤íŒ¨: $e')),
        );
      }
    }
  }
  
  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      _loadBookmarks();
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('ë‚´ ë¶ë§ˆí¬ ğŸ”–'),
        backgroundColor: Colors.white,
        foregroundColor: Colors.black,
      ),
      body: _bookmarks.isEmpty && !_isLoading
          ? const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.bookmark_border, size: 64, color: Colors.grey),
                  SizedBox(height: 16),
                  Text('ì•„ì§ ë¶ë§ˆí¬í•œ ë§›ì§‘ì´ ì—†ì–´ìš”'),
                  Text('ë§ˆìŒì— ë“œëŠ” ë§›ì§‘ì„ ë¶ë§ˆí¬í•´ë³´ì„¸ìš”!'),
                ],
              ),
            )
          : ListView.builder(
              controller: _scrollController,
              itemCount: _bookmarks.length + (_isLoading ? 1 : 0),
              itemBuilder: (context, index) {
                if (index == _bookmarks.length) {
                  return const Center(
                    child: Padding(
                      padding: EdgeInsets.all(16),
                      child: CircularProgressIndicator(),
                    ),
                  );
                }
                
                final bookmark = _bookmarks[index];
                return BookmarkListItem(bookmark: bookmark);
              },
            ),
    );
  }
}
```

## 3. 2ì‹œê°„ ì ê¸ˆ ì‹œìŠ¤í…œ

### [í•„ìˆ˜] ì ê¸ˆ ì‹œìŠ¤í…œ êµ¬í˜„

```dart
// íŒŒì¼: lib/features/feed/feed_lock_system.dart
import 'package:supabase_flutter/supabase_flutter.dart';

class FeedLockSystem {
  static const Duration lockDuration = Duration(hours: 2);
  
  // í”¼ë“œ ë“±ë¡ ì‹œ ì ê¸ˆ ìƒíƒœë¡œ ìƒì„±
  static Future<String> createLockedFeed({
    required Map<String, dynamic> feedData,
  }) async {
    final supabase = Supabase.instance.client;
    final userId = supabase.auth.currentUser!.id;
    
    // í”¼ë“œ ìƒì„± (ì ìˆ˜ ë¯¸í™•ì • ìƒíƒœ)
    final response = await supabase.from('feeds').insert({
      ...feedData,
      'user_id': userId,
      'is_locked': true,
      'locked_until': DateTime.now().add(lockDuration).toIso8601String(),
      'points_pending': _calculatePendingPoints(feedData),
      'created_at': DateTime.now().toIso8601String(),
    }).select().single();
    
    // 2ì‹œê°„ í›„ ìë™ ì ê¸ˆ í•´ì œ ìŠ¤ì¼€ì¤„
    _scheduleUnlock(response['id']);
    
    return response['id'];
  }
  
  // ì ê¸ˆ í•´ì œ ë° ì ìˆ˜ í™•ì •
  static Future<void> unlockFeed(String feedId) async {
    final supabase = Supabase.instance.client;
    
    // íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì²˜ë¦¬
    await supabase.rpc('unlock_feed_and_award_points', params: {
      'feed_id': feedId,
    });
  }
  
  // ì ê¸ˆ ì¤‘ ì‚­ì œ ì‹œë„
  static Future<bool> tryDeleteLockedFeed(String feedId) async {
    final supabase = Supabase.instance.client;
    
    // ì ê¸ˆ ìƒíƒœ í™•ì¸
    final feed = await supabase
        .from('feeds')
        .select('is_locked, locked_until, user_id')
        .eq('id', feedId)
        .single();
    
    // ë³¸ì¸ í™•ì¸
    if (feed['user_id'] != supabase.auth.currentUser!.id) {
      throw Exception('ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤');
    }
    
    if (feed['is_locked'] == true) {
      final lockedUntil = DateTime.parse(feed['locked_until']);
      if (DateTime.now().isBefore(lockedUntil)) {
        // ì ê¸ˆ ì¤‘ ì‚­ì œ - ì ìˆ˜ ë¯¸ì§€ê¸‰
        await supabase.from('feeds').delete().eq('id', feedId);
        return true; // ì ìˆ˜ ì—†ì´ ì‚­ì œë¨
      }
    }
    
    // ì ê¸ˆ í•´ì œëœ í”¼ë“œëŠ” ì¼ë°˜ ì‚­ì œ í”„ë¡œì„¸ìŠ¤
    return false;
  }
  
  // ëŒ€ê¸° ì¤‘ì¸ ì ìˆ˜ ê³„ì‚°
  static int _calculatePendingPoints(Map<String, dynamic> feedData) {
    int points = 3; // ê¸°ë³¸ ë“±ë¡ ì ìˆ˜
    
    // ìµœì´ˆ ë“±ë¡ ë³´ë„ˆìŠ¤
    if (feedData['is_first_registration'] == true) {
      points += 10;
    }
    
    // OCR ì¶”ê°€ ì˜ˆì • ì‹œ ì¶”ê°€ ì ìˆ˜ëŠ” ë‚˜ì¤‘ì—
    
    return points;
  }
  
  // ìë™ ì ê¸ˆ í•´ì œ ìŠ¤ì¼€ì¤„
  static void _scheduleUnlock(String feedId) {
    // ì‹¤ì œë¡œëŠ” ì„œë²„ ì‚¬ì´ë“œì—ì„œ ì²˜ë¦¬
    // Cloud Functionsë‚˜ Supabase Edge Functions ì‚¬ìš©
  }
}

// ì ê¸ˆ ìƒíƒœ UI í‘œì‹œ
class FeedLockIndicator extends StatelessWidget {
  final String feedId;
  final DateTime lockedUntil;
  
  const FeedLockIndicator({
    required this.feedId,
    required this.lockedUntil,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return StreamBuilder<int>(
      stream: Stream.periodic(const Duration(seconds: 1), (_) {
        final remaining = lockedUntil.difference(DateTime.now());
        return remaining.inSeconds;
      }),
      builder: (context, snapshot) {
        final remainingSeconds = snapshot.data ?? 0;
        
        if (remainingSeconds <= 0) {
          return const SizedBox.shrink();
        }
        
        final hours = remainingSeconds ~/ 3600;
        final minutes = (remainingSeconds % 3600) ~/ 60;
        final seconds = remainingSeconds % 60;
        
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
          decoration: BoxDecoration(
            color: Colors.orange.shade100,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.lock_clock, size: 16, color: Colors.orange),
              const SizedBox(width: 4),
              Text(
                '${hours.toString().padLeft(2, '0')}:'
                '${minutes.toString().padLeft(2, '0')}:'
                '${seconds.toString().padLeft(2, '0')}',
                style: const TextStyle(
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                  color: Colors.orange,
                ),
              ),
            ],
          ),
        );
      },
    );
  }
}
```

## 4. ì ìˆ˜ ê³„ì‚° ì‹œë‚˜ë¦¬ì˜¤

### [í•„ìˆ˜] ì ìˆ˜ ì‹œìŠ¤í…œ êµ¬í˜„

```python
# íŒŒì¼: backend/services/point_calculation.py
from datetime import datetime, timedelta
from typing import Dict, List
import logging

class PointCalculationService:
    """í™œë™ ì ìˆ˜ ê³„ì‚° ë° ê´€ë¦¬ ì„œë¹„ìŠ¤"""
    
    # ì ìˆ˜ ì •ì±…
    POINTS = {
        'feed_registration': 3,
        'first_registration': 10,
        'ocr_bonus': 5,
        'recommendation_given': 1,
        'bookmark_given': 1,
        'daily_reaction_min': 5,
        'daily_reaction_max': 50,
    }
    
    def __init__(self, supabase_client):
        self.supabase = supabase_client
        self.logger = logging.getLogger(__name__)
    
    def award_feed_registration_points(self, user_id: str, feed_data: Dict) -> int:
        """í”¼ë“œ ë“±ë¡ ì ìˆ˜ ê³„ì‚° ë° ì§€ê¸‰"""
        points = self.POINTS['feed_registration']
        
        # ìµœì´ˆ ë“±ë¡ í™•ì¸
        if self._is_first_registration(feed_data):
            points += self.POINTS['first_registration']
            self._log_activity(user_id, 'first_registration', 
                             self.POINTS['first_registration'])
        
        # ê¸°ë³¸ ë“±ë¡ ì ìˆ˜ ê¸°ë¡
        self._log_activity(user_id, 'feed_registration', 
                         self.POINTS['feed_registration'])
        
        # ì´ ì ìˆ˜ ì—…ë°ì´íŠ¸
        self._update_user_points(user_id, points)
        
        return points
    
    def award_ocr_bonus(self, user_id: str, feed_id: str) -> int:
        """OCR ì¶”ê°€ ë³´ë„ˆìŠ¤ ì ìˆ˜"""
        # 24ì‹œê°„ ë‚´ ì¶”ê°€ í™•ì¸
        feed = self.supabase.table('feeds').select('created_at').eq('id', feed_id).single().execute()
        created_at = datetime.fromisoformat(feed.data['created_at'])
        
        if datetime.now() - created_at > timedelta(hours=24):
            raise ValueError("OCR ì¶”ê°€ ê¸°í•œì´ ì§€ë‚¬ìŠµë‹ˆë‹¤")
        
        # ë³´ë„ˆìŠ¤ ì§€ê¸‰
        points = self.POINTS['ocr_bonus']
        self._log_activity(user_id, 'ocr_bonus', points)
        self._update_user_points(user_id, points)
        
        return points
    
    def calculate_daily_reaction_points(self, user_id: str) -> int:
        """ì¼ì¼ ë°˜ì‘ ë³´ìƒ ê³„ì‚°"""
        # ì˜¤ëŠ˜ ë°›ì€ ì¶”ì²œ/ë¶ë§ˆí¬ ìˆ˜ ê³„ì‚°
        today_start = datetime.now().replace(hour=0, minute=0, second=0)
        
        # ì¶”ì²œ ìˆ˜
        recommendations = self.supabase.table('recommendations')\
            .select('id', count='exact')\
            .gte('created_at', today_start.isoformat())\
            .eq('feed_user_id', user_id)\
            .execute()
        
        # ë¶ë§ˆí¬ ìˆ˜
        bookmarks = self.supabase.table('bookmarks')\
            .select('id', count='exact')\
            .gte('created_at', today_start.isoformat())\
            .eq('feed_user_id', user_id)\
            .execute()
        
        total_reactions = recommendations.count + bookmarks.count
        
        # ì ìˆ˜ ê³„ì‚° (5~50ì  ë²”ìœ„)
        if total_reactions == 0:
            return 0
        elif total_reactions <= 5:
            points = self.POINTS['daily_reaction_min']
        elif total_reactions >= 50:
            points = self.POINTS['daily_reaction_max']
        else:
            # ì„ í˜• ë³´ê°„
            points = int(self.POINTS['daily_reaction_min'] + 
                        (total_reactions - 5) / 45 * 
                        (self.POINTS['daily_reaction_max'] - 
                         self.POINTS['daily_reaction_min']))
        
        self._log_activity(user_id, 'daily_reaction_bonus', points,
                         {'reactions': total_reactions})
        self._update_user_points(user_id, points)
        
        return points
    
    def get_user_level(self, total_points: int) -> Dict:
        """ì ìˆ˜ì— ë”°ë¥¸ ë“±ê¸‰ ê³„ì‚°"""
        levels = [
            {'level': 1, 'name': 'ëˆ„ë£½ì§€', 'emoji': 'ğŸ˜', 'min_points': 0},
            {'level': 2, 'name': 'ë¹„ë¹”ë°¥', 'emoji': 'ğŸ¥—', 'min_points': 100},
            {'level': 3, 'name': 'ì‚¼ê²¹ì‚´', 'emoji': 'ğŸ¥“', 'min_points': 300},
            {'level': 4, 'name': 'ê°ˆë¹„íƒ•', 'emoji': 'ğŸ²', 'min_points': 600},
            {'level': 5, 'name': 'ëª¨ë‘ íšŒ', 'emoji': 'ğŸŸ', 'min_points': 1000},
            {'level': 6, 'name': 'ì”ì¹«ìƒ', 'emoji': 'ğŸŠ', 'min_points': 1500},
            {'level': 7, 'name': 'ìˆ˜ëìƒ', 'emoji': 'ğŸ‘‘', 'min_points': 2500},
        ]
        
        current_level = levels[0]
        for level in levels:
            if total_points >= level['min_points']:
                current_level = level
            else:
                break
        
        # ë‹¤ìŒ ë ˆë²¨ê¹Œì§€ í•„ìš”í•œ ì ìˆ˜
        next_level_idx = min(current_level['level'], len(levels) - 1)
        if next_level_idx < len(levels) - 1:
            next_level = levels[next_level_idx]
            points_to_next = next_level['min_points'] - total_points
        else:
            next_level = None
            points_to_next = 0
        
        return {
            'current': current_level,
            'next': next_level,
            'points_to_next': points_to_next,
            'total_points': total_points,
        }
    
    def _is_first_registration(self, feed_data: Dict) -> bool:
        """ìµœì´ˆ ë“±ë¡ ì—¬ë¶€ í™•ì¸"""
        # ê°™ì€ ìœ„ì¹˜, ê°™ì€ ê°€ê²Œì˜ ë©”ë‰´ê°€ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
        existing = self.supabase.table('feeds')\
            .select('id')\
            .eq('store_name', feed_data['store_name'])\
            .eq('menu_name', feed_data['menu_name'])\
            .limit(1)\
            .execute()
        
        return len(existing.data) == 0
    
    def _log_activity(self, user_id: str, activity_type: str, 
                     points: int, metadata: Dict = None):
        """í™œë™ ë¡œê·¸ ê¸°ë¡"""
        self.supabase.table('activity_logs').insert({
            'user_id': user_id,
            'activity_type': activity_type,
            'points': points,
            'metadata': metadata,
            'created_at': datetime.now().isoformat(),
        }).execute()
    
    def _update_user_points(self, user_id: str, points: int):
        """ì‚¬ìš©ì ì´ ì ìˆ˜ ì—…ë°ì´íŠ¸"""
        # PostgreSQLì˜ atomic update
        self.supabase.rpc('increment_user_points', {
            'user_id': user_id,
            'points': points,
        }).execute()
        
        # ë ˆë²¨ ë³€ê²½ í™•ì¸
        self._check_level_up(user_id)
    
    def _check_level_up(self, user_id: str):
        """ë ˆë²¨ì—… í™•ì¸ ë° ì•Œë¦¼"""
        user = self.supabase.table('user_profiles')\
            .select('total_points, current_level')\
            .eq('user_id', user_id)\
            .single()\
            .execute()
        
        level_info = self.get_user_level(user.data['total_points'])
        
        if level_info['current']['level'] > user.data['current_level']:
            # ë ˆë²¨ì—…!
            self.supabase.table('notifications').insert({
                'user_id': user_id,
                'type': 'level_up',
                'title': f"ğŸ‰ {level_info['current']['name']} ë“±ê¸‰ ë‹¬ì„±!",
                'body': f"ì¶•í•˜í•©ë‹ˆë‹¤! {level_info['current']['emoji']} ë“±ê¸‰ì´ ë˜ì—ˆì–´ìš”!",
                'metadata': {
                    'new_level': level_info['current']['level'],
                    'level_name': level_info['current']['name'],
                },
                'created_at': datetime.now().isoformat(),
            }).execute()
            
            # í”„ë¡œí•„ ì—…ë°ì´íŠ¸
            self.supabase.table('user_profiles').update({
                'current_level': level_info['current']['level'],
                'level_name': level_info['current']['name'],
            }).eq('user_id', user_id).execute()
```

### [í•„ìˆ˜] ì ìˆ˜ í˜„í™© UI

```dart
// íŒŒì¼: lib/features/profile/point_status_widget.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class PointStatusWidget extends ConsumerWidget {
  const PointStatusWidget({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userProfile = ref.watch(userProfileProvider);
    
    return userProfile.when(
      data: (profile) => Card(
        margin: const EdgeInsets.all(16),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '${profile.levelEmoji} ${profile.levelName}',
                    style: const TextStyle(
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 6,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.orange.shade100,
                      borderRadius: BorderRadius.circular(16),
                    ),
                    child: Text(
                      '${profile.totalPoints}ì ',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        color: Colors.orange,
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              
              // ë ˆë²¨ ì§„í–‰ ë°”
              if (profile.nextLevel != null) ...[
                Text(
                  'ë‹¤ìŒ ë“±ê¸‰: ${profile.nextLevel!.emoji} ${profile.nextLevel!.name}',
                  style: TextStyle(
                    fontSize: 14,
                    color: Colors.grey[600],
                  ),
                ),
                const SizedBox(height: 8),
                LinearProgressIndicator(
                  value: profile.levelProgress,
                  backgroundColor: Colors.grey[200],
                  valueColor: AlwaysStoppedAnimation<Color>(Colors.orange),
                ),
                const SizedBox(height: 4),
                Text(
                  '${profile.pointsToNext}ì  ë” í•„ìš”í•´ìš”!',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey[600],
                  ),
                ),
              ],
              
              const SizedBox(height: 16),
              
              // ì˜¤ëŠ˜ì˜ í™œë™
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.grey[50],
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text(
                      'ì˜¤ëŠ˜ì˜ í™œë™',
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    _buildTodayActivity('í”¼ë“œ ë“±ë¡', profile.todayFeeds, 3),
                    _buildTodayActivity('ì¶”ì²œ í•˜ê¸°', profile.todayRecommendations, 1),
                    _buildTodayActivity('ë¶ë§ˆí¬', profile.todayBookmarks, 1),
                    if (profile.todayReactionBonus > 0)
                      _buildTodayActivity(
                        'ë°˜ì‘ ë³´ë„ˆìŠ¤',
                        1,
                        profile.todayReactionBonus,
                        isBonus: true,
                      ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (error, _) => Center(child: Text('ì˜¤ë¥˜: $error')),
    );
  }
  
  Widget _buildTodayActivity(
    String label,
    int count,
    int pointsPerItem, {
    bool isBonus = false,
  }) {
    final totalPoints = count * pointsPerItem;
    
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              Icon(
                isBonus ? Icons.star : Icons.check_circle_outline,
                size: 16,
                color: isBonus ? Colors.orange : Colors.green,
              ),
              const SizedBox(width: 8),
              Text(label),
              if (!isBonus) Text(' x$count', style: TextStyle(color: Colors.grey[600])),
            ],
          ),
          Text(
            '+$totalPointsì ',
            style: TextStyle(
              fontWeight: FontWeight.bold,
              color: isBonus ? Colors.orange : Colors.green,
            ),
          ),
        ],
      ),
    );
  }
}
```

## 5. ê²€ì¦ ì²´í¬ë¦¬ìŠ¤íŠ¸

### âœ… ë¶ë§ˆí¬ ê¸°ëŠ¥ ê²€ì¦
- [ ] ë¶ë§ˆí¬ ì¶”ê°€ ì‹œ +1ì  ì¦‰ì‹œ ì§€ê¸‰
- [ ] ë¶ë§ˆí¬ í•´ì œ ì‹œ -1ì  ì°¨ê°
- [ ] ë¶ë§ˆí¬ ëª©ë¡ ì •ìƒ í‘œì‹œ
- [ ] ë¶ë§ˆí¬ ìƒíƒœ ì‹¤ì‹œê°„ ë™ê¸°í™”
- [ ] ì§€ë„ì—ì„œ ë¶ë§ˆí¬ ë§ˆì»¤ í‘œì‹œ
- [ ] í”¼ë“œ ì‘ì„±ìì—ê²Œ ë¶ë§ˆí¬ ì•Œë¦¼

### âœ… 2ì‹œê°„ ì ê¸ˆ ì‹œìŠ¤í…œ ê²€ì¦
- [ ] í”¼ë“œ ë“±ë¡ ì‹œ 2ì‹œê°„ íƒ€ì´ë¨¸ ì‹œì‘
- [ ] ì ê¸ˆ ì¤‘ ì‚­ì œ ì‹œ ì ìˆ˜ ë¯¸ì§€ê¸‰
- [ ] ì ê¸ˆ í•´ì œ í›„ ìë™ ì ìˆ˜ ì§€ê¸‰
- [ ] ì ê¸ˆ ì‹œê°„ í‘œì‹œ ì •í™•ì„±
- [ ] ì„œë²„ ì‹œê°„ ê¸°ì¤€ ë™ì‘
- [ ] ì•± ì¢…ë£Œ í›„ì—ë„ íƒ€ì´ë¨¸ ìœ ì§€

### âœ… ì ìˆ˜ ê³„ì‚° ê²€ì¦
- [ ] ê¸°ë³¸ ë“±ë¡ ì ìˆ˜ 3ì 
- [ ] ìµœì´ˆ ë“±ë¡ ë³´ë„ˆìŠ¤ 10ì 
- [ ] OCR ì¶”ê°€ ë³´ë„ˆìŠ¤ 5ì 
- [ ] ì¶”ì²œ/ë¶ë§ˆí¬ ê° 1ì 
- [ ] ì¼ì¼ ë°˜ì‘ ë³´ìƒ 5~50ì 
- [ ] ë ˆë²¨ì—… ì‹œ ì•Œë¦¼ ë°œì†¡
- [ ] ì ìˆ˜ ì´ë ¥ ì¶”ì  ê°€ëŠ¥

### âœ… ì—£ì§€ ì¼€ì´ìŠ¤
- [ ] ë™ì‹œ ë‹¤ë°œì  í™œë™ ì‹œ ì ìˆ˜ ì •í™•ì„±
- [ ] ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ ì ìˆ˜ ë³´ì „
- [ ] ì¤‘ë³µ ì ìˆ˜ ì§€ê¸‰ ë°©ì§€
- [ ] ìŒìˆ˜ ì ìˆ˜ ë°©ì§€
- [ ] íŠ¸ëœì­ì…˜ ë¡¤ë°± ì²˜ë¦¬

### ğŸ” ëª¨ë‹ˆí„°ë§ í¬ì¸íŠ¸
- ë¹„ì •ìƒì ì¸ ì ìˆ˜ íšë“ íŒ¨í„´
- ì–´ë·°ì§• ì˜ì‹¬ í™œë™
- ì¼ì¼ ì ìˆ˜ íšë“ ë¶„í¬