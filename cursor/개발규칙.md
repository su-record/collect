# 🎯 개발 규칙 (통합 스택 버전 - Material Design 및 i18n/l10n 반영)

## 1. ⭐ 기본 원칙 (Basic Principles) ⭐

### 핵심 원칙 (Core Principles)

- **모든 응답은 한국어로 작성** (All responses must be in Korean)
- **코드 라인 수는 최소화** (Minimize lines of code - Less code = Less debt)
- **중복, 불필요한 코드, 불필요한 변경 금지** (Avoid duplication, unnecessary code, and unnecessary changes)
- **단일 책임 원칙 (SRP) 준수** (Follow Single Responsibility Principle)
    - **모든 코드 단위(함수, 클래스, 모듈, 컴포넌트/위젯, 마이크로서비스)는 한 가지 명확한 역할만 수행** (All code units should have a single, clear responsibility)
    - **Flutter 위젯:** UI 렌더링, 상태 관리, 또는 특정 로직 처리 중 하나의 주요 책임에 집중합니다.
    - **백엔드 함수/모듈 (Cloud Functions 등):** 단일 비즈니스 로직 또는 작업 처리에 집중합니다.
    - **함수:** 명확한 입력을 받아 예측 가능한 결과를 반환하며, 부수 효과(side effects)를 최소화합니다.
    - **유틸리티:** 특정 도메인 또는 공통 관심사의 문제만 해결합니다.
    - **상태 관리 로직 (Flutter, 백엔드):** 하나의 특정 상태나 관련된 상태 그룹, 또는 하나의 주요 사이드 이펙트만 관리합니다.

### 패키지/라이브러리 관리 (Package/Library Management)

- **새로운 패키지/라이브러리 추가는 최소화** (Minimize adding new packages/libraries)
    - **기존 프로젝트의 패키지/라이브러리 우선 사용** (Use existing project packages/libraries first)
    - **새로운 패키지 추가 시 반드시 검토 및 승인 필요** (라이선스, 보안, 유지보수성, 활성도 등 고려) (New package additions require review and approval)
    - **불필요한 의존성은 제거** (Remove unnecessary dependencies)
    - **언어별 의존성 관리 도구 활용:**
        - **Flutter/Dart:** `pubspec.yaml`을 통한 체계적인 관리
        - **Python:** `requirements.txt` 또는 `pyproject.toml` (Poetry/PDM 등)을 통한 관리
        - **Node.js:** `package.json`을 통한 관리

### 파일 및 디렉토리 관리 (File and Directory Management)

- **새로운 파일 생성 시 필수 확인사항** (Required checks when creating new files)
    - **파일 생성 전 사용될 위치 및 모듈 구조 확인** (Check where the file will be used and its place in module structure before creation)
    - **파일 생성 후 즉시 필요한 import/export 구문 추가** (Add necessary import/export statements immediately after file creation)
    - **import/export 경로가 올바른지, 절대/상대 경로 규칙을 따르는지 확인** (Verify the import/export path is correct and follows path rules)
    - **순환 참조가 발생하지 않는지 확인** (Check for circular dependencies, especially in Python and Node.js backends)
    - **기능/도메인별 디렉토리 구조 권장** (Organize directories by feature/domain, not just by code type, for cohesion)

## 2. 💻 통합 개발 원칙 (Unified Development Principles)

### 🎨 UI/UX 원칙 (Flutter Focus)

- **Material Design 가이드라인 준수 (Adhere to Material Design Guidelines):**
    - Flutter UI 개발 시 Google의 **Material Design 시스템 ([material.io](https://material.io/))**을 적극 활용하여 일관되고 직관적인 사용자 경험(UX)을 제공합니다.
    - **기본 제공 Material 위젯** (예: `Scaffold`, `AppBar`, `FloatingActionButton`, `Card`, `TextFormField`, `ElevatedButton`, `TextButton`, `OutlinedButton` 등)을 우선적으로 사용하고, 필요시 커스터마이징합니다.
    - **`ThemeData`를 활용**하여 앱 전체의 색상 팔레트(primary, secondary, accent colors), 타이포그래피(폰트, 크기, 두께), 모양(shape), 아이콘 테마 등을 일관되게 관리합니다.
    - **반응형 UI 설계**를 고려하여 다양한 화면 크기(모바일, 태블릿), 해상도 및 방향(가로/세로)에 적절히 대응합니다. (`MediaQuery`, `LayoutBuilder`, `FittedBox` 등 활용)
    - 사용자 인터랙션 및 애니메이션은 Material Design의 원칙에 부합하도록 자연스럽고 의미 있게 적용합니다.

### 📖 가독성 & 네이밍 (Readability & Naming)

- **매직 넘버/문자열을 명명된 상수로 교체**하여 명확성 향상 (Replace magic numbers/strings with named constants for clarity)
    - 예: `const DEFAULT_TIMEOUT_SECONDS = 30;` (Dart/JS), `DEFAULT_TIMEOUT_SECONDS = 30` (Python)
- **복잡한 불리언 조건을 명명된 변수/함수에 할당** (Assign complex boolean conditions to named variables/functions)
- **조건의 의미를 명시적으로 표현** (Explicitly express the meaning of conditions)
- **네이밍 컨벤션 준수:**
    - **변수명은 주로 명사, 함수/메서드명은 주로 동사로 시작** (Variables mainly nouns, functions/methods mainly start with verbs)
    - **Flutter 이벤트 핸들러:** `onEventName` 또는 `handleEventName` 접두사 권장 (e.g., `onPressed`, `handleTap`)
    - **불리언 변수/함수:** `is`, `has`, `can`, `should` 등으로 시작 권장
    - **각 언어별 네이밍 컨벤션 준수:**
        - **Dart/Flutter:** `lowerCamelCase` (변수, 함수), `UpperCamelCase` (클래스, enum, 확장)
        - **Python:** `snake_case` (변수, 함수, 모듈), `PascalCase` (클래스)
        - **Node.js (JavaScript/TypeScript):** `camelCase` (변수, 함수), `PascalCase` (클래스)
- **Flutter 위젯 네이밍:** `UpperCamelCase`를 사용하며, 위젯의 역할과 시각적 표현을 명확히 드러내는 이름을 사용합니다. (예: `UserProfileCard`, `OrderConfirmationDialog`)
- **주석은 '왜(Why)'를 설명해야 하며, '무엇(What)'을 설명하지 않아야 함** (Comments should explain 'why', not 'what', unless the 'what' is very complex)
- **주석은 코드와 함께 최신 상태로 유지되어야 함** (Comments should be updated along with the code)

### ✨ 코드 구조 & 간결성 (Code Structure & Conciseness)

- **복잡한 조건부 로직/UI 분리:**
    - **Flutter:** 복잡한 조건부 UI는 별도의 위젯으로 분리합니다.
    - **백엔드 (Python/Node.js):** 복잡한 조건부 로직은 별도의 함수/메서드로 분리합니다.
- **Flutter 위젯 분리:**
    - 복잡한 UI는 재사용 가능하고 관리하기 쉬운 작은 위젯으로 분리합니다.
    - 특히, **Material Design의 구성 요소(components) 개념을 참고**하여 위젯을 모듈화합니다.
    - `build` 메서드가 너무 길어지지 않도록 주의하고, 로직과 UI 표현을 적절히 분리합니다.
- **각 전문화된 단위(위젯, 함수, 클래스)가 명확한 단일 책임을 가지도록 함** (Ensure each specialized unit has a clear, single responsibility)
- **과도하게 중첩된 제어문(if/else, for, while) 지양**, 함수/메서드 분리 고려 (Avoid excessively nested control statements)
- **불필요한 코드와 중복을 제거** (Remove unnecessary code and duplication)
    - **Helper/Utility 함수/클래스 적극 활용**
- **복잡한 로직은 함수/메서드로 분리하고 단순화** (Separate and simplify complex logic into functions/methods)
- **코드의 가독성과 유지보수성을 향상** (Improve code readability and maintainability)

### 🔮 예측 가능성 (Predictability)

- **유사한 함수/메서드/API 엔드포인트에 대해 일관된 인터페이스 및 반환 타입/구조 사용** (Use consistent interfaces and return types/structures for similar functions/methods/API endpoints)
- **개발자가 반환 값 형태를 예측할 수 있도록 함** (Allow developers to predict return value shapes)
- **숨겨진 로직 드러내기 (Revealing Hidden Logic):**
    - **숨겨진 부작용 방지; 함수/메서드는 시그니처에서 암시하는 작업만 수행** (Avoid hidden side effects; functions/methods should only perform actions implied by their signature)
    - **단일 책임 원칙(SRP)을 통한 예측 가능한 동작** (Predictable behavior through Single Responsibility Principle)
- **고유하고 설명적인 이름 (Unique and Descriptive Names):**
    - **커스텀 래퍼/함수/클래스/위젯에 고유하고 설명적인 이름 사용** (Use unique and descriptive names for custom wrappers/functions/classes/widgets)
    - **모호함을 방지하고 예측 가능성 향상** (Avoid ambiguity and enhance predictability)

### 🤝 응집성 (Cohesion)

- **기능/도메인별 코드 구성** (Organize directories by feature/domain, not just by code type across all layers - Frontend, Backend, Shared)
- **관련 파일들을 함께 유지하여 응집성 증가** (Keep related files together to increase cohesion)
- **매직 넘버/문자열과 로직 연관성:**
    - **관련 로직 근처에 상수 정의**하거나 이름으로 명확한 연결 보장 (Define constants near related logic or ensure names clearly link them)

### 🔗 결합도 최소화 (Coupling Minimization)

- **추상화와 결합도 균형 (Balancing Abstraction and Coupling):**
    - **사용 사례가 분기될 수 있다면 성급한 추상화 방지** (Avoid premature abstraction if use cases might diverge)
    - **낮은 결합도를 위해 일부 제어된 중복 허용 가능** (Allow some controlled duplication for lower coupling)
- **상태 관리 범위 지정 (Scoping State Management):**
    - **Flutter:** Provider, Riverpod, BLoC/Cubit 등을 사용하여 상태 관리 범위를 명확히 하고 필요한 위젯에만 노출합니다.
    - **백엔드:** Cloud Functions 간 상태 공유 시 Firestore, Pub/Sub, Memorystore 등 외부 저장소/메시징 서비스를 활용하고, 각 함수는 필요한 데이터에만 접근합니다.
- **의존성 전달 최소화:**
    - **Flutter:** 위젯 트리에서의 깊은 의존성 전달(prop drilling)을 피하고, 상태 관리 솔루션이나 의존성 주입(DI)을 활용합니다.
    - **백엔드:** 함수/서비스 간 직접적인 과도한 의존성을 피하고, 필요시 인터페이스나 메시지 큐를 통한 간접적 통신을 고려합니다.
- **불필요한 의존성 제거 (Eliminate Unnecessary Dependencies):**
    - **모듈/컴포넌트/위젯 간 불필요한 의존성 최소화** (Minimize unnecessary dependencies between modules/components/widgets)
    - **함수/메서드에는 정말 필요한 매개변수만 전달** (Pass only truly necessary parameters)

### 🎯 디자인 패턴 (Design Patterns)

- **각 플랫폼 및 언어 특성에 맞는 적절한 디자인 패턴 적용** (Apply appropriate design patterns suitable for each platform and language)
    - **Flutter (Material Design 기반):**
        - **위젯 구성:** **Composite 패턴** (선언적 UI). 다양한 Material 위젯들을 조합하여 복잡한 UI를 구성합니다.
        - **상태 관리:** **Observer 패턴** (Provider, Riverpod 등), **BLoC/Cubit** (명령과 상태 분리). Material 위젯들은 이러한 상태 관리 패턴과 자연스럽게 연동됩니다.
        - **위젯 생성:** **Factory 패턴** (조건에 따라 다른 Material 위젯 반환), **Builder 패턴** (컨텍스트에 따라 동적으로 Material 위젯 구성).
        - **스타일 및 테마:** `ThemeData`와 `copyWith`를 활용하여 Material Design 테마를 확장하고 일관성을 유지합니다.
    - **백엔드 (Python/Node.js):**
        - **요청 처리:** Strategy (다양한 요청 유형 처리), Chain of Responsibility (미들웨어)
        - **객체 생성:** Factory, Builder (복잡한 객체 생성)
        - **구조:** Adapter (외부 서비스/라이브러리 연동), Decorator (기능 확장)
        - **행동:** Observer (이벤트 기반 처리, Pub/Sub 연동), Template Method (작업 흐름 정의)
- **디자인 패턴은 과도하게 사용하지 않음** (Do not overuse design patterns)
    - **단순한 경우에는 패턴 적용을 지양** (Avoid applying patterns in simple cases)
    - **패턴 적용 시 코드 복잡도 증가 및 성능 영향 고려** (Consider code complexity and performance impact when applying patterns)
    - **패턴의 장단점을 충분히 검토 후 적용** (Apply patterns after thorough review of pros and cons)

#### 📋 빠른 참조 (Quick Reference) - (예시이며, 프로젝트 상황에 따라 우선순위 조정)

##### 🔥 높은 우선순위 (High Priority)

- **Flutter:**
    - **Observer 패턴 (Provider, Riverpod 등)** - 상태 관리
    - **Composite 패턴** - Material 위젯 기반 UI 트리 구성
- **백엔드:**
    - **Factory/Builder 패턴** - 객체/응답 생성
    - **Adapter 패턴** - 외부 API/서비스 연동 (예: Vision API, Maps API)

##### ⚡ 중간 우선순위 (Medium Priority)

- **Flutter:**
    - **Strategy 패턴** - 조건부 로직/UI 처리 (예: 상태에 따라 다른 Material 아이콘/버튼 표시)
    - **Builder 패턴** - 동적 Material 위젯 생성 (예: `ListView.builder` 와 함께 사용)
- **백엔드:**
    - **Strategy 패턴** - 다양한 비즈니스 로직 분기 처리
    - **Decorator 패턴** - Cloud Function 등에 공통 기능(로깅, 인증) 추가 (미들웨어 형태로 구현 가능)

##### 💡 낮은 우선순위 (Low Priority)

- (프로젝트 복잡도에 따라 선택적 사용)

##### 사용 가이드라인 (Usage Guidelines)

- **단순한 경우 (Simple Cases):** 패턴 사용 지양, 직접 구현
- **복잡한 경우 (Complex Cases):** 적절한 패턴 선택 후 적용
- **성능 고려 (Performance Consideration):** 패턴 적용 시 성능 영향 검토 (특히 Flutter UI, 백엔드 응답 시간)
- **테스트 용이성 (Testability):** 패턴이 테스트를 복잡하게 만들지 않는지 확인

#### 예시 코드 참고:

```dart
// Flutter: Composite 패턴 + Material 위젯 예시
// Card 위젯을 사용하여 정보를 표시하는 사용자 정의 위젯
import 'package:flutter/material.dart'; // Material 라이브러리 import

class UserInfoCard extends StatelessWidget {
  final String userName;
  final String userEmail;
  final VoidCallback? onEdit;

  const UserInfoCard({
    Key? key,
    required this.userName,
    required this.userEmail,
    this.onEdit,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Material Card 위젯 사용
    return Card(
      elevation: 4.0, // Material Design 그림자 효과
      margin: const EdgeInsets.all(16.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            Text(
              userName,
              // Material 테마의 텍스트 스타일 사용
              style: Theme.of(context).textTheme.headline6,
            ),
            const SizedBox(height: 8.0),
            Text(
              userEmail,
              style: Theme.of(context).textTheme.subtitle1,
            ),
            if (onEdit != null) ...[
              const SizedBox(height: 16.0),
              Align(
                alignment: Alignment.centerRight,
                // Material TextButton 사용
                child: TextButton.icon(
                  icon: const Icon(Icons.edit), // Material 아이콘
                  label: const Text('수정'),
                  onPressed: onEdit,
                ),
              ),
            ]
          ],
        ),
      ),
    );
  }
}

// 사용 예시
// UserInfoCard(
//   userName: "홍길동",
//   userEmail: "gildong@example.com",
//   onEdit: () { print("Edit tapped"); },
// )
```

```dart
// Flutter: Observer 패턴 (Provider 예시) + Material 위젯
// Counter 모델 (ChangeNotifier)
import 'package:flutter/foundation.dart'; // ChangeNotifier를 위해 import
import 'package:flutter/material.dart'; // Material 위젯을 위해 import
import 'package:provider/provider.dart'; // Provider를 위해 import

class Counter extends ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners(); // 구독자(Consumer, Selector 등)에게 알림
  }

  void decrement() {
    _count--;
    notifyListeners();
  }
}

// 예시 UI 부분
class CounterControls extends StatelessWidget {
  const CounterControls({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer<Counter>(
      builder: (context, counter, child) {
        return Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            // Material IconButton 사용
            IconButton(
              icon: const Icon(Icons.remove_circle_outline),
              onPressed: () => counter.decrement(),
              tooltip: '감소',
              color: Theme.of(context).primaryColor,
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text(
                '${counter.count}',
                style: Theme.of(context).textTheme.headline4,
              ),
            ),
            IconButton(
              icon: const Icon(Icons.add_circle_outline),
              onPressed: () => counter.increment(),
              tooltip: '증가',
              color: Theme.of(context).primaryColor,
            ),
          ],
        );
      },
    );
  }
}

// main.dart 또는 적절한 위치에 Provider 설정
// ChangeNotifierProvider(
//   create: (_) => Counter(),
//   child: MaterialApp(
//     home: Scaffold(
//       appBar: AppBar(title: Text('Material Counter')),
//       body: Center(child: CounterControls()),
//     ),
//   ),
// )
```

```python
# Python (Backend): Factory 패턴 예시
class DocumentProcessor:
    def process(self, content):
        raise NotImplementedError

class TextProcessor(DocumentProcessor):
    def process(self, content):
        # 텍스트 처리 로직 (예: Natural Language API 호출)
        # 실제 구현 시 Google Cloud Natural Language API 클라이언트 사용
        print(f"Processing text content (first 30 chars): {content[:30]}...")
        return f"Processed Text: {content[:30]}..."

class ImageProcessor(DocumentProcessor):
    def process(self, content_bytes): # 이미지 내용은 바이트로 가정
        # 이미지 처리 로직 (예: Vision API 호출)
        # 실제 구현 시 Google Cloud Vision API 클라이언트 사용
        print(f"Processing image content (bytes): {len(content_bytes)}")
        return f"Processed Image: {len(content_bytes)} bytes"

def get_document_processor(file_type: str) -> DocumentProcessor:
    if file_type.lower() == "txt":
        return TextProcessor()
    elif file_type.lower() in ["jpg", "jpeg", "png"]:
        return ImageProcessor()
    else:
        raise ValueError(f"Unsupported file type: {file_type}")

# 사용 예시
# try:
#   processor = get_document_processor("txt")
#   result = processor.process("Some long text content for processing...")
#   print(result)

#   # 이미지 파일이 있다고 가정 (예시용)
#   # with open("example.jpg", "rb") as img_file:
#   #   image_bytes = img_file.read()
#   #   image_processor = get_document_processor("jpg")
#   #   image_result = image_processor.process(image_bytes)
#   #   print(image_result)
# except ValueError as e:
#   print(e)
```

#### 문제 해결 예시 (Problem Solving Examples)

##### 1. 상태 관리 문제 (Flutter State Management Problem)

-   **문제:** 여러 위젯에서 동일한 사용자 인증 상태 공유 필요
-   **해결:** Provider/Riverpod와 같은 상태 관리 솔루션 활용. `ChangeNotifier`와 `Consumer`/`Selector` (Provider) 또는 `StateNotifier`와 `StateNotifierProvider` (Riverpod)를 사용하여 반응형으로 상태를 관리하고 UI에 반영합니다. (위 Counter 예시 참고)

##### 2. 성능 최적화 문제 (Performance Optimization Problem)

-   **Flutter:**
    -   `const` 위젯 적극 사용으로 불필요한 리빌드 방지
    -   `ListView.builder`, `GridView.builder` 등 효율적인 목록 렌더링 위젯 사용
    -   `RepaintBoundary`를 사용하여 변경이 잦은 부분과 정적인 부분을 분리
    -   `compute` 함수를 사용하여 무거운 연산 작업을 별도의 isolate에서 처리하여 UI 버벅임 방지
    -   Flutter `DevTools`를 사용하여 위젯 리빌드, CPU 프로파일링, 메모리 사용량 등 분석 및 최적화
-   **백엔드 (Python/Node.js):**
    -   **비동기 처리:** Python `asyncio` (`async/await`), Node.js `async/await` 적극 활용하여 I/O 바운드 작업 효율화
    -   **DB 쿼리 최적화:** Firestore 인덱싱 활용, 필요한 필드만 조회(`select`), 데이터 로드 최소화 (N+1 문제 방지)
    -   **캐싱 전략:** 자주 사용되지만 변경이 적은 데이터에 대해 Firestore 데이터 캐싱, API 응답 캐싱 (Cloud CDN, Memorystore 등) 고려
    -   **Cloud Functions 콜드 스타트 최소화:** 최소 인스턴스 설정 (요청량에 따라), 의존성 패키지 크기 최적화, 전역 변수 초기화 활용

##### 3. 에러 처리 문제 (Error Handling Problem)

-   **Flutter:**
    -   비동기 작업 시 `try-catch` 블록 사용, `Future`의 `catchError` 메서드 활용
    -   `Result` 타입 (성공/실패 객체 분리) 패턴 사용 고려 (패키지: `multiple_result`, `dartz` 등)하여 에러 상태 명시적 관리
    -   사용자에게 친화적인 에러 메시지 표시 (예: `SnackBar`, `AlertDialog` 사용)
    -   필요시 에러 로깅 서비스 연동 (예: Firebase Crashlytics)
-   **백엔드 (Cloud Functions 등):**
    -   **일관된 에러 응답 형식 정의:** HTTP 상태 코드, 내부 에러 코드, 사용자 친화적 메시지 포함
    -   `try-catch` 블록을 사용하여 예상되는 에러 처리, 전역 에러 핸들러 (Express.js 미들웨어 등) 설정으로 예외 일괄 처리
    -   **Google Cloud Logging을 통한 상세 에러 로깅** (스택 트레이스, 요청 정보 포함) 및 Error Reporting 서비스 연동
    -   **비동기 작업의 에러 전파** 확실히 처리하여 호출자에게 정확한 에러 정보 전달

## 3. ☁️ 클라우드 환경 개발 원칙 (Cloud Environment Development Principles)

### 리소스 관리 (Resource Management)

- **리소스 네이밍 컨벤션 통일:** 프로젝트 전체에 일관된 규칙 적용 (예: `[project]-[service]-[env]-[name]`)
- **IaC (Infrastructure as Code) 도입 고려:** Terraform, Google Cloud Deployment Manager 등을 사용하여 인프라 구성 관리
- **비용 최적화 마인드셋:**
    - 각 GCP 서비스의 과금 모델 이해 (Firestore 읽기/쓰기/저장, Cloud Functions 실행 시간/호출 수, Cloud Run vCPU/메모리 등)
    - 불필요한 리소스는 즉시 정리 또는 중지
    - 적절한 머신 타입, 스토리지 클래스 선택
- **Region 및 Zone 선택:** 지연 시간, 비용, 가용성 요구사항 고려

### 보안 (Security)

- **IAM (Identity and Access Management) 최소 권한 원칙 준수:** 사용자, 서비스 계정에 필요한 최소한의 권한만 부여
- **API 키, 인증서, 비밀번호 등 민감 정보 관리:**
    - **Google Secret Manager** 적극 활용
    - 환경 변수를 통해 주입 (Cloud Run, Cloud Functions)
    - 코드에 직접 하드코딩 금지
- **네트워크 보안:**
    - **Firebase Security Rules (Firestore, Storage):** 데이터 접근 권한 철저히 관리
    - **Cloud Functions/Cloud Run:** 인그레스(Ingress) 설정으로 호출자 제한, VPC 커넥터 사용 고려
    - **API Gateway 활용:** API 인증, 권한 부여, 속도 제한 등
- **데이터 암호화:** 저장 데이터(at-rest) 및 전송 중 데이터(in-transit) 암호화 확인 (GCP 기본 제공 활용)

### API 설계 (Backend API Design)

- **RESTful API 설계 원칙 준수** 또는 GraphQL 등 상황에 맞는 방식 선택
- **일관된 요청/응답 구조 및 HTTP 상태 코드 사용**
- **API 버전 관리 전략 수립** (URL 경로, 헤더 등)
- **문서화:** OpenAPI (Swagger) 등을 활용한 API 명세 자동화 및 관리

### 로깅 및 모니터링 (Logging & Monitoring)

- **Google Cloud's operations suite (Logging, Monitoring, Trace, Error Reporting) 적극 활용**
- **구조화된 로그(JSON 형식 등) 작성:** 분석 및 검색 용이성 증대
- **주요 지표(에러율, 응답 시간, 리소스 사용량 등)에 대한 대시보드 및 알림 설정**
- **분산 추적(Cloud Trace)을 활용한 서비스 간 호출 흐름 분석** (특히 마이크로서비스 아키텍처)

### 서비스 간 통신 (Inter-Service Communication)

- **동기식 vs 비동기식 통신 선택:**
    - **동기식:** 직접 HTTP 호출 (응답 즉시 필요시). API Gateway, 내부 Load Balancer 등 활용.
    - **비동기식:** **Pub/Sub** 등을 활용한 이벤트 기반 아키텍처. 서비스 간 결합도 낮춤, 탄력성 증대.
- **Firestore 변경 사항 감지 (Cloud Functions Triggers)**를 활용한 이벤트 기반 로직 구현

## 4. 🔄 코드 변경 (Code Changes)

- **반드시 "관련된 코드"만 최소한으로 변경** (Only modify related code minimally)
    - 변경 전에 코드의 영향 범위를 정확히 파악 (Understand the scope of changes before making them)
    - 변경 후에는 코드가 원래 의도대로 동작하는지 확인 (단위 테스트, 통합 테스트, UI 테스트) (Verify that the code works as intended after changes)
- **코드 스타일, 네이밍, 주석 등은 특별 요청 없으면 프로젝트 전체의 일관성을 해치지 않는 선에서 변경** (Do not change code style, naming, comments, etc. without special request, unless it harms project-wide consistency)
    - 코드 스타일은 각 언어/프레임워크의 Linter 및 Formatter 설정(예: Flutter `analysis_options.yaml`, Python `flake8`/`black`, Node.js `ESLint`/`Prettier`)을 따름
- **Flutter UI 변경 시:** Material Design 가이드라인 및 앱 전체 테마와의 일관성을 고려합니다.
- **리팩토링/정리/불필요한 삭제는 목적과 범위를 명확히 하고, 리뷰를 거쳐 진행** (Refactoring, cleanup, or unnecessary deletion should have clear purpose and scope, and go through review)
- **변경 전후 체크리스트(필요성, 영향, 최소범위, 부작용, 테스트 커버리지 등) 반드시 확인** (Always verify pre/post change checklist - necessity, impact, minimal scope, side effects, test coverage)
- **예시 코드 작성 시 프로젝트의 코드 스타일 및 아키텍처 패턴을 기반으로 작성** (Write example code based on the project's code style and architectural patterns)
- **모든 주요 변경 사항은 버전 관리 시스템(Git)에 의미 있는 커밋 메시지와 함께 기록**

## 5. 📝 문서화 (Documentation)

- **코드 내 주석:**
    - **함수/클래스/모듈 시작에 기능, 매개변수, 반환값 등을 명시하는 주석 작성** (Dart Doc, Python Docstrings, JSDoc/TSDoc 등 각 언어 표준 활용)
    - **복잡한 로직, 비즈니스 규칙, 특정 결정의 배경 설명**
- **Flutter 위젯 문서화:**
    - 위젯의 목적, 주요 속성(props), 사용된 주요 Material 위젯, 상태 관리 의존성 등을 Dart Doc 스타일로 작성합니다.
    - 필요한 경우 간단한 사용 예시(스토리북 형태 또는 코드 스니펫)를 포함할 수 있습니다.
- **버그/비효율/개선점 발견 시 "TODO:", "FIXME:", "OPTIMIZE:" 등으로 명확히 표시**하고, 가능하면 이슈 트래커에 등록
    - 주석에는 문제의 원인, 제안 해결 방법, 담당자(선택) 명시
- **README 파일:** 프로젝트 개요, 설정 방법, 실행 방법, 주요 아키텍처, 디렉토리 구조 등 기술
- **API 문서 (백엔드):** OpenAPI (Swagger) 등으로 명세 관리
- **클라우드 아키텍처 다이어그램 및 주요 설정값 문서화**
- **코드의 변경 이력과 이유는 버전 관리 시스템(커밋 메시지) 및 이슈 트래커를 통해 기록**
- **테스트 전략 및 결과 요약 문서화 (필요시)**

## 6. 🔍 문제 해결 (Problem Solving)

- **문제를 단계별로 분석 → (필요시) 의사코드 작성 → 해결 계획 수립 및 검토 → 코드 작성 → 테스트 및 검증 (Chain of Thought)**
    - 문제를 작은 단위로 나누어 분석 (Divide and conquer)
    - 가설 수립 및 검증 과정 반복
- **문제 해결 시 다양한 접근 방법을 고려** (Consider various approaches when solving problems)
    - 여러 해결 방법을 비교하고 장단점(성능, 복잡도, 유지보수성, 비용 등)을 고려하여 최적의 방법 선택
    - 동료 개발자와의 논의 및 코드 리뷰 적극 활용
- **문제 해결 후 코드의 효율성, 가독성, 확장성, 테스트 커버리지 검토**
    - 시간/공간 복잡도 고려 (특히 알고리즘, 데이터 처리)
    - GCP 서비스 사용 시 관련 비용 및 할당량(quota) 영향 검토
- **디버깅 도구 적극 활용:** 각 IDE의 디버거, Flutter DevTools, Chrome DevTools, GCP Logging/Monitoring 등

## 7. 📊 데이터 흐름 (Data Flow)

- **데이터 흐름 우선순위 (일반적인 예시):**
    1.  **외부 시스템/사용자 입력** (Flutter UI, 외부 API 호출 등)
    2.  **(프론트엔드) 입력 유효성 검사 및 전처리**
    3.  **API 호출 (Flutter -> Backend)**
    4.  **(백엔드) 요청 수신 및 인증/인가**
    5.  **(백엔드) 입력 유효성 검사 및 비즈니스 로직 처리** (필요시 Firestore, Vision API, Maps API 등 GCP 서비스 연동)
    6.  **(백엔드) 데이터베이스 CRUD (Firestore 등)**
    7.  **(백엔드) 응답 생성**
    8.  **API 응답 (Backend -> Flutter)**
    9.  **(프론트엔드) 응답 처리 및 상태 업데이트 (Provider, Riverpod 등)**
    10. **(프론트엔드) UI 렌더링** (Material 위젯 사용)
    11. **(비동기/이벤트 기반) Pub/Sub 메시지 발행 -> 구독하는 Cloud Function 처리 -> Firestore 업데이트 -> (실시간) Flutter UI 업데이트**

- **코드 정렬 및 구성 원칙:**
    - **데이터 흐름의 논리적 순서에 따라 코드 배치 고려** (예: Flutter 위젯 내 build 메서드, 백엔드 API 핸들러 내 로직 순서)
    - **관련된 로직은 응집도 높게 그룹화** (클래스, 모듈, 함수)
    - **각 계층(Presentation, Application, Domain, Infrastructure) 또는 기능 단위별 명확한 책임 분리**
- **데이터 의존성:**
    - **데이터 처리 파이프라인에서 상위(선행) 데이터가 하위(후행) 데이터보다 먼저 처리되도록 보장**
    - **데이터 의존성을 명확히 문서화하거나 코드 구조로 표현**
    - **순환 의존성 방지** (특히 모듈, 서비스 간)
    - **Firestore 데이터 모델 설계 시 데이터 중복과 정규화 사이의 균형 고려** (읽기 패턴 최적화)

## 8. ➕ 추가 고려 사항 및 가이드라인

### 🧪 테스트 규칙 (Test Guidelines)

-   **단위 테스트 (Unit Tests):**
    -   **Flutter:** 위젯 로직, 상태 관리 클래스(Notifier, BLoC/Cubit), 유틸리티 함수 등 개별 단위에 대한 테스트 작성. `flutter_test` 패키지 활용.
    -   **백엔드 (Python/Node.js):** 개별 함수, 클래스, 모듈의 로직 검증. Python `unittest`/`pytest`, Node.js `Jest`/`Mocha` 등 활용.
    -   테스트 커버리지 목표 설정 및 유지 노력 (예: 중요 모듈 80% 이상).
-   **위젯 테스트 (Widget Tests - Flutter):**
    -   개별 위젯의 UI, 인터랙션, 상태 변화에 따른 렌더링 검증. `flutter_test` 패키지의 `WidgetTester` 활용.
    -   Material 위젯과의 상호작용 및 테마 적용 여부 테스트 포함.
-   **통합 테스트 (Integration Tests):**
    -   여러 컴포넌트/모듈/서비스가 함께 동작하는 방식 검증.
    -   **Flutter:** `integration_test` 패키지 활용. 실제 기기나 에뮬레이터에서 앱의 특정 기능 흐름 테스트.
    -   **백엔드:** 여러 Cloud Functions 또는 서비스 간의 API 호출 및 데이터 흐름 테스트. 필요시 Mock 객체 활용.
-   **E2E (End-to-End) 테스트 (필요시):**
    -   사용자 시나리오 기반으로 전체 시스템(프론트엔드-백엔드-DB) 검증.
-   **테스트 데이터 관리:** 일관되고 재현 가능한 테스트를 위한 테스트 데이터 관리 방안 수립.

### 🧐 코드 리뷰 가이드라인 (Code Review Guidelines)

-   **리뷰 범위:** 기능 구현 정확성, 설계 적절성, 가독성, 성능, 보안, 테스트 코드, 문서화 등.
-   **중점 사항:**
    -   개발 규칙 준수 여부.
    -   버그 발생 가능성, 엣지 케이스 처리.
    -   중복 코드, 불필요한 복잡성.
    -   명확한 네이밍, 이해하기 쉬운 로직.
-   **피드백 방식:** 건설적이고 구체적인 피드백. 질문 형태로 제안 권장. "왜"를 설명.
-   **PR (Pull Request) 템플릿:** 변경 사항 요약, 테스트 방법, 관련 이슈 등을 포함하는 PR 템플릿 사용.
-   **최소 1명 이상의 리뷰어 승인 후 머지 (프로젝트 규모에 따라 조정).**

### 🌿 브랜치 전략 및 버전 관리 (Branching Strategy & Version Control)

-   **브랜치 모델:** Gitflow, GitHub flow, 또는 프로젝트에 맞는 간소화된 모델 선택.
    -   예: `main` (또는 `master`), `develop`, `feature/[feature-name]`, `release/[version]`, `hotfix/[issue-number]`
-   **커밋 메시지 컨벤션:** Conventional Commits ([https://www.conventionalcommits.org/](https://www.conventionalcommits.org/)) 또는 팀 내 합의된 규칙 사용. (예: `feat: 새로운 기능 추가`, `fix: 버그 수정`, `docs: 문서 변경`)
    -   커밋 메시지는 변경 사항을 명확히 설명하고, 관련 이슈 번호 포함.
-   **정기적인 `develop` 브랜치 동기화 (rebase 또는 merge).**

### 🛡️ 보안 코딩 가이드라인 (Secure Coding Guidelines)

-   **입력값 검증 (Input Validation):** 모든 외부 입력(사용자 입력, API 요청 등)은 프론트엔드와 백엔드 양쪽에서 철저히 검증. (타입, 길이, 형식, 범위 등)
-   **출력 인코딩 (Output Encoding):** XSS(Cross-Site Scripting) 방지를 위해 동적 데이터를 UI에 표시할 때 적절한 인코딩/이스케이핑 처리. (Flutter는 기본적으로 위젯에서 처리)
-   **안전한 API 사용:** GCP 서비스 및 외부 라이브러리 사용 시 보안 권장 사항 준수.
-   **인증 및 권한 부여:** Firebase Auth 및 IAM 규칙을 통해 강력한 인증 및 세분화된 권한 관리.
-   **민감 정보 보호:** API 키, 비밀번호 등은 Secret Manager에 저장하고, 로그에 민감 정보 출력 금지.
-   **의존성 보안:** 정기적으로 라이브러리/패키지의 보안 취약점 점검 및 업데이트.
-   **OWASP Top 10 및 각 플랫폼별 보안 가이드라인 참고.**

### ⚡ 성능 최적화 가이드라인 (Performance Optimization Guidelines)

-   **Flutter:**
    -   `build` 메서드 최적화: 조건부 로직 최소화, `const` 위젯 활용, 위젯 분리.
    -   이미지 최적화: 적절한 형식(WebP 등) 사용, 해상도 최적화, 캐싱.
    -   애니메이션 최적화: 불필요한 애니메이션 자제, `AnimatedBuilder` 등 효율적인 위젯 사용.
    -   상태 관리 솔루션의 효율적 사용: 불필요한 위젯 리빌드 방지.
-   **백엔드 (Cloud Functions/Run):**
    -   콜드 스타트 최적화: 함수 메모리/CPU 설정, 전역 스코프 활용, 의존성 최소화.
    -   비동기 작업 병렬 처리 (필요시).
    -   데이터베이스 쿼리 최적화 (인덱싱, 배치 작업).
    -   캐싱 전략 적극 활용 (인메모리 캐시, Memorystore, CDN).
-   **성능 테스트:** 정기적인 성능 측정 및 병목 지점 분석 (Flutter DevTools, GCP Monitoring, 부하 테스트 도구).

### 🌍 국제화(i18n) 및 지역화(l10n) 가이드라인 (Flutter)

-   **기본 프레임워크:**
    -   Flutter의 공식 국제화 지원 라이브러리인 `flutter_localizations` 패키지를 사용하고, `MaterialApp` 또는 `CupertinoApp`에 `localizationsDelegates`와 `supportedLocales`를 설정합니다.
    -   앱 내 사용자 정의 문자열 관리는 `intl` 패키지를 사용합니다. 모든 UI 텍스트, 메시지 등은 하드코딩하지 않고 `intl`을 통해 지역화된 문자열을 참조합니다.
-   **문자열 리소스 관리:**
    -   지역화될 문자열은 **`.arb` (Application Resource Bundle) 파일 형식**으로 관리합니다. 각 지원 언어별로 별도의 `.arb` 파일을 생성합니다. (예: `lib/l10n/app_en.arb`, `lib/l10n/app_ko.arb`)
    -   키(key) 이름은 명확하고 일관성 있게 정의합니다.
    -   `intl_utils` 또는 IDE 플러그인(VS Code의 "Flutter Intl" 등)을 활용하여 `.arb` 파일로부터 Dart 코드를 자동으로 생성하고 관리합니다.
-   **번역 관리 및 자동화 (Google 서비스 활용 옵션):**
    -   **(권장) Google Sheets 활용:**
        -   번역 문자열 관리를 위해 Google Sheets를 중앙 저장소로 사용할 수 있습니다. (컬럼: `key`, `en_US`, `ko_KR` 등)
        -   Google Apps Script 또는 별도 스크립트를 통해 Google Sheets의 내용을 각 언어별 `.arb` 파일로 자동 변환하고 프로젝트에 통합하는 워크플로우 구축을 고려합니다. 이를 통해 번역가/기획자와의 협업이 용이해집니다.
    -   **(보조적) Google Cloud Translation API 활용:**
        -   초기 대량 번역 또는 새로운 언어 추가 시 Google Cloud Translation API를 보조적으로 사용할 수 있습니다.
        -   **주의:** API를 통해 생성된 번역은 반드시 **원어민 또는 전문 번역가의 검토 및 수정 과정**을 거쳐야 합니다. 기계 번역의 품질 한계를 인지하고 사용합니다.
        -   번역된 결과는 최종적으로 `.arb` 파일 형식으로 관리합니다.
-   **동적 문자열 업데이트 (선택적/제한적 사용):**
    -   앱 업데이트 없이 특정 문자열을 긴급하게 수정해야 하거나, A/B 테스트 등을 위해 동적으로 문자열을 변경해야 할 경우, **Firebase Remote Config** 또는 **Firestore**를 활용할 수 있습니다.
    -   이 방식은 전체 앱 문자열이 아닌, 매우 제한적인 경우에만 사용하는 것을 권장합니다. (예: 이벤트 공지 문구, 특정 프로모션 문구)
    -   동적으로 로드된 문자열도 숫자/날짜 포맷팅, 복수형 처리 등은 `intl` 패키지의 기능을 활용합니다.
    -   오프라인 지원 및 초기 로딩 성능 영향을 고려하여 신중하게 설계합니다.
-   **포맷팅 및 복수형 처리:**
    -   날짜, 숫자, 통화 등의 포맷팅은 `intl` 패키지에서 제공하는 `DateFormat`, `NumberFormat` 등을 사용합니다.
    -   복수형(plurals), 성별(gender)에 따른 문자열 변화는 `Intl.plural` 및 `Intl.gender` 기능을 활용합니다.
-   **테스트:**
    -   각 지원 언어별로 UI가 올바르게 표시되고, 텍스트 잘림(overflow) 등이 없는지 다양한 기기 및 화면 크기에서 테스트합니다.
    -   로케일 변경 기능을 앱 내에 제공하거나 개발자 옵션으로 두어 테스트 용이성을 확보합니다.

### ♿ 접근성(Accessibility - a11y) 가이드라인 (Flutter - 필요시)

-   **의미 있는 위젯 사용:** `Semantics` 위젯을 사용하여 스크린 리더 사용자에게 명확한 정보 전달.
-   **충분한 터치 영역:** 버튼, 아이콘 등 인터랙티브 요소는 최소 48x48 dp 크기 권장.
-   **명도 대비:** 텍스트와 배경 간 충분한 명도 대비 확보 (WCAG 기준 참고).
-   **키보드 네비게이션 지원:** 모든 인터랙티브 요소에 키보드로 접근 및 조작 가능하도록.
-   **Flutter의 접근성 관련 위젯 및 도구 활용.** (예: `ExcludeSemantics`, `MergeSemantics`, Flutter Inspector의 Semantics Debugger)
