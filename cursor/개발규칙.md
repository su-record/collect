# 🎯 개발 규칙 (통합 스택 버전 - 구조 및 내용 개선)

## 📜 목차

1.  [⭐ 기본 원칙 (Basic Principles)](#1-기본-원칙-basic-principles)
    1.1. [핵심 가치 (Core Values)](#11-핵심-가치-core-values)
    1.2. [코드 작성 기본 (Code Writing Basics)](#12-코드-작성-기본-code-writing-basics)
    1.3. [패키지/라이브러리 관리 (Package/Library Management)](#13-패키지라이브러리-관리-packagelibrary-management)
    1.4. [파일 및 디렉토리 관리 (File and Directory Management)](#14-파일-및-디렉토리-관리-file-and-directory-management)
2.  [💻 아키텍처 및 설계 원칙 (Architecture & Design Principles)](#2-아키텍처-및-설계-원칙-architecture--design-principles)
    2.1. [구조적 원칙 (Structural Principles)](#21-구조적-원칙-structural-principles)
    2.2. [품질 속성 (Quality Attributes)](#22-품질-속성-quality-attributes)
    2.3. [디자인 패턴 (Design Patterns)](#23-디자인-패턴-design-patterns)
3.  [🎨 프론트엔드 개발 원칙 (Flutter Focus)](#3-프론트엔드-개발-원칙-flutter-focus)
    3.1. [UI/UX 원칙 (UI/UX Principles)](#31-uiux-원칙-uiux-principles)
    3.2. [Flutter 위젯 개발 (Flutter Widget Development)](#32-flutter-위젯-개발-flutter-widget-development)
    3.3. [상태 관리 (State Management - Flutter)](#33-상태-관리-state-management---flutter)
4.  [⚙️ 백엔드 개발 원칙 (Python/Node.js Focus)](#4-️-백엔드-개발-원칙-pythonnodejs-focus)
    4.1. [API 설계 (API Design)](#41-api-설계-api-design)
    4.2. [비즈니스 로직 구현 (Business Logic Implementation)](#42-비즈니스-로직-구현-business-logic-implementation)
    4.3. [데이터 처리 및 관리 (Data Handling & Management)](#43-데이터-처리-및-관리-data-handling--management)
5.  [☁️ 클라우드 환경 개발 원칙 (Cloud Environment - GCP)](#5-️-클라우드-환경-개발-원칙-cloud-environment---gcp)
    5.1. [리소스 관리 (Resource Management)](#51-리소스-관리-resource-management)
    5.2. [보안 (Security)](#52-보안-security)
    5.3. [서비스 운영 (Service Operations)](#53-서비스-운영-service-operations)
6.  [🔄 코드 변경 관리 (Code Change Management)](#6--코드-변경-관리-code-change-management)
7.  [📝 문서화 (Documentation)](#7--문서화-documentation)
8.  [🧪 테스트 규칙 (Test Guidelines)](#8--테스트-규칙-test-guidelines)
9.  [🧐 코드 리뷰 가이드라인 (Code Review Guidelines)](#9--코드-리뷰-가이드라인-code-review-guidelines)
10. [🌿 브랜치 전략 및 버전 관리 (Branching & Version Control)](#10--브랜치-전략-및-버전-관리-branching--version-control)
11. [🛡️ 보안 코딩 가이드라인 (Secure Coding Guidelines)](#11-️-보안-코딩-가이드라인-secure-coding-guidelines)
12. [⚡ 성능 최적화 가이드라인 (Performance Optimization Guidelines)](#12-️-성능-최적화-가이드라인-performance-optimization-guidelines)
13. [🌍 국제화(i18n) 및 지역화(l10n) 가이드라인 (Flutter)](#13--국제화i18n-및-지역화l10n-가이드라인-flutter)
14. [♿ 접근성(Accessibility - a11y) 가이드라인 (Flutter)](#14--접근성accessibility---a11y-가이드라인-flutter)
15. [🔍 문제 해결 전략 (Problem Solving Strategy)](#15--문제-해결-전략-problem-solving-strategy)

---

## 1. ⭐ 기본 원칙 (Basic Principles)

> **요약:** 모든 개발 활동의 기초가 되는 핵심 가치와 코드 작성의 기본 원칙을 정의합니다. 효율적이고 유지보수 가능한 소프트웨어 구축을 위한 토대를 마련합니다.

### 1.1. 핵심 가치 (Core Values)

-   **1.1.1. 모든 응답은 한국어로 작성** (All responses must be in Korean)
-   **1.1.2. 명확성 및 간결성 추구:** 코드는 이해하기 쉽고, 불필요한 복잡성을 피해야 합니다. (Less code = Less debt)
-   **1.1.3. 단일 책임 원칙 (SRP) 준수:** 모든 코드 단위(함수, 클래스, 모듈, 위젯, 서비스)는 하나의 명확한 책임만 가져야 합니다.
    -   **예시 (Flutter 위젯):**
        -   `Good`: `UserProfileView` 위젯 (사용자 프로필 UI 렌더링), `UserProfileController` (상태 관리 및 로직 처리) 분리.
        -   `Bad`: 하나의 거대한 위젯이 UI 렌더링, API 호출, 상태 관리를 모두 처리.
    -   **예시 (백엔드 함수 - Cloud Function):**
        -   `Good`: `createUser` 함수 (사용자 생성 로직만 담당), `sendWelcomeEmail` 함수 (환영 이메일 발송 로직만 담당).
        -   `Bad`: `processNewUser` 함수가 사용자 생성, 이메일 발송, 슬랙 알림 등 여러 책임을 동시에 수행.

### 1.2. 코드 작성 기본 (Code Writing Basics)

-   **1.2.1. 중복 최소화 (DRY - Don't Repeat Yourself):** 동일하거나 유사한 코드는 재사용 가능한 함수나 모듈로 추출합니다.
-   **1.2.2. 불필요한 코드 및 변경 금지:** 사용되지 않는 코드, 실험적인 코드, 또는 특별한 요청 없는 스타일 변경은 지양합니다.
-   **1.2.3. 네이밍 컨벤션 준수:** 각 언어/플랫폼의 표준 네이밍 규칙을 따르고, 변수/함수/클래스명은 그 역할과 의미를 명확히 드러내도록 작성합니다. (세부 내용은 [2. 아키텍처 및 설계 원칙](#2-아키텍처-및-설계-원칙-architecture--design-principles)의 가독성 부분 참고)

### 1.3. 패키지/라이브러리 관리 (Package/Library Management)

-   **1.3.1. 신규 추가 최소화 및 검토:** 새로운 의존성 추가는 기존 프로젝트의 것을 우선 사용하고, 추가 시에는 라이선스, 보안, 유지보수성 등을 반드시 검토 및 승인받습니다.
-   **1.3.2. 불필요한 의존성 제거:** 더 이상 사용되지 않는 패키지/라이브러리는 즉시 제거합니다.
-   **1.3.3. 플랫폼별 의존성 관리 도구 사용:**
    -   **Flutter/Dart:** `pubspec.yaml`
    -   **Python:** `requirements.txt` 또는 `pyproject.toml` (Poetry/PDM)
    -   **Node.js:** `package.json`

### 1.4. 파일 및 디렉토리 관리 (File and Directory Management)

-   **1.4.1. 생성 전 확인:** 파일 생성 전, 사용될 위치와 프로젝트의 모듈 구조 내에서의 역할을 명확히 합니다.
-   **1.4.2. 생성 후 즉시 조치:** 파일 생성 후 즉시 필요한 import/export 구문을 추가하고, 경로의 정확성을 확인합니다.
-   **1.4.3. 순환 참조 방지:** 파일/모듈 간 순환 참조가 발생하지 않도록 구조 설계에 유의합니다.
-   **1.4.4. 기능/도메인 중심 구성:** 단순히 코드 타입(예: `controllers`, `services`)별로만 디렉토리를 구성하기보다, 기능이나 도메인 중심으로 관련 파일들을 그룹화하여 응집도를 높입니다.

---

## 2. 💻 아키텍처 및 설계 원칙 (Architecture & Design Principles)

> **요약:** 견고하고 확장 가능한 시스템 설계를 위한 구조적 원칙, 코드 품질 속성, 그리고 효과적인 디자인 패턴 활용법을 다룹니다.

### 2.1. 구조적 원칙 (Structural Principles)

-   **2.1.1. 계층 분리 (Layered Architecture):** Presentation, Application/Business, Domain, Infrastructure 등 논리적 계층을 구분하여 각 계층의 책임을 명확히 합니다.
-   **2.1.2. 모듈화 (Modularity):** 시스템을 기능적으로 독립된 모듈로 나누어 개발하고 관리합니다. 각 모듈은 명확한 인터페이스를 통해 상호작용합니다.
-   **2.1.3. 응집도 최대화 (High Cohesion):** 모듈 내의 요소들은 서로 밀접하게 관련되어 하나의 목적을 수행하도록 구성합니다. (관련 파일/로직을 함께 배치)
-   **2.1.4. 결합도 최소화 (Low Coupling):** 모듈 간, 클래스 간, 함수 간 의존성을 낮춰 변경의 파급 효과를 줄이고 재사용성을 높입니다.
    -   **예시 (Flutter - Props Drilling 회피):** 중간 단계 위젯들이 직접 사용하지 않는 props를 계속 전달하는 대신, 상태 관리 솔루션(Provider, Riverpod)이나 컴포넌트 합성(Composition)을 활용합니다.
    -   **예시 (백엔드 - 의존성 주입):** 서비스나 핸들러가 직접 구체 클래스에 의존하기보다, 인터페이스에 의존하고 외부에서 실제 구현체를 주입받도록 설계합니다. (DI 프레임워크 활용 또는 수동 주입)

### 2.2. 품질 속성 (Quality Attributes)

-   **2.2.1. 가독성 (Readability):**
    -   **매직 넘버/문자열:** 명명된 상수로 대체합니다.
    -   **복잡한 조건문:** 명명된 변수/함수로 할당하여 의미를 명확히 합니다.
    -   **네이밍:**
        -   변수는 명사, 함수/메서드는 동사로 시작하는 것을 기본으로 합니다.
        -   Flutter 이벤트 핸들러: `onEventName` 또는 `handleEventName`.
        -   불리언: `is`, `has`, `can`, `should` 등으로 시작.
        -   각 언어/플랫폼 표준 준수: Dart (`lowerCamelCase`, `UpperCamelCase`), Python (`snake_case`, `PascalCase`), Node.js (`camelCase`, `PascalCase`).
    -   **주석:** '왜(Why)'를 설명하고, 코드와 함께 최신 상태로 유지합니다.

-   **2.2.2. 예측 가능성 (Predictability):**
    -   **일관된 인터페이스:** 유사한 기능에는 일관된 함수 시그니처 및 반환 타입을 사용합니다.
    -   **부수 효과 최소화:** 함수는 명시된 작업 외에 숨겨진 부수 효과를 만들지 않습니다.
    -   **명확한 이름:** 사용자 정의 래퍼, 함수, 클래스 등은 고유하고 설명적인 이름을 사용합니다.

-   **2.2.3. 유지보수성 (Maintainability):** 코드는 수정, 이해, 확장이 용이해야 합니다. (SRP, 모듈화, 가독성 등이 기여)

-   **2.2.4. 테스트 용이성 (Testability):** 코드는 격리되어 테스트하기 쉽도록 작성되어야 합니다. (의존성 주입, 인터페이스 기반 설계 등이 기여)

### 2.3. 디자인 패턴 (Design Patterns)

-   **2.3.1. 상황에 맞는 패턴 적용:** 각 플랫폼 및 언어 특성에 맞는 적절한 디자인 패턴을 문제 해결의 도구로 활용합니다.
    -   **Flutter:** Composite(위젯 구성), Observer(상태 관리 - Provider/Riverpod), BLoC/Cubit, Factory, Builder 등.
    -   **백엔드:** Strategy, Factory, Adapter, Decorator, Observer(이벤트 기반) 등.
-   **2.3.2. 과용 금지:** 단순한 문제에 복잡한 패턴을 적용하는 것을 지양합니다. 패턴 적용의 장단점과 코드 복잡도 증가를 충분히 검토합니다.
-   **2.3.3. 빠른 참조:**
    -   **높은 우선순위:**
        -   Flutter: Observer(상태 관리), Composite(위젯 구성)
        -   백엔드: Factory/Builder(객체 생성), Adapter(외부 연동)
    -   **중간 우선순위:**
        -   Flutter: Strategy(조건부 로직), Builder(동적 위젯)
        -   백엔드: Strategy(로직 분기), Decorator(기능 확장)
-   **2.3.4. 예시 코드:**
    *(기존 문서의 디자인 패턴별 예시 코드(UserInfoCard, CounterControls, DocumentProcessor 등)는 개념 이해에 도움이 되므로 유지합니다. 모든 패턴에 대한 예시를 추가하기보다, 핵심 패턴 위주로 제공합니다.)*

```dart
// Flutter: Composite 패턴 + Material 위젯 예시 (UserInfoCard)
// ... (이전 예시 코드와 동일) ...
```
```dart
// Flutter: Observer 패턴 (Provider 예시) + Material 위젯 (CounterControls)
// ... (이전 예시 코드와 동일) ...
```
```python
# Python (Backend): Factory 패턴 예시 (DocumentProcessor)
# ... (이전 예시 코드와 동일) ...
```

---

## 3. 🎨 프론트엔드 개발 원칙 (Flutter Focus)

> **요약:** Flutter를 사용한 프론트엔드 개발 시 사용자 경험(UX) 향상, 효율적인 위젯 개발, 그리고 체계적인 상태 관리를 위한 핵심 원칙들을 다룹니다.

### 3.1. UI/UX 원칙 (UI/UX Principles)

-   **3.1.1. Material Design 준수:** Google의 Material Design 시스템([material.io](https://material.io/))을 적극 활용하여 일관되고 직관적인 UX를 제공합니다.
-   **3.1.2. Material 위젯 우선 사용:** `Scaffold`, `AppBar`, `Card` 등 기본 제공 Material 위젯을 우선 사용하고 필요시 커스터마이징합니다.
-   **3.1.3. `ThemeData` 활용:** 앱 전체의 색상, 타이포그래피, 모양 등을 `ThemeData`로 일관되게 관리합니다.
-   **3.1.4. 반응형 UI 설계:** `MediaQuery`, `LayoutBuilder` 등을 활용하여 다양한 화면 크기 및 방향에 대응합니다.

### 3.2. Flutter 위젯 개발 (Flutter Widget Development)

-   **3.2.1. 위젯 분리 및 재사용:** 복잡한 UI는 작고 재사용 가능한 위젯으로 분리합니다. `build` 메서드는 간결하게 유지합니다.
-   **3.2.2. `const` 위젯 활용:** 변경되지 않는 위젯에는 `const` 키워드를 사용하여 성능을 최적화합니다.
-   **3.2.3. 위젯 네이밍:** `UpperCamelCase`를 사용하며, 역할과 시각적 표현을 명확히 드러내는 이름을 사용합니다. (예: `UserProfileCard`, `SettingsListItem`)

### 3.3. 상태 관리 (State Management - Flutter)

-   **3.3.1. 적절한 솔루션 선택:** 앱의 복잡도와 팀의 선호도에 따라 Provider, Riverpod, BLoC/Cubit 등 적절한 상태 관리 솔루션을 선택합니다.
-   **3.3.2. 상태 범위 최소화:** 상태는 필요한 최소한의 범위에만 노출되도록 관리하여 불필요한 리빌드를 방지합니다.
-   **3.3.3. 단방향 데이터 흐름 지향:** 예측 가능하고 디버깅하기 쉬운 상태 관리를 위해 단방향 데이터 흐름 아키텍처를 지향합니다.

---

## 4. ⚙️ 백엔드 개발 원칙 (Python/Node.js Focus)

> **요약:** Python 및 Node.js를 사용한 백엔드 개발 시, 안정적이고 확장 가능한 API 설계, 효율적인 비즈니스 로직 구현, 그리고 안전한 데이터 처리를 위한 핵심 원칙을 다룹니다.

### 4.1. API 설계 (API Design)

-   **4.1.1. RESTful 또는 적합한 방식 선택:** RESTful API 설계 원칙을 기본으로 하되, GraphQL 등 프로젝트 상황에 맞는 방식을 선택할 수 있습니다.
-   **4.1.2. 일관된 요청/응답 구조:** 명확한 HTTP 상태 코드와 일관된 JSON 요청/응답 형식을 사용합니다.
-   **4.1.3. API 버전 관리:** URL 경로(`v1/users`)나 헤더를 통한 API 버전 관리 전략을 수립합니다.
-   **4.1.4. 상세한 API 문서화:** OpenAPI(Swagger) 등을 활용하여 API 명세를 관리하고 공유합니다. ([7. 문서화](#7--문서화-documentation) 참고)

### 4.2. 비즈니스 로직 구현 (Business Logic Implementation)

-   **4.2.1. 서비스 계층 활용:** 복잡한 비즈니스 로직은 별도의 서비스 계층(Service Layer)으로 분리하여 핸들러/컨트롤러의 책임을 줄이고 재사용성을 높입니다.
-   **4.2.2. 비동기 처리 적극 활용:** I/O 바운드 작업(DB 접근, 외부 API 호출 등)은 Python `asyncio` 또는 Node.js `async/await`를 사용하여 논블로킹 방식으로 처리합니다.
-   **4.2.3. 설정 값 외부화:** 데이터베이스 연결 정보, API 키 등 환경에 따라 달라지는 설정은 환경 변수나 설정 파일을 통해 외부에서 주입합니다. ([5.2.2. 민감 정보 관리](#522-민감-정보-관리-secrets-management) 참고)

### 4.3. 데이터 처리 및 관리 (Data Handling & Management)

-   **4.3.1. 입력값 검증 (Validation):** API 요청으로 들어오는 모든 입력값은 서버 측에서 반드시 검증합니다. (타입, 형식, 범위 등)
-   **4.3.2. ORM/ODM 활용 (필요시):** 데이터베이스 상호작용 시 생산성 및 안전성을 위해 ORM(SQLAlchemy 등)이나 ODM(Mongoose 등) 사용을 고려합니다.
-   **4.3.3. 트랜잭션 관리:** 여러 데이터 변경 작업을 하나의 논리적 단위로 묶어야 할 경우, 데이터베이스 트랜잭션을 적절히 활용하여 데이터 일관성을 보장합니다.
-   **4.3.4. Firestore 데이터 모델링:** 읽기 패턴을 고려하여 데이터 중복과 정규화 사이의 균형을 맞추고, 효율적인 쿼리가 가능하도록 설계합니다.

---

## 5. ☁️ 클라우드 환경 개발 원칙 (Cloud Environment - GCP)

> **요약:** Google Cloud Platform(GCP)을 활용한 개발 시 리소스의 효율적 관리, 강력한 보안 체계 구축, 그리고 안정적인 서비스 운영을 위한 핵심 지침을 제공합니다.

### 5.1. 리소스 관리 (Resource Management)

-   **5.1.1. 네이밍 컨벤션 통일:** GCP 리소스(프로젝트, 인스턴스, 버킷 등)에 일관된 네이밍 규칙(예: `[project]-[service]-[env]-[name]`)을 적용합니다.
-   **5.1.2. IaC (Infrastructure as Code) 도입 고려:** Terraform, Cloud Deployment Manager 등으로 인프라 구성을 코드로 관리하여 재현성과 자동화를 높입니다.
-   **5.1.3. 비용 최적화:** 각 GCP 서비스의 과금 모델을 이해하고, 불필요한 리소스 정리, 적절한 머신 타입/스토리지 클래스 선택 등으로 비용을 관리합니다.
-   **5.1.4. Region/Zone 선택:** 지연 시간, 비용, 가용성 요구사항을 종합적으로 고려하여 최적의 Region 및 Zone을 선택합니다.

### 5.2. 보안 (Security)

-   **5.2.1. IAM 최소 권한 원칙:** 사용자 및 서비스 계정에 필요한 최소한의 권한만 부여합니다. (Principle of Least Privilege)
-   **5.2.2. 민감 정보 관리 (Secrets Management):** API 키, 인증서, 비밀번호 등은 **Google Secret Manager**에 저장하고, 환경 변수를 통해 안전하게 주입합니다. 코드 내 하드코딩은 절대 금지합니다.
-   **5.2.3. 네트워크 보안:**
    -   **Firebase Security Rules:** Firestore, Cloud Storage의 데이터 접근 권한을 세밀하게 제어합니다.
    -   **Cloud Functions/Run 인그레스 설정:** 필요한 호출자만 접근하도록 제한하고, VPC Service Controls, VPC Connector 사용을 고려합니다.
    -   **API Gateway 활용:** API 인증, 권한 부여, 요청량 제한(Rate Limiting) 등의 보안 기능을 적용합니다.
-   **5.2.4. 데이터 암호화:** 저장 데이터(at-rest) 및 전송 중 데이터(in-transit) 암호화는 GCP 기본 제공 기능을 최대한 활용합니다.

### 5.3. 서비스 운영 (Service Operations)

-   **5.3.1. 로깅 및 모니터링 (Logging & Monitoring):**
    -   **Google Cloud's operations suite (Cloud Logging, Cloud Monitoring, Cloud Trace, Error Reporting) 적극 활용.**
    -   **구조화된 로그(JSON 등) 작성**으로 분석 및 검색 효율을 높입니다.
    -   주요 지표(에러율, 응답 시간, 리소스 사용량)에 대한 대시보드 및 알림을 설정합니다.
-   **5.3.2. 서비스 간 통신 (Inter-Service Communication):**
    -   **동기식:** 즉각적인 응답이 필요할 때 HTTP API 호출 사용. (API Gateway, 내부 Load Balancer 활용)
    -   **비동기식:** **Cloud Pub/Sub** 등을 활용한 이벤트 기반 아키텍처로 서비스 간 결합도를 낮추고 탄력성을 높입니다. (예: Firestore 트리거를 통한 비동기 작업 처리)
-   **5.3.3. 멱등성(Idempotency) 고려:** 재시도 가능한 작업(특히 비동기 메시지 처리)은 여러 번 호출되어도 동일한 결과를 내도록 멱등성을 고려하여 설계합니다.

---

## 6. 🔄 코드 변경 관리 (Code Change Management)

> **요약:** 코드 변경 시 안정성과 예측 가능성을 확보하기 위한 지침입니다. 변경 범위 최소화, 기존 스타일 존중, 신중한 리팩토링, 그리고 변경 전후 확인 절차를 강조합니다.

-   **6.1. 최소 변경 원칙:** 관련된 코드만 최소한으로 변경합니다. 변경 전 코드의 영향 범위를 정확히 파악하고, 변경 후 의도대로 동작하는지 철저히 검증합니다. (테스트 필수)
-   **6.2. 스타일 일관성 유지:** 코드 스타일, 네이밍, 주석 등은 프로젝트 전체의 일관성을 해치지 않는 선에서 변경합니다. 각 언어/플랫폼의 Linter 및 Formatter 설정을 따릅니다.
    -   **Flutter UI 변경 시:** Material Design 가이드라인 및 앱 전체 테마와의 일관성을 우선 고려합니다.
-   **6.3. 신중한 리팩토링:** 리팩토링, 코드 정리, 불필요한 삭제는 명확한 목적과 범위를 설정하고, 반드시 코드 리뷰를 거쳐 진행합니다.
-   **6.4. 변경 전후 체크리스트 활용:** 변경의 필요성, 영향 범위, 최소 변경 여부, 부작용 가능성, 테스트 커버리지 등을 확인합니다.
-   **6.5. 버전 관리:** 모든 주요 변경 사항은 버전 관리 시스템(Git)에 의미 있는 커밋 메시지와 함께 기록합니다. ([10. 브랜치 전략 및 버전 관리](#10--브랜치-전략-및-버전-관리-branching--version-control) 참고)

---

## 7. 📝 문서화 (Documentation)

> **요약:** 효과적인 지식 공유와 유지보수를 위한 문서화 원칙입니다. 코드 내 주석, README, API 명세 등 다양한 형태의 문서를 최신 상태로 명확하게 관리하는 방법을 안내합니다.

-   **7.1. 코드 내 주석:**
    -   **JSDoc/DartDoc/Docstrings 활용:** 함수, 클래스, 모듈 시작 부분에 기능, 매개변수, 반환값 등을 명시합니다. (각 언어 표준 주석 스타일 사용)
    -   **복잡한 로직 설명:** 이해하기 어려운 알고리즘이나 특정 비즈니스 규칙, 기술적 결정의 배경 등을 설명하는 주석을 추가합니다.
    -   **Flutter 위젯 문서화:** 위젯의 목적, 주요 속성, 사용된 Material 위젯, 상태 관리 의존성 등을 Dart Doc 스타일로 작성합니다.
-   **7.2. 작업 표시 주석 (TODO, FIXME 등):**
    -   버그, 비효율, 개선점 등은 `TODO:`, `FIXME:`, `OPTIMIZE:` 등으로 명확히 표시하고, 가능한 경우 이슈 트래커에 해당 내용을 등록합니다.
    -   주석에는 문제 원인, 제안 해결 방법, 담당자(선택) 등을 간략히 명시합니다.
-   **7.3. 프로젝트 레벨 문서:**
    -   **README.md:** 프로젝트 개요, 기술 스택, 설정 및 실행 방법, 주요 아키텍처, 디렉토리 구조 등을 상세히 기술합니다.
    -   **API 문서 (백엔드):** OpenAPI(Swagger) 명세를 작성하고, API Gateway 등을 통해 제공하거나 별도 문서로 관리합니다.
    -   **아키텍처 다이어그램:** 시스템 전체 구조나 주요 서비스 간의 상호작용을 시각적으로 표현한 다이어그램을 유지보수합니다. (필요시 주요 GCP 리소스 설정값 포함)
-   **7.4. 변경 이력 관리:** 코드 변경의 이유와 내용은 버전 관리 시스템(커밋 메시지) 및 이슈 트래커를 통해 추적 가능하도록 기록합니다.

---

## 8. 🧪 테스트 규칙 (Test Guidelines)

> **요약:** 소프트웨어 품질 확보를 위한 다양한 레벨의 테스트 전략과 작성 지침을 제공합니다. 단위 테스트부터 E2E 테스트까지, 각 테스트 유형의 목적과 효과적인 작성 방법을 안내합니다.

-   **8.1. 테스트의 중요성:** 모든 주요 기능 및 로직 변경에는 적절한 테스트 코드가 동반되어야 합니다. 테스트는 버그를 조기에 발견하고, 리팩토링의 안정성을 보장하며, 코드의 동작을 문서화하는 역할을 합니다.

-   **8.2. 테스트 유형 및 전략:**
    -   **8.2.1. 단위 테스트 (Unit Tests):**
        -   **목적:** 개별 함수, 메서드, 클래스, 위젯 로직 등 가장 작은 코드 단위를 독립적으로 검증합니다.
        -   **Flutter:** `flutter_test` 패키지를 사용하여 위젯의 로직, 상태 관리 클래스(Notifier, BLoC/Cubit), 유틸리티 함수 등을 테스트합니다.
        -   **백엔드 (Python/Node.js):** Python `unittest`/`pytest`, Node.js `Jest`/`Mocha` 등을 사용하여 개별 함수, 클래스, 모듈의 로직을 검증합니다.
        -   **Mock 객체 활용:** 외부 의존성(DB, API 호출 등)은 Mock 객체를 사용하여 제어하고, 테스트 대상 코드에만 집중합니다.
    -   **8.2.2. 위젯 테스트 (Widget Tests - Flutter Only):**
        -   **목적:** 개별 위젯의 UI 렌더링, 사용자 인터랙션, 상태 변화에 따른 UI 업데이트를 검증합니다.
        -   **도구:** `flutter_test` 패키지의 `WidgetTester`를 활용합니다.
        -   **범위:** Material 위젯과의 상호작용, 테마 적용 여부 등을 포함할 수 있습니다.
    -   **8.2.3. 통합 테스트 (Integration Tests):**
        -   **목적:** 여러 컴포넌트, 모듈, 또는 서비스가 함께 연동되어 올바르게 동작하는지 검증합니다.
        -   **Flutter:** `integration_test` 패키지를 사용하여 실제 기기나 에뮬레이터에서 앱의 특정 기능 흐름(예: 로그인 후 특정 화면 이동)을 테스트합니다.
        -   **백엔드:** 여러 Cloud Functions 또는 마이크로서비스 간의 API 호출 및 데이터 흐름을 테스트합니다. 필요한 경우 부분적인 Mocking을 사용하거나 실제 의존 서비스를 활용할 수 있습니다.
    -   **8.2.4. E2E (End-to-End) 테스트 (필요시):**
        -   **목적:** 실제 사용자 시나리오를 기반으로 전체 시스템(프론트엔드-백엔드-데이터베이스 등)의 동작을 검증합니다.
        -   **환경:** 실제 운영 환경과 최대한 유사하게 시뮬레이션된 환경에서 수행하는 것을 목표로 합니다.

-   **8.3. 테스트 작성 원칙:**
    -   **명확성 (Clear):** 테스트 코드의 의도와 검증 내용이 명확해야 합니다. 테스트 이름은 무엇을 테스트하는지 설명적으로 작성합니다.
    -   **독립성 (Independent):** 각 테스트는 다른 테스트에 영향을 주거나 받지 않고 독립적으로 실행될 수 있어야 합니다.
    -   **반복 가능성 (Repeatable):** 어떤 환경에서도 동일한 결과를 반복적으로 생성해야 합니다. (외부 요인 최소화)
    -   **AAA 패턴 (Arrange-Act-Assert):** 테스트 코드는 준비(Arrange), 실행(Act), 검증(Assert)의 세 단계로 구조화하는 것을 권장합니다.

-   **8.4. 테스트 커버리지:**
    -   단순히 높은 커버리지 숫자를 목표로 하기보다, **핵심 비즈니스 로직과 중요한 기능 위주로 높은 커버리지를 확보**하는 것을 목표로 합니다. (예: 중요 모듈 80% 이상)
    -   커버리지 측정 도구를 활용하여 주기적으로 점검하고 개선합니다.

-   **8.5. 테스트 데이터 관리:**
    -   테스트에는 일관되고 재현 가능한 데이터가 필요합니다.
    -   단위 테스트에는 주로 Mock 데이터나 하드코딩된 데이터를 사용합니다.
    -   통합/E2E 테스트에는 필요한 경우 테스트용 DB를 사용하거나, 특정 상태를 재현할 수 있는 데이터를 준비합니다.

---

## 9. 🧐 코드 리뷰 가이드라인 (Code Review Guidelines)

> **요약:** 코드 품질 향상, 지식 공유, 그리고 잠재적 버그 예방을 위한 효과적인 코드 리뷰 수행 방법을 안내합니다. 리뷰어와 작성자 모두에게 도움이 되는 건설적인 리뷰 문화를 조성하는 것을 목표로 합니다.

-   **9.1. 코드 리뷰의 목적:**
    -   코드 품질 향상 (가독성, 유지보수성, 성능, 보안 등)
    -   버그 및 잠재적 문제점 조기 발견
    -   팀 내 지식 공유 및 표준 개발 관행 전파
    -   코드 작성자의 성장 지원

-   **9.2. 리뷰어의 역할 및 책임:**
    -   **건설적인 피드백 제공:** 비판보다는 개선을 위한 제안 형태로, 긍정적이고 존중하는 태도를 유지합니다.
    -   **구체적인 지적:** 모호한 표현보다는 문제점과 개선 방안을 구체적으로 명시합니다. "왜" 그렇게 생각하는지 이유를 설명합니다.
    -   **개발 규칙 준수 확인:** 본 문서에 명시된 개발 규칙 및 코딩 컨벤션 준수 여부를 확인합니다.
    -   **핵심 로직 검토:** 기능 구현의 정확성, 엣지 케이스 처리, 알고리즘의 효율성 등을 중점적으로 검토합니다.
    -   **질문 활용:** 이해가 안 되거나 의도가 불분명한 부분은 질문을 통해 명확히 합니다.
    -   **작은 단위 리뷰 선호:** 너무 큰 변경 사항은 리뷰하기 어려우므로, PR(Pull Request)을 작은 단위로 나누도록 권장합니다.

-   **9.3. 코드 작성자(Author)의 역할 및 책임:**
    -   **리뷰 요청 전 자가 점검:** PR 제출 전, 자신의 코드를 스스로 리뷰하고 테스트하여 명백한 오류나 개선점을 수정합니다.
    -   **명확한 PR 설명:** 변경 사항의 목적, 주요 내용, 테스트 방법, 관련 이슈 등을 PR 설명에 상세히 작성합니다. (PR 템플릿 활용)
    -   **피드백 수용 및 논의:** 리뷰어의 피드백을 열린 마음으로 검토하고, 이견이 있을 경우 건설적으로 논의합니다.
    -   **신속한 피드백 반영:** 합의된 개선 사항은 신속하게 코드에 반영합니다.

-   **9.4. 코드 리뷰 프로세스:**
    -   **PR 생성:** 코드 작성자는 기능 개발 또는 버그 수정 완료 후 PR을 생성합니다.
    -   **리뷰어 지정:** 프로젝트 정책에 따라 1명 이상의 리뷰어를 지정합니다. (팀 규모에 따라 자동 지정 또는 수동 지정)
    -   **리뷰 진행:** 리뷰어는 지정된 시간 내에 리뷰를 수행하고 피드백을 남깁니다.
    -   **수정 및 재리뷰:** 코드 작성자는 피드백을 반영하고, 필요한 경우 재리뷰를 요청합니다.
    -   **승인 및 머지 (Merge):** 모든 주요 피드백이 해결되고 리뷰어의 승인을 받으면 코드를 대상 브랜치(예: `develop`)에 머지합니다.

-   **9.5. 코드 리뷰 중점 사항 (체크리스트 예시):**
    -   **설계 및 아키텍처:** SRP, DRY 원칙 준수 여부, 모듈화 및 계층 분리 적절성.
    -   **가독성:** 명확한 네이밍, 적절한 주석, 일관된 코드 스타일.
    -   **기능 구현:** 요구사항 충족 여부, 로직의 정확성, 엣지 케이스 처리.
    -   **테스트:** 충분한 테스트 코드 작성 여부, 테스트 케이스의 적절성.
    -   **성능:** 비효율적인 루프, 불필요한 DB/API 호출, 메모리 누수 가능성 등.
    -   **보안:** 입력값 검증 누락, 민감 정보 노출 가능성 등.
    -   **문서화:** 필요한 주석 및 문서 업데이트 여부.

---

## 10. 🌿 브랜치 전략 및 버전 관리 (Branching & Version Control)

> **요약:** Git을 사용한 효율적인 협업과 안정적인 버전 관리를 위한 브랜치 운영 전략 및 커밋 메시지 작성 규칙을 안내합니다.

-   **10.1. 기본 브랜치 모델:** 프로젝트의 규모와 특성에 따라 Gitflow, GitHub Flow 또는 이를 간소화한 모델을 선택하여 일관되게 운영합니다.
    -   **주요 브랜치 예시 (Gitflow 기반):**
        -   `main` (또는 `master`): 실제 운영 환경에 배포되는 가장 안정적인 버전의 코드. 직접적인 커밋은 금지하며, `release` 또는 `hotfix` 브랜치에서 병합(merge)합니다.
        -   `develop`: 다음 릴리스를 위해 개발 중인 코드. 기능 개발이 완료된 `feature` 브랜치들이 병합되는 통합 브랜치입니다.
        -   `feature/[feature-name]` (예: `feature/user-authentication`): 새로운 기능 개발을 위한 브랜치. `develop` 브랜치에서 생성하고, 개발 완료 후 `develop` 브랜치로 병합합니다.
        -   `release/[version]` (예: `release/1.2.0`): 새로운 버전 배포를 준비하기 위한 브랜치. `develop` 브랜치에서 생성하며, 배포 전 최종 테스트, 버그 수정, 문서 업데이트 등을 진행합니다. 완료 후 `main`과 `develop` 브랜치에 병합합니다.
        -   `hotfix/[issue-number]` (예: `hotfix/issue-123`): 운영 환경에서 발생한 긴급 버그 수정을 위한 브랜치. `main` 브랜치에서 생성하며, 수정 완료 후 `main`과 `develop` 브랜치에 병합합니다.

-   **10.2. 커밋 메시지 컨벤션:** 의미 있고 일관된 커밋 메시지는 코드 변경 이력 추적 및 협업에 매우 중요합니다.
    -   **Conventional Commits ([https://www.conventionalcommits.org/](https://www.conventionalcommits.org/)) 사용 권장:**
        -   형식: `<type>(<scope>): <subject>`
        -   `type`: `feat`(새 기능), `fix`(버그 수정), `docs`(문서 변경), `style`(코드 스타일 변경, 포맷팅 등), `refactor`(코드 리팩토링), `test`(테스트 코드 추가/수정), `chore`(빌드 관련, 패키지 매니저 설정 등 기타 유지보수) 등.
        -   `scope`(선택 사항): 변경 사항의 범위를 나타내는 명사 (예: `auth`, `payment`, `ui-component`).
        -   `subject`: 변경 내용에 대한 간결하고 명확한 설명 (현재 시제, 마침표 X).
    -   **예시:**
        -   `feat(auth): implement user login functionality`
        -   `fix(payment): resolve currency formatting issue in checkout`
        -   `docs: update API documentation for user endpoint`
    -   커밋 메시지 본문(선택 사항)에는 변경 이유, 상세 내용, 관련 이슈 번호 등을 포함할 수 있습니다.

-   **10.3. 브랜치 관리 규칙:**
    -   `feature` 브랜치는 가능한 작고 명확한 단위로 관리합니다.
    -   `develop` 브랜치로 병합(merge)하기 전, 자신의 `feature` 브랜치를 최신 `develop` 브랜치와 동기화(rebase 또는 merge)하여 충돌을 최소화합니다.
    -   병합된 `feature` 브랜치는 원격 저장소에서 삭제하는 것을 원칙으로 합니다. (필요시 정책 조정)
    -   PR(Pull Request)을 통한 코드 리뷰 후 병합을 원칙으로 합니다. ([9. 코드 리뷰 가이드라인](#9--코드-리뷰-가이드라인-code-review-guidelines) 참고)

---

## 11. 🛡️ 보안 코딩 가이드라인 (Secure Coding Guidelines)

> **요약:** 개발 초기 단계부터 보안을 고려하여 안전한 애플리케이션을 구축하기 위한 핵심 원칙과 실천 방안을 안내합니다. OWASP Top 10 등 표준 보안 지침을 기반으로 합니다.

-   **11.1. 입력값 검증 (Input Validation):**
    -   **원칙:** "절대 외부 입력을 신뢰하지 말라 (Never trust user input)."
    -   **프론트엔드 검증:** 사용자 경험 향상을 위해 기본적인 입력값 형식, 길이 등을 클라이언트 사이드에서 검증합니다. (이는 보안 조치가 아닌 UX 개선 목적)
    -   **백엔드 (서버) 검증 (필수):** 모든 API 요청 및 외부 시스템으로부터의 데이터는 서버 측에서 반드시 강력하게 검증합니다. (타입, 길이, 형식, 허용된 문자, 범위, 비즈니스 규칙 등)
    -   SQL Injection, XSS(Cross-Site Scripting), Command Injection 등 주요 공격 방지를 위한 첫 단계입니다.

-   **11.2. 출력 인코딩/이스케이핑 (Output Encoding/Escaping):**
    -   **XSS 방지:** 사용자 입력 또는 데이터베이스에서 가져온 데이터를 HTML, JavaScript, CSS 등에 동적으로 삽입할 때, 해당 컨텍스트에 맞는 적절한 인코딩 또는 이스케이핑 처리를 수행하여 악성 스크립트 실행을 방지합니다.
    -   **Flutter:** 기본적으로 Flutter 위젯은 문자열을 안전하게 렌더링하지만, 웹뷰(WebView)를 사용하거나 HTML을 직접 다루는 경우 특히 주의해야 합니다.
    -   **백엔드:** API 응답으로 데이터를 내려줄 때, 클라이언트가 해당 데이터를 안전하게 처리할 수 있도록 Content-Type을 명확히 지정하고, 필요시 인코딩합니다.

-   **11.3. 인증 (Authentication) 및 인가 (Authorization):**
    -   **강력한 인증 메커니즘 사용:** Firebase Authentication 등 검증된 인증 솔루션을 활용합니다. 다중 요소 인증(MFA) 도입을 고려합니다.
    -   **세션 관리 보안:** 안전한 세션 토큰 생성, 전송(HTTPS), 저장, 만료 정책을 수립합니다.
    -   **최소 권한 원칙 기반 인가:** 인증된 사용자라도 해당 리소스나 기능에 접근할 수 있는 최소한의 권한만 부여합니다. (IAM, Firebase Security Rules 등 활용)
    -   API 엔드포인트별로 적절한 인가 로직을 구현합니다.

-   **11.4. 민감 정보 보호 (Sensitive Data Protection):**
    -   **저장 시 암호화:** 비밀번호, 개인 식별 정보(PII), 금융 정보 등 민감 데이터는 저장 시 강력한 암호화 알고리즘(단방향 해시-비밀번호, 양방향 암호화-PII)을 사용합니다. (GCP KMS 등 활용)
    -   **전송 시 암호화 (HTTPS/TLS):** 모든 데이터 통신은 HTTPS/TLS를 사용하여 암호화합니다.
    -   **Secret Manager 활용:** API 키, 데이터베이스 자격 증명, 암호화 키 등은 Google Secret Manager에 안전하게 저장하고, 애플리케이션에는 환경 변수 등을 통해 주입합니다. ([5.2.2. 민감 정보 관리](#522-민감-정보-관리-secrets-management) 참고)
    -   **로그에 민감 정보 기록 금지:** 로그 파일에 비밀번호, 세션 토큰, 개인 정보 등이 기록되지 않도록 주의합니다.

-   **11.5. 안전한 API 사용 및 의존성 관리:**
    -   **GCP 서비스 보안 설정:** 사용하는 GCP 서비스(Firestore, Cloud Storage, Pub/Sub 등)의 보안 설정을 숙지하고 권장 사항을 따릅니다.
    -   **외부 라이브러리/패키지 보안:** 사용하는 오픈소스 라이브러리 및 패키지의 알려진 보안 취약점을 정기적으로 점검하고, 최신 보안 패치가 적용된 버전으로 업데이트합니다. (예: `npm audit`, `pip-audit`, Flutter `pub outdated`)

-   **11.6. 에러 처리 및 로깅:**
    -   **상세한 에러 메시지 노출 금지:** 사용자에게는 일반적인 에러 메시지만 보여주고, 상세한 시스템 정보나 스택 트레이스는 서버 측 로그에만 기록합니다.
    -   **보안 이벤트 로깅:** 인증 시도(성공/실패), 주요 권한 변경, 중요 데이터 접근 등의 보안 관련 이벤트를 로깅하여 추후 감사 및 분석에 활용합니다.

-   **11.7. 정기적인 보안 검토 및 테스트:**
    -   개발 수명주기에 보안 테스트(정적 분석-SAST, 동적 분석-DAST, 모의 해킹 등)를 통합하는 것을 고려합니다.
    -   새로운 취약점 정보에 주의를 기울이고, 필요시 코드 및 시스템 설정을 업데이트합니다.

---

## 12. ⚡ 성능 최적화 가이드라인 (Performance Optimization Guidelines)

> **요약:** 사용자 경험을 향상시키고 시스템 자원을 효율적으로 사용하기 위한 성능 최적화 전략과 구체적인 실천 방안을 안내합니다. Flutter 프론트엔드와 GCP 백엔드 각각의 특성을 고려한 최적화 기법을 포함합니다.

-   **12.1. 성능 최적화의 기본 원칙:**
    -   **측정 우선 (Measure First):** 추측에 기반한 최적화는 지양합니다. 성능 프로파일링 도구를 사용하여 병목 지점을 정확히 식별한 후 최적화를 진행합니다.
    -   **점진적 개선 (Iterative Improvement):** 한 번에 모든 것을 최적화하려고 하기보다, 가장 큰 영향을 미치는 부분부터 점진적으로 개선해 나갑니다.
    -   **사용자 관점 고려:** 실제 사용자가 체감하는 성능(로딩 속도, 반응성 등) 개선에 우선순위를 둡니다.

-   **12.2. Flutter 프론트엔드 성능 최적화:**
    -   **12.2.1. 위젯 리빌드 최적화:**
        -   **`const` 위젯 적극 사용:** 변경되지 않는 위젯에 `const` 생성자를 사용하여 불필요한 리빌드를 방지합니다.
        -   **위젯 분리:** 상태 변경의 영향을 받는 범위를 최소화하도록 위젯을 작게 분리합니다.
        -   **`RepaintBoundary` 활용:** 복잡하거나 자주 변경되는 부분을 독립적인 레이어로 분리하여 리페인트 범위를 제한합니다.
        -   **상태 관리 솔루션 효율적 사용:** Provider의 `Selector`, Riverpod의 `select` 등을 사용하여 필요한 데이터 변경에만 반응하도록 합니다.
    -   **12.2.2. 레이아웃 및 렌더링 최적화:**
        -   **`ListView.builder`, `GridView.builder` 사용:** 많은 항목을 표시할 때 화면에 보이는 부분만 렌더링하여 성능을 향상시킵니다.
        -   **과도한 `Opacity`, `ClipPath` 사용 자제:** 성능에 영향을 줄 수 있는 위젯 사용 시 주의합니다.
        -   **비동기 작업으로 UI 스레드 확보:** `compute` 함수나 별도의 Isolate를 사용하여 무거운 계산 작업을 UI 스레드 외부에서 처리합니다.
    -   **12.2.3. 이미지 최적화:**
        -   **적절한 이미지 형식 사용:** WebP 등 압축 효율이 좋은 형식을 고려합니다.
        -   **해상도 최적화:** 표시될 크기에 맞는 해상도의 이미지를 사용합니다. (예: `CachedNetworkImage` 패키지의 리사이징 기능 활용)
        -   **이미지 캐싱:** `CachedNetworkImage` 등의 패키지를 활용하여 네트워크 요청을 줄이고 로딩 속도를 개선합니다.
    -   **12.2.4. 애니메이션 최적화:**
        -   불필요하거나 과도한 애니메이션은 자제합니다.
        -   `AnimatedBuilder`, `AnimatedWidget` 등 효율적인 애니메이션 위젯을 사용하고, 애니메이션의 범위를 최소화합니다.
    -   **12.2.5. 앱 시작 시간 최적화 (App Startup Time):**
        -   초기화 로직 최소화, 스플래시 스크린 활용, 코드 스플리팅(Deferred Loding) 등을 고려합니다.
    -   **12.2.6. Flutter DevTools 활용:** 위젯 리빌드, CPU 프로파일링, 메모리 사용량 등을 분석하여 병목 지점을 찾고 개선합니다.

-   **12.3. 백엔드 (Cloud Functions/Run) 성능 최적화:**
    -   **12.3.1. 콜드 스타트(Cold Start) 최적화:**
        -   **적절한 메모리/CPU 설정:** 함수/서비스의 특성에 맞게 리소스를 할당합니다.
        -   **전역 스코프 활용:** 함수 호출 간에 재사용될 수 있는 객체(DB 클라이언트, 설정 값 등)는 전역 스코프에서 초기화합니다.
        -   **의존성 최소화:** 패키지 크기를 줄이고, 필요한 의존성만 포함합니다.
        -   **최소 인스턴스 설정 (Cloud Run/Functions v2):** 트래픽이 꾸준한 경우 최소 인스턴스를 설정하여 항상 준비된 인스턴스를 유지합니다.
    -   **12.3.2. 비동기 처리 및 병렬화:**
        -   I/O 바운드 작업은 `async/await`를 사용하여 논블로킹 방식으로 처리합니다.
        -   독립적으로 수행될 수 있는 여러 비동기 작업은 `Promise.all` (Node.js) 또는 `asyncio.gather` (Python) 등을 사용하여 병렬로 처리합니다.
    -   **12.3.3. 데이터베이스 쿼리 최적화:**
        -   **인덱싱:** Firestore 등에서 자주 사용되는 필드에 적절한 인덱스를 생성하여 쿼리 속도를 향상시킵니다.
        -   **필요한 데이터만 조회:** `select` 구문을 사용하여 필요한 필드만 가져오고, 전체 문서를 로드하는 것을 피합니다.
        -   **배치(Batch) 작업 활용:** 여러 문서를 한 번에 읽거나 쓰는 배치 작업을 활용하여 네트워크 왕복을 줄입니다.
        -   **N+1 쿼리 문제 방지:** 루프 내에서 반복적인 DB 쿼리를 수행하지 않도록 주의합니다.
    -   **12.3.4. 캐싱 전략 적극 활용:**
        -   **인메모리 캐시 (단일 인스턴스):** 자주 접근하지만 변경이 적은 데이터를 인스턴스 메모리에 캐시합니다. (주의: 여러 인스턴스 환경에서는 데이터 불일치 문제 발생 가능)
        -   **외부 캐시 서비스 활용 (Memorystore for Redis/Memcached):** 여러 인스턴스 간 공유 가능한 고성능 캐시를 사용합니다.
        -   **API 응답 캐싱 (Cloud CDN, API Gateway):** 자주 변경되지 않는 API 응답은 CDN이나 API Gateway 캐시를 활용하여 응답 시간을 단축하고 백엔드 부하를 줄입니다.
    -   **12.3.5. 코드 및 로직 최적화:** 비효율적인 알고리즘이나 루프를 개선하고, 불필요한 계산을 줄입니다.

-   **12.4. 성능 모니터링 및 테스트:**
    -   **GCP Cloud Monitoring, Cloud Trace, Cloud Logging** 등을 활용하여 실시간으로 애플리케이션 성능 지표를 모니터링합니다.
    -   **부하 테스트 도구 (Load Testing Tools):** k6, JMeter, Locust 등을 사용하여 예상 트래픽 상황에서의 시스템 성능을 테스트하고 병목 지점을 파악합니다.
    -   주기적인 성능 테스트 및 튜닝을 통해 지속적으로 성능을 관리합니다.

---

## 13. 🌍 국제화(i18n) 및 지역화(l10n) 가이드라인 (Flutter)

> **요약:** Flutter 앱의 다국어 지원을 위한 표준 방법과 Google 서비스 활용 방안을 안내합니다. 사용자에게 친숙한 언어 환경을 제공하여 글로벌 사용자를 확보하는 것을 목표로 합니다.

-   **13.1. 기본 프레임워크 및 패키지:**
    -   **`flutter_localizations` 패키지 사용:** Flutter의 공식 국제화 지원을 위해 `MaterialApp` 또는 `CupertinoApp`의 `localizationsDelegates`와 `supportedLocales`를 설정합니다. 이는 Material 및 Cupertino 위젯의 기본 지역화된 문자열, 날짜/시간 형식 등을 제공합니다.
    -   **`intl` 패키지 사용:** 앱 내 사용자 정의 문자열(UI 텍스트, 메시지 등) 관리를 위해 `intl` 패키지를 사용합니다. 모든 문자열은 하드코딩하지 않고 `intl`을 통해 지역화된 문자열을 참조합니다.

-   **13.2. 문자열 리소스 관리:**
    -   **`.arb` (Application Resource Bundle) 파일 형식 사용:** 지역화될 문자열은 `.arb` 파일로 관리하며, 각 지원 언어별로 별도의 파일을 생성합니다. (예: `lib/l10n/app_en.arb` (영어), `lib/l10n/app_ko.arb` (한국어))
    -   **명확한 키(Key) 이름 정의:** 문자열을 식별하는 키는 명확하고 일관성 있게 정의합니다. (예: `loginButtonText`, `welcomeMessage`)
    -   **자동 코드 생성 도구 활용:** `intl_utils` 패키지 또는 IDE 플러그인(VS Code의 "Flutter Intl" 등)을 활용하여 `.arb` 파일로부터 Dart 코드를 자동으로 생성하고 관리하여 개발 편의성을 높입니다.

-   **13.3. 번역 관리 및 자동화 (Google 서비스 활용 옵션):**
    -   **13.3.1. (권장) Google Sheets를 번역 관리 도구로 활용:**
        -   번역 문자열 관리를 위해 Google Sheets를 중앙 저장소로 사용할 수 있습니다. (컬럼 예시: `key`, `en_US_description`, `en_US_translation`, `ko_KR_description`, `ko_KR_translation` 등)
        -   Google Apps Script 또는 별도의 스크립트를 통해 Google Sheets의 내용을 각 언어별 `.arb` 파일로 자동 변환하고 프로젝트에 통합하는 워크플로우 구축을 고려합니다. 이를 통해 번역가나 기획자와의 협업이 용이해집니다.
    -   **13.3.2. (보조적) Google Cloud Translation API 활용:**
        -   초기 대량 번역이나 새로운 언어 추가 시 Google Cloud Translation API를 보조적으로 사용할 수 있습니다.
        -   **주의:** API를 통해 생성된 기계 번역은 반드시 **원어민 또는 전문 번역가의 검토 및 수정 과정**을 거쳐야 합니다. 번역 품질의 한계를 인지하고 사용해야 하며, API 사용 비용이 발생할 수 있습니다.
        -   번역된 결과는 최종적으로 `.arb` 파일 형식으로 통합하여 관리합니다.

-   **13.4. 동적 문자열 업데이트 (선택적/제한적 사용):**
    -   앱을 새로 빌드하고 배포하지 않고 특정 문자열(예: 긴급 공지, 프로모션 문구)을 수정해야 하거나, A/B 테스트를 위해 동적으로 문자열을 변경해야 할 경우, **Firebase Remote Config** 또는 **Firestore**를 활용할 수 있습니다.
    -   이 방식은 전체 앱 문자열이 아닌, **매우 제한적인 경우에만 사용하는 것을 권장**합니다.
    -   동적으로 로드된 문자열도 숫자/날짜 포맷팅, 복수형 처리 등은 `intl` 패키지의 기능을 활용할 수 있도록 설계합니다.
    -   오프라인 지원 및 초기 로딩 성능에 미치는 영향을 고려하여 신중하게 도입합니다.

-   **13.5. 포맷팅 및 복수형/성별 처리:**
    -   **날짜, 숫자, 통화 포맷팅:** `intl` 패키지에서 제공하는 `DateFormat`, `NumberFormat` 등을 사용하여 각 로케일에 맞는 형식으로 표시합니다.
    -   **복수형(Plurals) 및 성별(Gender) 처리:** 언어에 따라 단어 형태가 바뀌는 경우, `Intl.plural` 및 `Intl.gender` 기능을 활용하여 정확한 문자열을 제공합니다. (예: `1 file` vs `2 files`)

-   **13.6. 국제화 테스트:**
    -   각 지원 언어별로 UI가 올바르게 표시되고, 텍스트 잘림(overflow), 레이아웃 깨짐 등이 없는지 다양한 기기 및 화면 크기에서 철저히 테스트합니다.
    -   앱 내에 로케일 변경 기능을 제공하거나 개발자 옵션으로 두어 테스트 용이성을 확보합니다.
    -   의사 로케일(Pseudo-locales)을 사용하여 번역되지 않은 문자열을 쉽게 식별하거나, 긴 문자열로 인한 UI 문제를 미리 발견하는 데 활용할 수 있습니다.

---

## 14. ♿ 접근성(Accessibility - a11y) 가이드라인 (Flutter)

> **요약:** 모든 사용자가 앱을 편리하게 사용할 수 있도록 Flutter 앱의 접근성을 향상시키기 위한 주요 원칙과 실천 방안을 안내합니다. 이는 법적 요구사항 충족뿐만 아니라 더 넓은 사용자층을 포용하는 데 기여합니다.

-   **14.1. 접근성의 중요성:**
    -   장애가 있는 사용자(시각, 청각, 지체, 인지 등)도 앱의 정보와 기능을 동등하게 이용할 수 있도록 보장합니다.
    -   더 넓은 사용자층에게 긍정적인 사용자 경험을 제공합니다.
    -   일부 국가/지역에서는 법적 요구사항일 수 있습니다.

-   **14.2. Flutter 접근성 기본 원칙:**
    -   **14.2.1. 의미 있는 위젯 사용 및 정보 제공 (Semantics):**
        -   `Semantics` 위젯을 명시적으로 사용하여 스크린 리더(TalkBack, VoiceOver 등) 사용자에게 위젯의 역할, 상태, 값 등에 대한 명확한 정보를 전달합니다.
        -   버튼, 아이콘 등 시각적 요소만으로는 의미 전달이 어려운 경우 `label`, `hint`, `value` 등의 `SemanticsProperties`를 적절히 설정합니다.
        -   `ExcludeSemantics` 위젯을 사용하여 스크린 리더에 불필요한 정보를 숨기고, `MergeSemantics` 위젯으로 관련된 정보들을 하나의 의미 단위로 그룹화할 수 있습니다.
    -   **14.2.2. 충분한 터치 영역 확보:**
        -   버튼, 아이콘, 링크 등 모든 인터랙티브 요소는 사용자가 쉽게 탭하거나 클릭할 수 있도록 충분한 크기(Material Design 권장 최소 48x48 dp)와 간격을 가져야 합니다.
        -   `InkWell`, `GestureDetector` 등의 터치 영역을 시각적 표현보다 넓게 설정하는 것을 고려합니다.
    -   **14.2.3. 명도 대비 준수:**
        -   텍스트와 배경, 아이콘과 배경 간의 명도 대비는 WCAG (Web Content Accessibility Guidelines) 2.1 AA 레벨 기준(일반 텍스트 4.5:1, 큰 텍스트 3:1) 이상을 충족하도록 합니다.
        -   Flutter DevTools의 "Highlight oversized images" 기능처럼, 명도 대비 검사 도구를 활용하여 확인합니다.
    -   **14.2.4. 키보드 네비게이션 및 포커스 관리:**
        -   모든 인터랙티브 요소는 키보드(하드웨어 또는 가상)만으로도 접근하고 조작할 수 있어야 합니다.
        -   포커스 순서가 논리적이고 예측 가능하도록 관리합니다. `FocusNode`, `FocusScopeNode` 등을 활용합니다.
        -   현재 포커스된 요소는 시각적으로 명확하게 구분되어야 합니다.
    -   **14.2.5. 콘텐츠 크기 조절 지원:**
        -   사용자가 시스템 설정에서 글꼴 크기를 변경했을 때 앱의 텍스트 크기도 적절히 조절되고, 레이아웃이 깨지지 않도록 합니다. (`MediaQuery.textScaleFactor` 활용)
    -   **14.2.6. 이미지 및 미디어 대체 텍스트 제공:**
        -   의미 있는 이미지는 `Semantics` 위젯의 `label` 속성을 통해 대체 텍스트를 제공하여 스크린 리더 사용자가 이미지의 내용을 이해할 수 있도록 합니다.
        -   동영상에는 자막(captions)을, 오디오 콘텐츠에는 대본(transcript)을 제공하는 것을 고려합니다.

-   **14.3. Flutter 접근성 도구 활용:**
    -   **Flutter Inspector의 Semantics Debugger:** 시맨틱 트리를 시각화하여 스크린 리더가 앱을 어떻게 해석하는지 확인할 수 있습니다.
    -   **`showSemanticsDebugger = true;`:** `MaterialApp` 또는 `WidgetsApp` 생성자에서 이 속성을 true로 설정하면 시맨틱 정보를 화면에 오버레이로 표시하여 디버깅에 용이합니다.
    -   **다양한 보조 기술로 테스트:** 실제 스크린 리더(TalkBack, VoiceOver), 키보드 네비게이션, 글꼴 크기 조절 등을 사용하여 직접 테스트합니다.

-   **14.4. 지속적인 접근성 개선:**
    -   개발 초기 단계부터 접근성을 고려하여 설계하고 구현합니다.
    -   새로운 기능 추가 시 접근성 테스트를 포함하고, 정기적으로 접근성 검토를 수행합니다.

---

## 15. 🔍 문제 해결 전략 (Problem Solving Strategy)

> **요약:** 개발 과정에서 발생하는 다양한 문제에 효과적으로 대처하기 위한 체계적인 접근법과 사고방식을 안내합니다. 단계별 분석, 다양한 해결책 모색, 동료와의 협업, 그리고 해결 후 검토 과정을 통해 문제 해결 능력을 향상시키는 것을 목표로 합니다.

-   **15.1. 문제 정의 및 이해 (Define and Understand the Problem):**
    -   **정확한 문제 기술:** 문제가 무엇인지 명확하고 구체적으로 정의합니다. "작동하지 않는다" 와 같은 모호한 표현 대신, "X 기능을 실행했을 때 Y라는 에러 메시지가 발생하며 Z 현상이 나타난다" 와 같이 상세하게 기술합니다.
    -   **재현 단계 확인:** 문제를 일관되게 재현할 수 있는 단계를 파악합니다. 이는 문제의 원인을 찾는 데 매우 중요합니다.
    -   **기대 결과 명확화:** 정상적으로 동작했을 때 어떤 결과가 나와야 하는지 명확히 인지합니다.
    -   **범위 축소 (Scoping):** 문제가 발생하는 특정 범위(모듈, 기능, 환경 등)를 최대한 좁혀나갑니다.

-   **15.2. 정보 수집 및 분석 (Gather Information and Analyze):**
    -   **로그 확인:** 관련 로그(클라이언트 로그, 서버 로그, GCP 로그 등)를 면밀히 검토하여 에러 메시지, 스택 트레이스, 비정상적인 동작 패턴 등을 찾습니다.
    -   **디버깅 도구 활용:** 각 IDE의 디버거, Flutter DevTools, 브라우저 개발자 도구, GCP Monitoring/Trace 등을 적극적으로 사용하여 코드 실행 흐름을 추적하고 변수 값을 확인합니다.
    -   **관련 문서 및 자료 검색:** 유사한 문제에 대한 해결책이나 관련 기술 문서를 검색합니다. (공식 문서, 스택 오버플로우, 기술 블로그 등)
    -   **최근 변경 사항 검토:** 문제가 발생하기 시작한 시점과 가까운 시일 내에 변경된 코드나 설정을 확인합니다. (버전 관리 시스템 활용)

-   **15.3. 가설 수립 및 검증 (Formulate Hypotheses and Test):**
    -   **가능한 원인 나열:** 수집된 정보를 바탕으로 문제의 원인이 될 수 있는 여러 가설을 세웁니다.
    -   **가설 우선순위 결정:** 가장 가능성이 높거나 검증하기 쉬운 가설부터 테스트합니다.
    -   **체계적인 테스트:** 한 번에 하나의 가설만 검증하고, 변경 사항은 최소화하여 테스트 결과에 영향을 미칠 수 있는 다른 요인을 배제합니다.
    -   **예상 결과와 실제 결과 비교:** 테스트 결과를 예상과 비교하여 가설이 맞는지 틀린지 판단합니다.

-   **15.4. 해결책 모색 및 적용 (Identify Solutions and Implement):**
    -   **다양한 해결 방법 고려:** 문제의 근본 원인을 해결할 수 있는 여러 가지 방법을 모색합니다. (단기적인 해결책 vs 장기적인 해결책)
    -   **최적의 해결책 선택:** 각 해결책의 장단점(코드 복잡도, 성능 영향, 유지보수성, 시간 제약 등)을 비교하여 가장 적절한 방법을 선택합니다.
    -   **코드 수정 및 테스트:** 선택한 해결책을 적용하여 코드를 수정하고, 수정된 코드가 문제를 해결했는지, 그리고 다른 부작용(side effects)을 일으키지 않는지 철저히 테스트합니다. ([8. 테스트 규칙](#8--테스트-규칙-test-guidelines) 참고)

-   **15.5. 검토 및 문서화 (Review and Document):**
    -   **해결 과정 공유 (필요시):** 특히 복잡하거나 중요한 문제였을 경우, 해결 과정과 결과를 팀 내에 공유하여 지식을 전파합니다.
    -   **코드 리뷰:** 수정된 코드에 대해 코드 리뷰를 받아 다른 팀원의 검증을 거칩니다. ([9. 코드 리뷰 가이드라인](#9--코드-리뷰-가이드라인-code-review-guidelines) 참고)
    -   **문서 업데이트:** 문제의 원인, 해결 방법, 재발 방지 대책 등을 관련 문서(위키, 이슈 트래커, 코드 주석 등)에 기록합니다.
    -   **재발 방지책 강구:** 동일하거나 유사한 문제가 다시 발생하지 않도록 시스템 개선, 프로세스 변경, 추가 테스트 케이스 작성 등의 조치를 고려합니다.

-   **15.6. 협업 및 도움 요청 (Collaborate and Ask for Help):**
    -   일정 시간 이상 문제 해결에 진전이 없으면 주저하지 말고 동료에게 도움을 요청합니다. 문제를 설명하는 과정에서 스스로 해결책을 찾기도 합니다. (러버덕 디버깅)
    -   다른 사람의 관점이나 경험이 문제 해결의 실마리를 제공할 수 있습니다.
