**1. 로그인 프로세스:**

*   **프론트엔드:**
    1.  사용자가 앱/웹사이트에 처음 접속하거나 로그아웃 상태일 때 로그인 페이지를 표시합니다.
    2.  사용자가 이메일과 비밀번호를 입력하고 '로그인' 버튼을 클릭합니다.
    3.  입력된 정보를 백엔드의 로그인 API로 전송합니다. (SWR/React Query의 `useMutation` 사용)
*   **백엔드:**
    1.  전달받은 이메일과 비밀번호를 검증합니다.
    2.  인증 성공 시:
        *   사용자 정보와 함께 **액세스 토큰(Access Token)** 과 **리프레시 토큰(Refresh Token)** 을 생성하여 프론트엔드로 응답합니다. (JWT - JSON Web Token 형식이 일반적)
            *   **액세스 토큰:** 실제 API 요청 시 사용되며, 비교적 짧은 만료 시간(예: 15분, 1시간)을 가집니다.
            *   **리프레시 토큰:** 액세스 토큰이 만료되었을 때 새로운 액세스 토큰을 발급받기 위해 사용되며, 긴 만료 시간(예: 7일, 30일)을 가집니다. 보안을 위해 httpOnly 쿠키로 전달하는 것이 좋습니다.
    3.  인증 실패 시: 에러 메시지를 프론트엔드로 응답합니다.
*   **프론트엔드:**
    1.  로그인 성공 시:
        *   액세스 토큰은 JavaScript로 접근 가능한 곳(예: 메모리 내 변수 - Zustand, Jotai, Recoil 등 상태 관리 라이브러리 사용 또는 React Context)에 저장합니다.
        *   리프레시 토큰은 (만약 백엔드가 httpOnly 쿠키로 주지 않았다면) 안전한 곳(예: localStorage, sessionStorage는 XSS에 취약할 수 있으므로 주의. PWA의 경우 IndexedDB도 고려 가능하나, httpOnly 쿠키가 가장 안전)에 저장하거나, 백엔드가 httpOnly 쿠키로 설정했다면 브라우저가 자동으로 관리합니다.
        *   메인 서비스 페이지로 리디렉션합니다.
    2.  로그인 실패 시: 에러 메시지를 사용자에게 표시합니다.

**2. 자동 로그인 (앱 재실행/페이지 새로고침 시):**

*   **프론트엔드:**
    1.  앱/웹사이트가 로드될 때 (예: `App.js` 또는 최상위 컴포넌트의 `useEffect` 훅):
        *   저장된 액세스 토큰이 있는지 확인합니다.
        *   **액세스 토큰이 있고 유효하다면:** 사용자를 로그인 상태로 간주하고 메인 서비스 페이지를 바로 보여줍니다. API 요청 시 이 토큰을 사용합니다.
        *   **액세스 토큰이 없거나 만료되었다면:**
            *   저장된 리프레시 토큰이 있는지 확인합니다.
            *   **리프레시 토큰이 있다면:** 이 리프레시 토큰을 사용하여 백엔드에 새로운 액세스 토큰을 요청하는 API를 호출합니다. (SWR/React Query의 `useMutation` 또는 일반 fetch/axios 사용)
                *   새로운 액세스 토큰 발급 성공: 발급받은 액세스 토큰을 저장하고, 사용자를 로그인 상태로 간주하여 메인 서비스 페이지를 보여줍니다.
                *   새로운 액세스 토큰 발급 실패 (리프레시 토큰도 만료되었거나 유효하지 않은 경우): 사용자를 로그아웃 상태로 간주하고 로그인 페이지로 보냅니다.
            *   **리프레시 토큰도 없다면:** 사용자를 로그아웃 상태로 간주하고 로그인 페이지로 보냅니다.

**3. API 요청 시 인증 처리:**

*   **프론트엔드:**
    1.  보호된 API를 호출할 때마다 HTTP 요청 헤더(일반적으로 `Authorization` 헤더)에 액세스 토큰을 포함하여 전송합니다. (예: `Authorization: Bearer <access_token>`)
    2.  SWR/React Query 또는 사용 중인 HTTP 클라이언트(Fetch, Ky, Axios)의 인터셉터 기능을 활용하면 모든 요청에 자동으로 토큰을 추가하거나, 토큰 만료 시 리프레시 로직을 수행하기 편리합니다.
*   **백엔드:**
    1.  API 요청 수신 시 헤더에서 액세스 토큰을 추출하고 유효성을 검증합니다.
    2.  토큰이 유효하면 요청을 처리하고, 유효하지 않거나 만료된 경우 401 Unauthorized 에러를 응답합니다.

**4. 로그아웃 처리:**

*   **프론트엔드:**
    1.  '로그아웃' 버튼 클릭 시:
        *   저장된 액세스 토큰과 리프레시 토큰을 클라이언트 측에서 삭제합니다.
        *   (선택 사항/권장) 백엔드에 로그아웃 API를 호출하여 서버 측에서도 리프레시 토큰을 무효화하도록 요청합니다 (보안 강화).
        *   사용자를 로그인 페이지로 리디렉션합니다.

**기술 스택 관점:**

*   **상태 관리 (액세스 토큰 저장, 로그인 상태 등):**
    *   Zustand, Jotai, Recoil 같은 가벼운 상태 관리 라이브러리가 유용합니다. 로그인 상태, 사용자 정보, 액세스 토큰 등을 전역적으로 관리할 수 있습니다.
    *   React Context API도 사용할 수 있지만, 상태 업데이트에 따른 불필요한 리렌더링을 주의해야 합니다.
*   **토큰 저장:**
    *   **액세스 토큰:** 메모리(상태 관리 라이브러리 변수)에 저장하는 것이 XSS 공격으로부터 비교적 안전합니다. 페이지 새로고침 시 사라지므로, 초기 로드 시 리프레시 토큰으로 재발급받는 로직이 중요합니다.
    *   **리프레시 토큰:**
        *   **가장 안전한 방법:** 백엔드에서 `HttpOnly`, `Secure`, `SameSite=Strict` (또는 `Lax`) 플래그가 설정된 쿠키로 전달받아 브라우저가 자동으로 관리하도록 하는 것입니다. JavaScript로 접근이 불가능하여 XSS에 안전합니다.
        *   **차선책 (HttpOnly 쿠키 사용 불가 시):** PWA의 경우 `IndexedDB`에 암호화하여 저장하는 것을 고려할 수 있으나, 구현 복잡도가 올라갑니다. `localStorage`는 XSS에 취약하여 민감한 정보 저장에는 권장되지 않습니다.
*   **라우팅 (로그인 상태에 따른 페이지 접근 제어):**
    *   React Router의 `Outlet`, `Navigate` 컴포넌트와 커스텀 훅을 조합하여 "보호된 라우트(Protected Route)" 및 "공개 라우트(Public Route)"를 구현합니다.
    *   예: 로그인 상태면 `/login` 접근 시 메인 페이지로 리디렉션, 비로그인 상태면 `/dashboard` 접근 시 `/login` 페이지로 리디렉션.

**추가 질문 및 논의 사항:**

*   **리프레시 토큰을 백엔드에서 HttpOnly 쿠키로 처리해 줄 수 있나요?** 이것이 가능하다면 프론트엔드에서 리프레시 토큰을 직접 관리할 필요가 없어 구현이 간단해지고 보안도 향상됩니다.
*   **비밀번호 관련 정책:**
    *   최초 로그인 시 비밀번호 변경을 강제하거나 권장할 필요가 있을까요? (가입이 없으므로 관리자가 초기 비밀번호를 설정해줄 텐데, 보안상 변경하는 것이 좋을 수 있습니다.)
    *   비밀번호 분실 시 처리 프로세스는 어떻게 할 예정인가요? (예: 관리자에게 문의하여 초기화)
