# 5ï¸âƒ£ ì‹¤ì‹œê°„ ê¸°ëŠ¥ êµ¬í˜„ ê°€ì´ë“œ

## ğŸ¯ **ëª©í‘œ**
WebSocketì„ ì‚¬ìš©í•˜ì—¬ íšŒì˜ì‹¤ ì˜ˆì•½ ì‹œìŠ¤í…œì˜ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ê¸°ëŠ¥ì„ êµ¬í˜„í•©ë‹ˆë‹¤. ë‹¤ë¥¸ ì‚¬ìš©ìì˜ ì˜ˆì•½ ìƒì„±/ìˆ˜ì •/ì‚­ì œ, íšŒì˜ì‹¤ ìƒíƒœ ë³€ê²½ ë“±ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°˜ì˜í•©ë‹ˆë‹¤.

---

## ğŸ“‹ **ì‹¤ì‹œê°„ ê¸°ëŠ¥ ëª©ë¡**

### ğŸ”„ **ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ëŒ€ìƒ**
- **ì˜ˆì•½ ê´€ë ¨**
  - ìƒˆ ì˜ˆì•½ ìƒì„±/ìˆ˜ì •/ì·¨ì†Œ ì•Œë¦¼
  - ì˜ˆì•½ ìƒíƒœ ë³€ê²½ (ìŠ¹ì¸/ê±°ì ˆ)
  - ì˜ˆì•½ ì¶©ëŒ ê°ì§€ ë° ì•Œë¦¼

- **íšŒì˜ì‹¤ ê´€ë ¨**
  - íšŒì˜ì‹¤ ìƒíƒœ ë³€ê²½ (ì‚¬ìš© ì¤‘/ì‚¬ìš© ê°€ëŠ¥)
  - íšŒì˜ì‹¤ ì •ë³´ ì—…ë°ì´íŠ¸
  - íšŒì˜ì‹¤ ì¶”ê°€/ì‚­ì œ

- **ì‹œìŠ¤í…œ ì•Œë¦¼**
  - ì‚¬ìš©ì ì ‘ì†/í•´ì œ ìƒíƒœ
  - ì‹œìŠ¤í…œ ê³µì§€ì‚¬í•­
  - ê¸´ê¸‰ ì•Œë¦¼

---

## ğŸ”Œ **1ë‹¨ê³„: WebSocket í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„**

### `src/services/websocket.ts`
```typescript
import { WS_URL } from '@/utils/constants';

/**
 * WebSocket ì´ë²¤íŠ¸ íƒ€ì… ì •ì˜
 */
export interface WebSocketEvent {
  type: string;
  data: any;
  timestamp: string;
  userId?: string;
}

/**
 * ì˜ˆì•½ ê´€ë ¨ ì´ë²¤íŠ¸ íƒ€ì…
 */
export interface ReservationEvent extends WebSocketEvent {
  type: 
    | 'reservation:created'
    | 'reservation:updated' 
    | 'reservation:cancelled'
    | 'reservation:deleted';
  data: {
    reservation: any; // Reservation íƒ€ì…
    roomId: string;
    userId: string;
  };
}

/**
 * íšŒì˜ì‹¤ ê´€ë ¨ ì´ë²¤íŠ¸ íƒ€ì…
 */
export interface RoomEvent extends WebSocketEvent {
  type: 
    | 'room:created'
    | 'room:updated'
    | 'room:deleted'
    | 'room:status_changed';
  data: {
    room: any; // Room íƒ€ì…
    previousStatus?: string;
  };
}

/**
 * ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ íƒ€ì…
 */
export interface SystemEvent extends WebSocketEvent {
  type: 
    | 'user:connected'
    | 'user:disconnected'
    | 'system:notification'
    | 'system:maintenance';
  data: {
    message: string;
    userId?: string;
    level?: 'info' | 'warning' | 'error';
  };
}

/**
 * ëª¨ë“  ì´ë²¤íŠ¸ íƒ€ì…ì˜ ìœ ë‹ˆì˜¨
 */
export type SocketEvent = ReservationEvent | RoomEvent | SystemEvent;

/**
 * ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ íƒ€ì…
 */
export type EventHandler<T = any> = (event: T) => void;

/**
 * WebSocket ì—°ê²° ìƒíƒœ
 */
export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';

/**
 * WebSocket í´ë¼ì´ì–¸íŠ¸ ì˜µì…˜
 */
interface WebSocketClientOptions {
  autoReconnect?: boolean;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
  pingInterval?: number;
}

/**
 * WebSocket í´ë¼ì´ì–¸íŠ¸ í´ë˜ìŠ¤
 */
export class WebSocketClient {
  private ws: WebSocket | null = null;
  private eventHandlers: Map<string, EventHandler[]> = new Map();
  private reconnectTimer: NodeJS.Timeout | null = null;
  private pingTimer: NodeJS.Timeout | null = null;
  private reconnectAttempts = 0;
  private status: ConnectionStatus = 'disconnected';
  private statusHandlers: EventHandler<ConnectionStatus>[] = [];

  constructor(
    private url: string,
    private options: WebSocketClientOptions = {}
  ) {
    this.options = {
      autoReconnect: true,
      reconnectInterval: 3000,
      maxReconnectAttempts: 5,
      pingInterval: 30000,
      ...options,
    };
  }

  /**
   * WebSocket ì—°ê²°
   */
  connect(token?: string): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      return;
    }

    this.setStatus('connecting');

    // í† í°ì´ ìˆìœ¼ë©´ URLì— ì¶”ê°€
    const wsUrl = token ? `${this.url}?token=${token}` : this.url;
    
    try {
      this.ws = new WebSocket(wsUrl);
      this.setupEventListeners();
    } catch (error) {
      console.error('WebSocket connection failed:', error);
      this.setStatus('error');
      this.handleReconnection();
    }
  }

  /**
   * WebSocket ì—°ê²° í•´ì œ
   */
  disconnect(): void {
    this.options.autoReconnect = false;
    this.clearTimers();
    
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    
    this.setStatus('disconnected');
  }

  /**
   * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
   */
  private setupEventListeners(): void {
    if (!this.ws) return;

    this.ws.onopen = () => {
      console.log('WebSocket connected');
      this.setStatus('connected');
      this.reconnectAttempts = 0;
      this.startPing();
    };

    this.ws.onmessage = (event) => {
      try {
        const socketEvent: SocketEvent = JSON.parse(event.data);
        this.handleEvent(socketEvent);
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error);
      }
    };

    this.ws.onclose = (event) => {
      console.log('WebSocket disconnected:', event.code, event.reason);
      this.setStatus('disconnected');
      this.clearTimers();
      
      if (this.options.autoReconnect && event.code !== 1000) {
        this.handleReconnection();
      }
    };

    this.ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      this.setStatus('error');
    };
  }

  /**
   * ì´ë²¤íŠ¸ í•¸ë“¤ë§
   */
  private handleEvent(event: SocketEvent): void {
    const handlers = this.eventHandlers.get(event.type) || [];
    handlers.forEach(handler => {
      try {
        handler(event);
      } catch (error) {
        console.error(`Error in event handler for ${event.type}:`, error);
      }
    });

    // ì „ì²´ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì‹¤í–‰
    const allHandlers = this.eventHandlers.get('*') || [];
    allHandlers.forEach(handler => {
      try {
        handler(event);
      } catch (error) {
        console.error('Error in global event handler:', error);
      }
    });
  }

  /**
   * ì¬ì—°ê²° ì²˜ë¦¬
   */
  private handleReconnection(): void {
    if (
      !this.options.autoReconnect ||
      this.reconnectAttempts >= this.options.maxReconnectAttempts!
    ) {
      return;
    }

    this.reconnectAttempts++;
    console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.options.maxReconnectAttempts})`);

    this.reconnectTimer = setTimeout(() => {
      const token = localStorage.getItem('token');
      this.connect(token || undefined);
    }, this.options.reconnectInterval);
  }

  /**
   * Ping ì‹œì‘
   */
  private startPing(): void {
    this.pingTimer = setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.send('ping', {});
      }
    }, this.options.pingInterval);
  }

  /**
   * íƒ€ì´ë¨¸ ì •ë¦¬
   */
  private clearTimers(): void {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    
    if (this.pingTimer) {
      clearInterval(this.pingTimer);
      this.pingTimer = null;
    }
  }

  /**
   * ì—°ê²° ìƒíƒœ ì„¤ì •
   */
  private setStatus(status: ConnectionStatus): void {
    this.status = status;
    this.statusHandlers.forEach(handler => handler(status));
  }

  /**
   * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
   */
  on<T = any>(eventType: string, handler: EventHandler<T>): void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, []);
    }
    this.eventHandlers.get(eventType)!.push(handler);
  }

  /**
   * ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
   */
  off(eventType: string, handler: EventHandler): void {
    const handlers = this.eventHandlers.get(eventType);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    }
  }

  /**
   * ì—°ê²° ìƒíƒœ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
   */
  onStatusChange(handler: EventHandler<ConnectionStatus>): void {
    this.statusHandlers.push(handler);
  }

  /**
   * ì—°ê²° ìƒíƒœ ë¦¬ìŠ¤ë„ˆ ì œê±°
   */
  offStatusChange(handler: EventHandler<ConnectionStatus>): void {
    const index = this.statusHandlers.indexOf(handler);
    if (index > -1) {
      this.statusHandlers.splice(index, 1);
    }
  }

  /**
   * ë©”ì‹œì§€ ì „ì†¡
   */
  send(type: string, data: any): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      const message: WebSocketEvent = {
        type,
        data,
        timestamp: new Date().toISOString(),
      };
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket is not connected. Cannot send message.');
    }
  }

  /**
   * í˜„ì¬ ì—°ê²° ìƒíƒœ ë°˜í™˜
   */
  getStatus(): ConnectionStatus {
    return this.status;
  }

  /**
   * ì—°ê²° ì—¬ë¶€ í™•ì¸
   */
  isConnected(): boolean {
    return this.status === 'connected';
  }
}

/**
 * ê¸€ë¡œë²Œ WebSocket í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤
 */
export const wsClient = new WebSocketClient(WS_URL);
```

---

## ğŸ£ **2ë‹¨ê³„: React í›… êµ¬í˜„**

### `src/hooks/useWebSocket.ts`
```typescript
import { useEffect, useRef, useCallback } from 'react';
import { wsClient, EventHandler, ConnectionStatus, SocketEvent } from '@/services/websocket';

/**
 * WebSocket ì—°ê²° ê´€ë¦¬ í›…
 */
export const useWebSocket = () => {
  const isInitialized = useRef(false);

  useEffect(() => {
    if (!isInitialized.current) {
      const token = localStorage.getItem('token');
      if (token) {
        wsClient.connect(token);
        isInitialized.current = true;
      }
    }

    return () => {
      // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì—°ê²° í•´ì œ
      wsClient.disconnect();
      isInitialized.current = false;
    };
  }, []);

  const send = useCallback((type: string, data: any) => {
    wsClient.send(type, data);
  }, []);

  return {
    send,
    isConnected: wsClient.isConnected(),
    status: wsClient.getStatus(),
  };
};

/**
 * íŠ¹ì • ì´ë²¤íŠ¸ íƒ€ì…ì„ êµ¬ë…í•˜ëŠ” í›…
 */
export const useWebSocketEvent = <T = any>(
  eventType: string,
  handler: EventHandler<T>,
  deps: React.DependencyList = []
) => {
  const handlerRef = useRef(handler);

  // í•¸ë“¤ëŸ¬ ì°¸ì¡° ì—…ë°ì´íŠ¸
  useEffect(() => {
    handlerRef.current = handler;
  }, [handler]);

  useEffect(() => {
    const wrappedHandler = (event: T) => {
      handlerRef.current(event);
    };

    wsClient.on(eventType, wrappedHandler);

    return () => {
      wsClient.off(eventType, wrappedHandler);
    };
  }, [eventType, ...deps]);
};

/**
 * ì—°ê²° ìƒíƒœë¥¼ ê´€ë¦¬í•˜ëŠ” í›…
 */
export const useWebSocketStatus = () => {
  const [status, setStatus] = useState<ConnectionStatus>('disconnected');

  useEffect(() => {
    const handleStatusChange = (newStatus: ConnectionStatus) => {
      setStatus(newStatus);
    };

    wsClient.onStatusChange(handleStatusChange);
    setStatus(wsClient.getStatus());

    return () => {
      wsClient.offStatusChange(handleStatusChange);
    };
  }, []);

  return status;
};
```

### `src/hooks/useRealtimeReservations.ts`
```typescript
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { useWebSocketEvent } from './useWebSocket';
import { queryKeys } from '@/lib/queryClient';
import { ReservationEvent } from '@/services/websocket';
import { Reservation } from '@/types/reservation';

/**
 * ì˜ˆì•½ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 */
export const useRealtimeReservations = () => {
  const queryClient = useQueryClient();

  // ì˜ˆì•½ ìƒì„± ì´ë²¤íŠ¸
  useWebSocketEvent<ReservationEvent>(
    'reservation:created',
    (event) => {
      console.log('New reservation created:', event.data.reservation);
      
      // ì˜ˆì•½ ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.reservations.lists() });
      
      // í•´ë‹¹ íšŒì˜ì‹¤ì˜ ì˜ˆì•½ ëª©ë¡ë„ ë¬´íš¨í™”
      queryClient.invalidateQueries({ 
        queryKey: queryKeys.rooms.detail(event.data.roomId) 
      });
      
      // ëŒ€ì‹œë³´ë“œ í†µê³„ ì—…ë°ì´íŠ¸
      queryClient.invalidateQueries({ queryKey: ['dashboard', 'stats'] });
    }
  );

  // ì˜ˆì•½ ìˆ˜ì • ì´ë²¤íŠ¸
  useWebSocketEvent<ReservationEvent>(
    'reservation:updated',
    (event) => {
      console.log('Reservation updated:', event.data.reservation);
      
      const reservation = event.data.reservation;
      
      // íŠ¹ì • ì˜ˆì•½ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(
        queryKeys.reservations.detail(reservation.id),
        reservation
      );
      
      // ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.reservations.lists() });
    }
  );

  // ì˜ˆì•½ ì·¨ì†Œ ì´ë²¤íŠ¸
  useWebSocketEvent<ReservationEvent>(
    'reservation:cancelled',
    (event) => {
      console.log('Reservation cancelled:', event.data.reservation);
      
      // ê´€ë ¨ ì¿¼ë¦¬ë“¤ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.reservations.lists() });
      queryClient.invalidateQueries({ 
        queryKey: queryKeys.rooms.detail(event.data.roomId) 
      });
    }
  );

  // ì˜ˆì•½ ì‚­ì œ ì´ë²¤íŠ¸
  useWebSocketEvent<ReservationEvent>(
    'reservation:deleted',
    (event) => {
      console.log('Reservation deleted:', event.data.reservation);
      
      // ìºì‹œì—ì„œ í•´ë‹¹ ì˜ˆì•½ ì œê±°
      queryClient.removeQueries({ 
        queryKey: queryKeys.reservations.detail(event.data.reservation.id) 
      });
      
      // ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.reservations.lists() });
    }
  );
};
```

### `src/hooks/useRealtimeRooms.ts`
```typescript
import { useQueryClient } from '@tanstack/react-query';
import { useWebSocketEvent } from './useWebSocket';
import { queryKeys } from '@/lib/queryClient';
import { RoomEvent } from '@/services/websocket';

/**
 * íšŒì˜ì‹¤ ê´€ë ¨ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í›…
 */
export const useRealtimeRooms = () => {
  const queryClient = useQueryClient();

  // íšŒì˜ì‹¤ ìƒì„± ì´ë²¤íŠ¸
  useWebSocketEvent<RoomEvent>(
    'room:created',
    (event) => {
      console.log('New room created:', event.data.room);
      
      // íšŒì˜ì‹¤ ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.rooms.lists() });
    }
  );

  // íšŒì˜ì‹¤ ìˆ˜ì • ì´ë²¤íŠ¸
  useWebSocketEvent<RoomEvent>(
    'room:updated',
    (event) => {
      console.log('Room updated:', event.data.room);
      
      const room = event.data.room;
      
      // íŠ¹ì • íšŒì˜ì‹¤ ìºì‹œ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(queryKeys.rooms.detail(room.id), room);
      
      // ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.rooms.lists() });
    }
  );

  // íšŒì˜ì‹¤ ìƒíƒœ ë³€ê²½ ì´ë²¤íŠ¸
  useWebSocketEvent<RoomEvent>(
    'room:status_changed',
    (event) => {
      console.log('Room status changed:', event.data.room);
      
      const room = event.data.room;
      
      // ì‹¤ì‹œê°„ìœ¼ë¡œ íšŒì˜ì‹¤ ìƒíƒœ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(queryKeys.rooms.detail(room.id), room);
      
      // ëª©ë¡ì—ì„œë„ í•´ë‹¹ íšŒì˜ì‹¤ ìƒíƒœ ì—…ë°ì´íŠ¸
      queryClient.setQueryData(
        queryKeys.rooms.lists(),
        (oldData: any) => {
          if (!oldData) return oldData;
          
          return {
            ...oldData,
            items: oldData.items.map((item: any) => 
              item.id === room.id ? { ...item, ...room } : item
            ),
          };
        }
      );
    }
  );

  // íšŒì˜ì‹¤ ì‚­ì œ ì´ë²¤íŠ¸
  useWebSocketEvent<RoomEvent>(
    'room:deleted',
    (event) => {
      console.log('Room deleted:', event.data.room);
      
      // ìºì‹œì—ì„œ í•´ë‹¹ íšŒì˜ì‹¤ ì œê±°
      queryClient.removeQueries({ 
        queryKey: queryKeys.rooms.detail(event.data.room.id) 
      });
      
      // ëª©ë¡ ì¿¼ë¦¬ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: queryKeys.rooms.lists() });
    }
  );
};
```

---

## ğŸ”” **3ë‹¨ê³„: ì‹¤ì‹œê°„ ì•Œë¦¼ ì‹œìŠ¤í…œ**

### `src/hooks/useNotifications.ts`
```typescript
import { useState, useCallback } from 'react';
import { useWebSocketEvent } from './useWebSocket';
import { SystemEvent } from '@/services/websocket';

/**
 * ì•Œë¦¼ íƒ€ì… ì •ì˜
 */
export interface Notification {
  id: string;
  type: 'info' | 'warning' | 'error' | 'success';
  title: string;
  message: string;
  timestamp: string;
  read: boolean;
  action?: {
    label: string;
    onClick: () => void;
  };
}

/**
 * ì‹¤ì‹œê°„ ì•Œë¦¼ ê´€ë¦¬ í›…
 */
export const useNotifications = () => {
  const [notifications, setNotifications] = useState<Notification[]>([]);

  // ì‹œìŠ¤í…œ ì•Œë¦¼ ì´ë²¤íŠ¸ êµ¬ë…
  useWebSocketEvent<SystemEvent>(
    'system:notification',
    (event) => {
      const notification: Notification = {
        id: Date.now().toString(),
        type: event.data.level || 'info',
        title: 'ì‹œìŠ¤í…œ ì•Œë¦¼',
        message: event.data.message,
        timestamp: event.timestamp,
        read: false,
      };
      
      setNotifications(prev => [notification, ...prev]);
      
      // ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ (ê¶Œí•œì´ ìˆëŠ” ê²½ìš°)
      if (Notification.permission === 'granted') {
        new Notification(notification.title, {
          body: notification.message,
          icon: '/icon-192x192.png',
        });
      }
    }
  );

  // ì˜ˆì•½ ê´€ë ¨ ì•Œë¦¼
  useWebSocketEvent(
    'reservation:created',
    (event) => {
      const currentUserId = localStorage.getItem('userId');
      if (event.data.userId !== currentUserId) {
        const notification: Notification = {
          id: Date.now().toString(),
          type: 'info',
          title: 'ìƒˆ ì˜ˆì•½',
          message: `${event.data.reservation.room.name}ì— ìƒˆë¡œìš´ ì˜ˆì•½ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`,
          timestamp: event.timestamp,
          read: false,
        };
        
        setNotifications(prev => [notification, ...prev]);
      }
    }
  );

  // ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  const markAsRead = useCallback((id: string) => {
    setNotifications(prev => 
      prev.map(notification => 
        notification.id === id 
          ? { ...notification, read: true }
          : notification
      )
    );
  }, []);

  // ì•Œë¦¼ ì‚­ì œ
  const removeNotification = useCallback((id: string) => {
    setNotifications(prev => prev.filter(notification => notification.id !== id));
  }, []);

  // ëª¨ë“  ì•Œë¦¼ ì½ìŒ ì²˜ë¦¬
  const markAllAsRead = useCallback(() => {
    setNotifications(prev => 
      prev.map(notification => ({ ...notification, read: true }))
    );
  }, []);

  // ëª¨ë“  ì•Œë¦¼ ì‚­ì œ
  const clearAll = useCallback(() => {
    setNotifications([]);
  }, []);

  // ì½ì§€ ì•Šì€ ì•Œë¦¼ ê°œìˆ˜
  const unreadCount = notifications.filter(n => !n.read).length;

  return {
    notifications,
    unreadCount,
    markAsRead,
    removeNotification,
    markAllAsRead,
    clearAll,
  };
};
```

### `src/components/common/NotificationBell.tsx`
```typescript
import { useState } from 'react';
import { Bell } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuHeader,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Badge } from '@/components/ui/badge';
import { useNotifications } from '@/hooks/useNotifications';
import { formatDistanceToNow } from 'date-fns';
import { ko } from 'date-fns/locale';

/**
 * ì•Œë¦¼ ë²¨ ì»´í¬ë„ŒíŠ¸
 */
export const NotificationBell: React.FC = () => {
  const [open, setOpen] = useState(false);
  const {
    notifications,
    unreadCount,
    markAsRead,
    markAllAsRead,
    clearAll,
  } = useNotifications();

  const getNotificationIcon = (type: string) => {
    const icons = {
      info: 'ğŸ“¢',
      warning: 'âš ï¸',
      error: 'âŒ',
      success: 'âœ…',
    };
    return icons[type as keyof typeof icons] || 'ğŸ“¢';
  };

  const getNotificationColor = (type: string) => {
    const colors = {
      info: 'bg-blue-50 border-blue-200',
      warning: 'bg-yellow-50 border-yellow-200',
      error: 'bg-red-50 border-red-200',
      success: 'bg-green-50 border-green-200',
    };
    return colors[type as keyof typeof colors] || 'bg-gray-50 border-gray-200';
  };

  return (
    <DropdownMenu open={open} onOpenChange={setOpen}>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="sm" className="relative">
          <Bell className="h-4 w-4" />
          {unreadCount > 0 && (
            <Badge 
              variant="destructive" 
              className="absolute -top-1 -right-1 h-5 w-5 p-0 flex items-center justify-center text-xs"
            >
              {unreadCount > 99 ? '99+' : unreadCount}
            </Badge>
          )}
        </Button>
      </DropdownMenuTrigger>
      
      <DropdownMenuContent align="end" className="w-80 max-h-96 overflow-y-auto">
        <DropdownMenuHeader className="font-semibold">
          ì•Œë¦¼ {unreadCount > 0 && `(${unreadCount})`}
        </DropdownMenuHeader>
        
        {notifications.length > 0 && (
          <>
            <DropdownMenuSeparator />
            <div className="flex gap-2 p-2">
              <Button 
                variant="outline" 
                size="sm" 
                onClick={markAllAsRead}
                disabled={unreadCount === 0}
              >
                ëª¨ë‘ ì½ìŒ
              </Button>
              <Button 
                variant="outline" 
                size="sm" 
                onClick={clearAll}
              >
                ëª¨ë‘ ì‚­ì œ
              </Button>
            </div>
          </>
        )}
        
        <DropdownMenuSeparator />
        
        {notifications.length === 0 ? (
          <div className="p-4 text-center text-muted-foreground">
            ìƒˆë¡œìš´ ì•Œë¦¼ì´ ì—†ìŠµë‹ˆë‹¤
          </div>
        ) : (
          <div className="max-h-64 overflow-y-auto">
            {notifications.slice(0, 10).map((notification) => (
              <DropdownMenuItem
                key={notification.id}
                className={`p-3 cursor-pointer ${
                  !notification.read ? 'bg-blue-50' : ''
                }`}
                onClick={() => markAsRead(notification.id)}
              >
                <div className="flex items-start gap-3 w-full">
                  <span className="text-lg">
                    {getNotificationIcon(notification.type)}
                  </span>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <p className="font-medium text-sm truncate">
                        {notification.title}
                      </p>
                      {!notification.read && (
                        <div className="w-2 h-2 bg-blue-500 rounded-full flex-shrink-0" />
                      )}
                    </div>
                    <p className="text-xs text-muted-foreground line-clamp-2">
                      {notification.message}
                    </p>
                    <p className="text-xs text-muted-foreground mt-1">
                      {formatDistanceToNow(new Date(notification.timestamp), {
                        addSuffix: true,
                        locale: ko,
                      })}
                    </p>
                  </div>
                </div>
              </DropdownMenuItem>
            ))}
          </div>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  );
};
```

---

## ğŸ”„ **4ë‹¨ê³„: ì‹¤ì‹œê°„ ìƒíƒœ í‘œì‹œ**

### `src/components/common/ConnectionStatus.tsx`
```typescript
import { Wifi, WifiOff, AlertCircle } from 'lucide-react';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { useWebSocketStatus } from '@/hooks/useWebSocket';

/**
 * WebSocket ì—°ê²° ìƒíƒœ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
 */
export const ConnectionStatus: React.FC = () => {
  const status = useWebSocketStatus();

  const getStatusConfig = () => {
    switch (status) {
      case 'connected':
        return {
          icon: Wifi,
          label: 'ì˜¨ë¼ì¸',
          variant: 'default' as const,
          color: 'text-green-600',
        };
      case 'connecting':
        return {
          icon: AlertCircle,
          label: 'ì—°ê²° ì¤‘...',
          variant: 'secondary' as const,
          color: 'text-yellow-600',
        };
      case 'disconnected':
        return {
          icon: WifiOff,
          label: 'ì˜¤í”„ë¼ì¸',
          variant: 'destructive' as const,
          color: 'text-red-600',
        };
      case 'error':
        return {
          icon: AlertCircle,
          label: 'ì—°ê²° ì˜¤ë¥˜',
          variant: 'destructive' as const,
          color: 'text-red-600',
        };
      default:
        return {
          icon: WifiOff,
          label: 'ì•Œ ìˆ˜ ì—†ìŒ',
          variant: 'secondary' as const,
          color: 'text-gray-600',
        };
    }
  };

  const config = getStatusConfig();
  const Icon = config.icon;

  // ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ í‘œì‹œí•˜ì§€ ì•ŠìŒ
  if (status === 'connected') {
    return null;
  }

  return (
    <Alert variant={config.variant} className="mb-4">
      <Icon className="h-4 w-4" />
      <AlertDescription className="flex items-center justify-between">
        <span>ì‹¤ì‹œê°„ ì—°ê²° ìƒíƒœ: {config.label}</span>
        <Badge variant={config.variant}>
          <Icon className={`h-3 w-3 mr-1 ${config.color}`} />
          {config.label}
        </Badge>
      </AlertDescription>
    </Alert>
  );
};
```

### `src/components/features/rooms/RoomStatusIndicator.tsx`
```typescript
import { Badge } from '@/components/ui/badge';
import { Users, Clock } from 'lucide-react';

interface RoomStatusIndicatorProps {
  isOccupied: boolean;
  currentReservation?: {
    title: string;
    endTime: string;
    attendeeCount?: number;
  };
  nextReservation?: {
    title: string;
    startTime: string;
  };
}

/**
 * íšŒì˜ì‹¤ ì‹¤ì‹œê°„ ìƒíƒœ í‘œì‹œ ì»´í¬ë„ŒíŠ¸
 */
export const RoomStatusIndicator: React.FC<RoomStatusIndicatorProps> = ({
  isOccupied,
  currentReservation,
  nextReservation,
}) => {
  return (
    <div className="space-y-2">
      {/* í˜„ì¬ ìƒíƒœ */}
      <div className="flex items-center gap-2">
        <Badge variant={isOccupied ? 'destructive' : 'default'}>
          {isOccupied ? 'ì‚¬ìš© ì¤‘' : 'ì‚¬ìš© ê°€ëŠ¥'}
        </Badge>
        
        {isOccupied && currentReservation && (
          <div className="flex items-center gap-1 text-sm text-muted-foreground">
            <Clock className="h-3 w-3" />
            <span>
              {new Date(currentReservation.endTime).toLocaleTimeString('ko-KR', {
                hour: '2-digit',
                minute: '2-digit',
              })}ê¹Œì§€
            </span>
          </div>
        )}
      </div>

      {/* í˜„ì¬ ì˜ˆì•½ ì •ë³´ */}
      {isOccupied && currentReservation && (
        <div className="text-sm">
          <p className="font-medium">{currentReservation.title}</p>
          {currentReservation.attendeeCount && (
            <div className="flex items-center gap-1 text-muted-foreground">
              <Users className="h-3 w-3" />
              <span>{currentReservation.attendeeCount}ëª…</span>
            </div>
          )}
        </div>
      )}

      {/* ë‹¤ìŒ ì˜ˆì•½ ì •ë³´ */}
      {!isOccupied && nextReservation && (
        <div className="text-sm text-muted-foreground">
          <p>
            ë‹¤ìŒ: {nextReservation.title} (
            {new Date(nextReservation.startTime).toLocaleTimeString('ko-KR', {
              hour: '2-digit',
              minute: '2-digit',
            })}
            )
          </p>
        </div>
      )}
    </div>
  );
};
```

---

## ğŸ›ï¸ **5ë‹¨ê³„: ë©”ì¸ ì•±ì— ì‹¤ì‹œê°„ ê¸°ëŠ¥ í†µí•©**

### `src/App.tsx` ì—…ë°ì´íŠ¸
```typescript
import { AppRouter } from '@/lib/router';
import { ErrorBoundary, ConnectionStatus } from '@/components/common';
import { useTokenRefresh } from '@/hooks/useTokenRefresh';
import { useWebSocket } from '@/hooks/useWebSocket';
import { useRealtimeReservations } from '@/hooks/useRealtimeReservations';
import { useRealtimeRooms } from '@/hooks/useRealtimeRooms';
import '@/styles/globals.css';

function App() {
  // í† í° ìë™ ê°±ì‹ 
  useTokenRefresh();
  
  // WebSocket ì—°ê²°
  useWebSocket();
  
  // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ êµ¬ë…
  useRealtimeReservations();
  useRealtimeRooms();

  return (
    <ErrorBoundary>
      <ConnectionStatus />
      <AppRouter />
    </ErrorBoundary>
  );
}

export default App;
```

### Header ì»´í¬ë„ŒíŠ¸ì— ì•Œë¦¼ ë²¨ ì¶”ê°€
```typescript
// src/components/common/Header.tsx ì—…ë°ì´íŠ¸
import { NotificationBell } from './NotificationBell';

// Header ì»´í¬ë„ŒíŠ¸ì˜ ìš°ì¸¡ ì•¡ì…˜ ë²„íŠ¼ ë¶€ë¶„ì„ ë‹¤ìŒê³¼ ê°™ì´ ìˆ˜ì •:
<div className="flex items-center space-x-2">
  {/* ì•Œë¦¼ ë²„íŠ¼ */}
  <NotificationBell />

  {/* ì‚¬ìš©ì ë©”ë‰´ */}
  <DropdownMenu>
    {/* ê¸°ì¡´ ì½”ë“œ... */}
  </DropdownMenu>
</div>
```

---

## ğŸ”§ **6ë‹¨ê³„: ë¸Œë¼ìš°ì € ì•Œë¦¼ ê¶Œí•œ ìš”ì²­**

### `src/utils/notifications.ts`
```typescript
/**
 * ë¸Œë¼ìš°ì € ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
 */
export const requestNotificationPermission = async (): Promise<NotificationPermission> => {
  if (!('Notification' in window)) {
    console.warn('This browser does not support notifications');
    return 'denied';
  }

  if (Notification.permission === 'granted') {
    return 'granted';
  }

  if (Notification.permission !== 'denied') {
    const permission = await Notification.requestPermission();
    return permission;
  }

  return Notification.permission;
};

/**
 * ë¸Œë¼ìš°ì € ì•Œë¦¼ í‘œì‹œ
 */
export const showBrowserNotification = (
  title: string,
  options: NotificationOptions = {}
): Notification | null => {
  if (Notification.permission !== 'granted') {
    return null;
  }

  return new Notification(title, {
    icon: '/icon-192x192.png',
    badge: '/icon-192x192.png',
    ...options,
  });
};
```

### ë¡œê·¸ì¸ ì‹œ ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
```typescript
// src/hooks/useAuth.tsì— ì¶”ê°€
import { requestNotificationPermission } from '@/utils/notifications';

// loginMutationì˜ onSuccessì— ì¶”ê°€:
onSuccess: async (data) => {
  // ê¸°ì¡´ ì½”ë“œ...
  
  // ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
  await requestNotificationPermission();
  
  // ê¸°ì¡´ ì½”ë“œ...
},
```

---

## ğŸ“Š **7ë‹¨ê³„: ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ìœ„ì ¯**

### `src/components/features/dashboard/RealtimeStats.tsx`
```typescript
import { useEffect, useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useWebSocketEvent } from '@/hooks/useWebSocket';
import { Badge } from '@/components/ui/badge';

/**
 * ì‹¤ì‹œê°„ í†µê³„ ìœ„ì ¯
 */
export const RealtimeStats: React.FC = () => {
  const [stats, setStats] = useState({
    activeReservations: 0,
    connectedUsers: 0,
    availableRooms: 12,
    lastUpdate: new Date(),
  });

  // ì‹¤ì‹œê°„ í†µê³„ ì—…ë°ì´íŠ¸
  useWebSocketEvent('stats:update', (event) => {
    setStats(prevStats => ({
      ...prevStats,
      ...event.data,
      lastUpdate: new Date(),
    }));
  });

  // ì‚¬ìš©ì ì—°ê²°/í•´ì œ ì´ë²¤íŠ¸
  useWebSocketEvent('user:connected', () => {
    setStats(prev => ({ ...prev, connectedUsers: prev.connectedUsers + 1 }));
  });

  useWebSocketEvent('user:disconnected', () => {
    setStats(prev => ({ 
      ...prev, 
      connectedUsers: Math.max(0, prev.connectedUsers - 1) 
    }));
  });

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <CardTitle className="text-sm font-medium">
          ì‹¤ì‹œê°„ í˜„í™©
        </CardTitle>
        <Badge variant="outline" className="text-xs">
          Live
        </Badge>
      </CardHeader>
      <CardContent>
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div>
            <p className="text-muted-foreground">ì§„í–‰ ì¤‘ì¸ íšŒì˜</p>
            <p className="text-lg font-bold">{stats.activeReservations}</p>
          </div>
          <div>
            <p className="text-muted-foreground">ì ‘ì† ì¤‘ì¸ ì‚¬ìš©ì</p>
            <p className="text-lg font-bold">{stats.connectedUsers}</p>
          </div>
          <div>
            <p className="text-muted-foreground">ì‚¬ìš© ê°€ëŠ¥í•œ íšŒì˜ì‹¤</p>
            <p className="text-lg font-bold">{stats.availableRooms}</p>
          </div>
          <div>
            <p className="text-muted-foreground">ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸</p>
            <p className="text-xs text-muted-foreground">
              {stats.lastUpdate.toLocaleTimeString()}
            </p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};
```
