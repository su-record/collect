# 3️⃣ 인증 시스템 구현 가이드

## 🎯 **목표**
JWT 기반의 안전하고 사용자 친화적인 인증 시스템을 구현합니다. 자동 로그인, 토큰 갱신, 보호된 라우트 등 완전한 인증 플로우를 제공합니다.

---

## 🔐 **인증 시스템 요약**

### 🛡️ **보안 특징**
- **JWT 기반 인증** - 상태 비저장 토큰 방식
- **자동 토큰 갱신** - 사용자 개입 없이 세션 유지
- **메모리 기반 액세스 토큰** - XSS 공격 방지
- **API 인터셉터** - 자동 토큰 만료 처리
- **역할 기반 접근 제어** - 관리자/사용자 권한 구분

### 🎯 **사용자 경험**
- **자동 로그인** - 페이지 새로고침 시에도 로그인 유지
- **부드러운 전환** - 로딩 상태와 에러 처리
- **비밀번호 관리** - 변경 및 재설정 지원
- **프로필 관리** - 사용자 정보 수정 기능

---

## 🔐 **인증 플로우 개요**

### 📋 **전체 인증 프로세스**
```
1. 로그인 → 2. 토큰 저장 → 3. API 요청 시 인증 → 4. 토큰 갱신 → 5. 로그아웃
```

---

## 🚀 **1단계: 인증 상태 관리 (Zustand)**

### `src/stores/authStore.ts`
```typescript
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { User } from '@/types/auth';

/**
 * 인증 상태 인터페이스
 */
interface AuthState {
  // 상태
  user: User | null;
  accessToken: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  
  // 액션
  setUser: (user: User) => void;
  setTokens: (accessToken: string, refreshToken: string) => void;
  clearAuth: () => void;
  setLoading: (loading: boolean) => void;
}

/**
 * 인증 스토어
 * - accessToken: 메모리에만 저장 (보안)
 * - refreshToken: localStorage에 저장 (자동 로그인용)
 * - user: localStorage에 저장 (UI 표시용)
 */
export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      // 초기 상태
      user: null,
      accessToken: null,
      refreshToken: null,
      isAuthenticated: false,
      isLoading: false,

      // 사용자 정보 설정
      setUser: (user: User) => {
        set({ 
          user, 
          isAuthenticated: true 
        });
      },

      // 토큰 설정
      setTokens: (accessToken: string, refreshToken: string) => {
        set({ 
          accessToken, 
          refreshToken,
          isAuthenticated: true 
        });
        
        // API 클라이언트에 토큰 설정
        if (typeof window !== 'undefined') {
          const { apiClient } = require('@/services/api/client');
          apiClient.setAuthToken(accessToken);
        }
      },

      // 인증 정보 모두 삭제
      clearAuth: () => {
        set({ 
          user: null,
          accessToken: null,
          refreshToken: null,
          isAuthenticated: false 
        });
        
        // API 클라이언트에서 토큰 제거
        if (typeof window !== 'undefined') {
          const { apiClient } = require('@/services/api/client');
          apiClient.removeAuthToken();
        }
      },

      // 로딩 상태 설정
      setLoading: (loading: boolean) => {
        set({ isLoading: loading });
      },
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => localStorage),
      // accessToken은 메모리에만 저장 (보안상 localStorage 제외)
      partialize: (state) => ({
        user: state.user,
        refreshToken: state.refreshToken,
      }),
    }
  )
);
```

---

## 🔑 **2단계: 인증 API 서비스 확장**

### `src/services/api/auth.ts` 보완
```typescript
import { apiClient, ApiResponse } from './client';
import { API_ENDPOINTS } from '@/utils/constants';
import { LoginRequest, LoginResponse, User } from '@/types/auth';

/**
 * 토큰 갱신 응답 타입
 */
export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken: string;
  user: User;
}

/**
 * 비밀번호 변경 요청 타입
 */
export interface ChangePasswordRequest {
  currentPassword: string;
  newPassword: string;
  confirmPassword: string;
}

/**
 * 인증 관련 API 서비스
 */
export const authAPI = {
  /**
   * 로그인
   */
  login: async (credentials: LoginRequest): Promise<ApiResponse<LoginResponse>> => {
    return apiClient.post<LoginResponse>(API_ENDPOINTS.AUTH.LOGIN, credentials);
  },

  /**
   * 로그아웃 (서버에서 리프레시 토큰 무효화)
   */
  logout: async (): Promise<ApiResponse<void>> => {
    return apiClient.post<void>(API_ENDPOINTS.AUTH.LOGOUT);
  },

  /**
   * 토큰 갱신
   */
  refreshToken: async (refreshToken: string): Promise<ApiResponse<RefreshTokenResponse>> => {
    return apiClient.post<RefreshTokenResponse>(API_ENDPOINTS.AUTH.REFRESH, {
      refreshToken,
    });
  },

  /**
   * 현재 사용자 정보 조회
   */
  getMe: async (): Promise<ApiResponse<User>> => {
    return apiClient.get<User>(API_ENDPOINTS.AUTH.ME);
  },

  /**
   * 비밀번호 변경
   */
  changePassword: async (data: ChangePasswordRequest): Promise<ApiResponse<void>> => {
    return apiClient.post<void>(API_ENDPOINTS.AUTH.CHANGE_PASSWORD, data);
  },

  /**
   * 비밀번호 초기화 요청 (관리자에게 알림)
   */
  requestPasswordReset: async (email: string): Promise<ApiResponse<void>> => {
    return apiClient.post<void>(API_ENDPOINTS.AUTH.REQUEST_RESET, { email });
  },
};
```

### `src/utils/constants.ts` API 엔드포인트 추가
```typescript
export const API_ENDPOINTS = {
  // 인증
  AUTH: {
    LOGIN: '/auth/login',
    LOGOUT: '/auth/logout',
    REFRESH: '/auth/refresh',
    ME: '/auth/me',
    CHANGE_PASSWORD: '/auth/change-password',
    REQUEST_RESET: '/auth/request-password-reset',
  },
  // ... 기존 엔드포인트들
} as const;
```

---

## 🎣 **3단계: 인증 훅 구현**

### `src/hooks/useAuth.ts` 완전 구현
```typescript
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { useNavigate, useLocation } from 'react-router-dom';
import { authAPI } from '@/services/api/auth';
import { useAuthStore } from '@/stores/authStore';
import { queryKeys } from '@/lib/queryClient';
import { LoginRequest, ChangePasswordRequest } from '@/types/auth';
import { ApiError } from '@/services/api/client';

/**
 * 인증 관련 훅
 */
export const useAuth = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const queryClient = useQueryClient();
  
  const {
    user,
    accessToken,
    refreshToken,
    isAuthenticated,
    isLoading,
    setUser,
    setTokens,
    clearAuth,
    setLoading,
  } = useAuthStore();

  // 현재 사용자 정보 조회 (토큰이 있을 때만)
  const { 
    data: userData, 
    error: userError,
    isLoading: isUserLoading 
  } = useQuery({
    queryKey: queryKeys.auth.me,
    queryFn: async () => {
      const response = await authAPI.getMe();
      return response.data;
    },
    enabled: !!accessToken && !user,
    retry: false,
  });

  // 사용자 데이터가 로드되면 스토어에 저장
  useEffect(() => {
    if (userData && !user) {
      setUser(userData);
    }
  }, [userData, user, setUser]);

  // 로그인 뮤테이션
  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginRequest) => {
      setLoading(true);
      const response = await authAPI.login(credentials);
      return response.data;
    },
    onSuccess: (data) => {
      // 토큰과 사용자 정보 저장
      setTokens(data.token, data.refreshToken);
      setUser(data.user);
      
      // 사용자 정보 캐시 업데이트
      queryClient.setQueryData(queryKeys.auth.me, data.user);
      
      // 원래 가려던 페이지 또는 대시보드로 이동
      const from = (location.state as any)?.from?.pathname || '/dashboard';
      navigate(from, { replace: true });
    },
    onError: (error) => {
      console.error('Login failed:', error);
    },
    onSettled: () => {
      setLoading(false);
    },
  });

  // 로그아웃 뮤테이션
  const logoutMutation = useMutation({
    mutationFn: async () => {
      // 서버에 로그아웃 요청 (토큰 무효화)
      if (refreshToken) {
        try {
          await authAPI.logout();
        } catch (error) {
          // 서버 로그아웃 실패해도 클라이언트는 로그아웃 진행
          console.warn('Server logout failed:', error);
        }
      }
    },
    onSuccess: () => {
      // 클라이언트 인증 정보 정리
      clearAuth();
      
      // 모든 쿼리 캐시 초기화
      queryClient.clear();
      
      // 로그인 페이지로 이동
      navigate('/login', { replace: true });
    },
  });

  // 비밀번호 변경 뮤테이션
  const changePasswordMutation = useMutation({
    mutationFn: async (data: ChangePasswordRequest) => {
      const response = await authAPI.changePassword(data);
      return response.data;
    },
    onSuccess: () => {
      // 비밀번호 변경 후 재로그인 유도
      clearAuth();
      queryClient.clear();
      navigate('/login', { 
        replace: true,
        state: { message: '비밀번호가 변경되었습니다. 다시 로그인해주세요.' }
      });
    },
  });

  // 비밀번호 초기화 요청 뮤테이션
  const requestPasswordResetMutation = useMutation({
    mutationFn: async (email: string) => {
      const response = await authAPI.requestPasswordReset(email);
      return response.data;
    },
  });

  return {
    // 상태
    user,
    isAuthenticated,
    isLoading: isLoading || isUserLoading,
    error: userError,
    
    // 액션
    login: loginMutation.mutate,
    logout: logoutMutation.mutate,
    changePassword: changePasswordMutation.mutate,
    requestPasswordReset: requestPasswordResetMutation.mutate,
    
    // 뮤테이션 상태
    isLoggingIn: loginMutation.isPending,
    isLoggingOut: logoutMutation.isPending,
    isChangingPassword: changePasswordMutation.isPending,
    isRequestingReset: requestPasswordResetMutation.isPending,
    
    // 에러
    loginError: loginMutation.error,
    logoutError: logoutMutation.error,
    changePasswordError: changePasswordMutation.error,
    resetRequestError: requestPasswordResetMutation.error,
  };
};
```

---

## 🔄 **4단계: 자동 토큰 갱신 시스템**

### `src/hooks/useTokenRefresh.ts` 보완
```typescript
import { useEffect, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { authAPI } from '@/services/api/auth';
import { useAuthStore } from '@/stores/authStore';
import { ApiError } from '@/services/api/client';

/**
 * JWT 토큰 자동 갱신 훅
 */
export const useTokenRefresh = () => {
  const queryClient = useQueryClient();
  const { 
    accessToken, 
    refreshToken, 
    setTokens, 
    clearAuth,
    setLoading 
  } = useAuthStore();

  /**
   * 토큰 갱신 함수
   */
  const refreshAccessToken = useCallback(async (): Promise<boolean> => {
    if (!refreshToken) {
      return false;
    }

    try {
      setLoading(true);
      const response = await authAPI.refreshToken(refreshToken);
      const { accessToken: newAccessToken, refreshToken: newRefreshToken } = response.data;
      
      // 새 토큰들 저장
      setTokens(newAccessToken, newRefreshToken);
      
      return true;
    } catch (error) {
      console.error('Token refresh failed:', error);
      
      // 리프레시 토큰도 만료된 경우 로그아웃 처리
      if (error instanceof ApiError && [401, 403].includes(error.status)) {
        clearAuth();
        queryClient.clear();
        window.location.href = '/login';
      }
      
      return false;
    } finally {
      setLoading(false);
    }
  }, [refreshToken, setTokens, clearAuth, queryClient, setLoading]);

  /**
   * 토큰 만료 시간 확인 및 갱신 스케줄링
   */
  useEffect(() => {
    if (!accessToken || !refreshToken) {
      return;
    }

    const scheduleTokenRefresh = () => {
      try {
        // JWT 토큰 디코딩
        const payload = JSON.parse(atob(accessToken.split('.')[1]));
        const expiryTime = payload.exp * 1000; // 밀리초로 변환
        const currentTime = Date.now();
        
        // 만료 5분 전에 갱신
        const REFRESH_MARGIN = 5 * 60 * 1000; // 5분
        const timeUntilRefresh = expiryTime - currentTime - REFRESH_MARGIN;

        if (timeUntilRefresh > 0) {
          // 토큰 갱신 스케줄링
          const timeoutId = setTimeout(() => {
            refreshAccessToken();
          }, timeUntilRefresh);

          return () => clearTimeout(timeoutId);
        } else {
          // 이미 만료되었거나 곧 만료될 예정이면 즉시 갱신
          refreshAccessToken();
        }
      } catch (error) {
        console.error('Invalid token format:', error);
        clearAuth();
      }
    };

    return scheduleTokenRefresh();
  }, [accessToken, refreshToken, refreshAccessToken, clearAuth]);

  /**
   * 앱 초기 로드 시 토큰 상태 확인
   */
  useEffect(() => {
    // localStorage에서 복원된 refreshToken이 있지만 accessToken이 없는 경우
    if (refreshToken && !accessToken) {
      refreshAccessToken();
    }
  }, [refreshToken, accessToken, refreshAccessToken]);

  return {
    refreshAccessToken,
  };
};
```

---

## 🛡️ **5단계: 라우트 보호 시스템**

### `src/components/features/auth/ProtectedRoute.tsx` 보완
```typescript
import { ReactNode, useEffect } from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { Layout, Loading } from '@/components/common';
import { useAuth } from '@/hooks/useAuth';
import { useAuthStore } from '@/stores/authStore';

interface ProtectedRouteProps {
  children: ReactNode;
  requiredRole?: 'admin' | 'user';
}

/**
 * 인증이 필요한 라우트를 보호하는 컴포넌트
 */
export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ 
  children, 
  requiredRole 
}) => {
  const location = useLocation();
  const { isAuthenticated, user, isLoading } = useAuth();
  const { accessToken } = useAuthStore();

  // 로딩 중일 때
  if (isLoading || (!user && accessToken)) {
    return (
      <Layout>
        <div className="flex items-center justify-center min-h-[400px]">
          <Loading size="lg" text="인증 확인 중..." />
        </div>
      </Layout>
    );
  }

  // 인증되지 않은 경우
  if (!isAuthenticated) {
    return (
      <Navigate 
        to="/login" 
        state={{ from: location }} 
        replace 
      />
    );
  }

  // 권한 확인 (역할 기반 접근 제어)
  if (requiredRole && user?.role !== requiredRole) {
    return (
      <Layout>
        <div className="flex items-center justify-center min-h-[400px]">
          <div className="text-center">
            <h2 className="text-2xl font-bold text-red-600">접근 권한 없음</h2>
            <p className="text-muted-foreground mt-2">
              이 페이지에 접근할 권한이 없습니다.
            </p>
          </div>
        </div>
      </Layout>
    );
  }

  return <Layout>{children}</Layout>;
};
```

### `src/components/features/auth/PublicRoute.tsx` 보완
```typescript
import { ReactNode } from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '@/hooks/useAuth';
import { Loading } from '@/components/common';

interface PublicRouteProps {
  children: ReactNode;
}

/**
 * 비인증 사용자만 접근 가능한 라우트 (로그인 페이지 등)
 */
export const PublicRoute: React.FC<PublicRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();

  // 로딩 중일 때
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loading size="lg" text="로딩 중..." />
      </div>
    );
  }

  // 이미 인증된 사용자는 대시보드로 리다이렉트
  if (isAuthenticated) {
    return <Navigate to="/dashboard" replace />;
  }

  return <>{children}</>;
};
```

---

## 📝 **6단계: 로그인 페이지 구현**

### `src/pages/LoginPage.tsx` 완전 구현
```typescript
import { useState, useEffect } from 'react';
import { useLocation } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Eye, EyeOff, LogIn, AlertCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useAuth } from '@/hooks/useAuth';
import { ApiError } from '@/services/api/client';
import { APP_NAME } from '@/utils/constants';

/**
 * 로그인 폼 스키마
 */
const loginSchema = z.object({
  email: z
    .string()
    .min(1, '이메일을 입력해주세요')
    .email('올바른 이메일 형식이 아닙니다'),
  password: z
    .string()
    .min(1, '비밀번호를 입력해주세요'),
});

type LoginFormData = z.infer<typeof loginSchema>;

/**
 * 로그인 페이지
 */
export const LoginPage: React.FC = () => {
  const [showPassword, setShowPassword] = useState(false);
  const [alertMessage, setAlertMessage] = useState<string>('');
  const location = useLocation();
  
  const { 
    login, 
    isLoggingIn, 
    loginError,
    requestPasswordReset,
    isRequestingReset,
    resetRequestError
  } = useAuth();

  const {
    register,
    handleSubmit,
    formState: { errors },
    setFocus,
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  // 페이지 로드 시 이메일 필드에 포커스
  useEffect(() => {
    setFocus('email');
  }, [setFocus]);

  // 로그인 페이지 진입 시 메시지 표시
  useEffect(() => {
    const state = location.state as any;
    if (state?.message) {
      setAlertMessage(state.message);
    }
  }, [location.state]);

  /**
   * 로그인 처리
   */
  const onSubmit = (data: LoginFormData) => {
    setAlertMessage('');
    login(data);
  };

  /**
   * 비밀번호 재설정 요청
   */
  const handlePasswordReset = async () => {
    const email = (document.getElementById('email') as HTMLInputElement)?.value;
    
    if (!email) {
      setAlertMessage('이메일을 먼저 입력해주세요.');
      return;
    }

    try {
      await requestPasswordReset(email);
      setAlertMessage('비밀번호 재설정 요청이 관리자에게 전송되었습니다.');
    } catch (error) {
      setAlertMessage('비밀번호 재설정 요청에 실패했습니다.');
    }
  };

  /**
   * 에러 메시지 처리
   */
  const getErrorMessage = () => {
    if (alertMessage) return alertMessage;
    if (loginError instanceof ApiError) {
      return loginError.message || '로그인에 실패했습니다.';
    }
    if (resetRequestError instanceof ApiError) {
      return resetRequestError.message || '비밀번호 재설정 요청에 실패했습니다.';
    }
    return '';
  };

  const errorMessage = getErrorMessage();

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <div className="flex items-center justify-center mb-4">
            <div className="w-12 h-12 bg-primary rounded-lg flex items-center justify-center">
              <LogIn className="w-6 h-6 text-primary-foreground" />
            </div>
          </div>
          <CardTitle className="text-2xl text-center">
            {APP_NAME}
          </CardTitle>
          <p className="text-center text-muted-foreground">
            계정에 로그인하세요
          </p>
        </CardHeader>
        
        <CardContent>
          {errorMessage && (
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>{errorMessage}</AlertDescription>
            </Alert>
          )}

          <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">이메일</Label>
              <Input
                id="email"
                type="email"
                placeholder="name@company.com"
                disabled={isLoggingIn}
                {...register('email')}
              />
              {errors.email && (
                <p className="text-sm text-red-600">{errors.email.message}</p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="password">비밀번호</Label>
              <div className="relative">
                <Input
                  id="password"
                  type={showPassword ? 'text' : 'password'}
                  placeholder="비밀번호를 입력하세요"
                  disabled={isLoggingIn}
                  {...register('password')}
                />
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
                  onClick={() => setShowPassword(!showPassword)}
                  disabled={isLoggingIn}
                >
                  {showPassword ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </Button>
              </div>
              {errors.password && (
                <p className="text-sm text-red-600">{errors.password.message}</p>
              )}
            </div>

            <Button
              type="submit"
              className="w-full"
              disabled={isLoggingIn}
            >
              {isLoggingIn ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
                  로그인 중...
                </>
              ) : (
                '로그인'
              )}
            </Button>
          </form>

          <div className="mt-4 text-center">
            <Button
              variant="link"
              size="sm"
              onClick={handlePasswordReset}
              disabled={isRequestingReset}
              className="text-sm text-muted-foreground hover:text-primary"
            >
              {isRequestingReset ? '처리 중...' : '비밀번호를 잊으셨나요?'}
            </Button>
          </div>

          <div className="mt-6 text-center text-xs text-muted-foreground">
            <p>문제가 있으시면 관리자에게 문의하세요</p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};
```

---

## 🔧 **7단계: 프로필 및 비밀번호 관리**

### `src/components/features/auth/ChangePasswordDialog.tsx`
```typescript
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Eye, EyeOff, Lock } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { useAuth } from '@/hooks/useAuth';
import { ApiError } from '@/services/api/client';

/**
 * 비밀번호 변경 스키마
 */
const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, '현재 비밀번호를 입력해주세요'),
  newPassword: z
    .string()
    .min(8, '새 비밀번호는 최소 8자 이상이어야 합니다')
    .regex(
      /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
      '새 비밀번호는 대소문자, 숫자, 특수문자를 포함해야 합니다'
    ),
  confirmPassword: z.string().min(1, '비밀번호 확인을 입력해주세요'),
}).refine(
  (data) => data.newPassword === data.confirmPassword,
  {
    message: '새 비밀번호가 일치하지 않습니다',
    path: ['confirmPassword'],
  }
);

type ChangePasswordFormData = z.infer<typeof changePasswordSchema>;

/**
 * 비밀번호 변경 다이얼로그
 */
export const ChangePasswordDialog: React.FC = () => {
  const [open, setOpen] = useState(false);
  const [showPasswords, setShowPasswords] = useState({
    current: false,
    new: false,
    confirm: false,
  });

  const { changePassword, isChangingPassword, changePasswordError } = useAuth();

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
  } = useForm<ChangePasswordFormData>({
    resolver: zodResolver(changePasswordSchema),
  });

  /**
   * 비밀번호 변경 처리
   */
  const onSubmit = async (data: ChangePasswordFormData) => {
    try {
      await changePassword(data);
      setOpen(false);
      reset();
    } catch (error) {
      // 에러는 useAuth에서 처리됨
    }
  };

  /**
   * 다이얼로그 닫기
   */
  const handleClose = () => {
    setOpen(false);
    reset();
  };

  /**
   * 비밀번호 표시/숨김 토글
   */
  const togglePasswordVisibility = (field: keyof typeof showPasswords) => {
    setShowPasswords(prev => ({
      ...prev,
      [field]: !prev[field],
    }));
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant="outline" size="sm">
          <Lock className="h-4 w-4 mr-2" />
          비밀번호 변경
        </Button>
      </DialogTrigger>
      
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>비밀번호 변경</DialogTitle>
          <DialogDescription>
            보안을 위해 새로운 비밀번호로 변경해주세요.
          </DialogDescription>
        </DialogHeader>

        {changePasswordError && (
          <Alert variant="destructive">
            <AlertDescription>
              {changePasswordError instanceof ApiError 
                ? changePasswordError.message 
                : '비밀번호 변경에 실패했습니다.'}
            </AlertDescription>
          </Alert>
        )}

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          {/* 현재 비밀번호 */}
          <div className="space-y-2">
            <Label htmlFor="currentPassword">현재 비밀번호</Label>
            <div className="relative">
              <Input
                id="currentPassword"
                type={showPasswords.current ? 'text' : 'password'}
                disabled={isChangingPassword}
                {...register('currentPassword')}
              />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="absolute right-0 top-0 h-full px-3"
                onClick={() => togglePasswordVisibility('current')}
              >
                {showPasswords.current ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
              </Button>
            </div>
            {errors.currentPassword && (
              <p className="text-sm text-red-600">{errors.currentPassword.message}</p>
            )}
          </div>

          {/* 새 비밀번호 */}
          <div className="space-y-2">
            <Label htmlFor="newPassword">새 비밀번호</Label>
            <div className="relative">
              <Input
                id="newPassword"
                type={showPasswords.new ? 'text' : 'password'}
                disabled={isChangingPassword}
                {...register('newPassword')}
              />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="absolute right-0 top-0 h-full px-3"
                onClick={() => togglePasswordVisibility('new')}
              >
                {showPasswords.new ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
              </Button>
            </div>
            {errors.newPassword && (
              <p className="text-sm text-red-600">{errors.newPassword.message}</p>
            )}
          </div>

          {/* 비밀번호 확인 */}
          <div className="space-y-2">
            <Label htmlFor="confirmPassword">새 비밀번호 확인</Label>
            <div className="relative">
              <Input
                id="confirmPassword"
                type={showPasswords.confirm ? 'text' : 'password'}
                disabled={isChangingPassword}
                {...register('confirmPassword')}
              />
              <Button
                type="button"
                variant="ghost"
                size="sm"
                className="absolute right-0 top-0 h-full px-3"
                onClick={() => togglePasswordVisibility('confirm')}
              >
                {showPasswords.confirm ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
              </Button>
            </div>
            {errors.confirmPassword && (
              <p className="text-sm text-red-600">{errors.confirmPassword.message}</p>
            )}
          </div>

          {/* 버튼들 */}
          <div className="flex justify-end gap-2 pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={handleClose}
              disabled={isChangingPassword}
            >
              취소
            </Button>
            <Button type="submit" disabled={isChangingPassword}>
              {isChangingPassword ? '변경 중...' : '변경하기'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
};
```

### `src/pages/ProfilePage.tsx` 구현
```typescript
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { User, Mail, Calendar, Shield } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { PageTitle } from '@/components/common';
import { ChangePasswordDialog } from '@/components/features/auth/ChangePasswordDialog';
import { useAuth } from '@/hooks/useAuth';
import { usersAPI } from '@/services/api/users';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { queryKeys } from '@/lib/queryClient';

/**
 * 프로필 수정 스키마
 */
const profileSchema = z.object({
  name: z.string().min(2, '이름은 최소 2자 이상이어야 합니다'),
});

type ProfileFormData = z.infer<typeof profileSchema>;

/**
 * 프로필 페이지
 */
export const ProfilePage: React.FC = () => {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  const [isEditing, setIsEditing] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    setValue,
  } = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    defaultValues: {
      name: user?.name || '',
    },
  });

  // 프로필 수정 뮤테이션
  const updateProfileMutation = useMutation({
    mutationFn: async (data: ProfileFormData) => {
      const response = await usersAPI.updateProfile(data);
      return response.data;
    },
    onSuccess: (updatedUser) => {
      // 사용자 정보 캐시 업데이트
      queryClient.setQueryData(queryKeys.auth.me, updatedUser);
      setIsEditing(false);
    },
  });

  /**
   * 프로필 수정 처리
   */
  const onSubmit = (data: ProfileFormData) => {
    updateProfileMutation.mutate(data);
  };

  /**
   * 수정 취소
   */
  const handleCancel = () => {
    reset({ name: user?.name || '' });
    setIsEditing(false);
  };

  if (!user) {
    return null;
  }

  return (
    <div className="space-y-6">
      <PageTitle 
        title="내 프로필" 
        description="계정 정보를 확인하고 관리할 수 있습니다" 
      />

      <div className="grid gap-6">
        {/* 기본 정보 */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <User className="h-5 w-5" />
              기본 정보
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
              <div className="grid gap-4 md:grid-cols-2">
                {/* 이름 */}
                <div className="space-y-2">
                  <Label htmlFor="name">이름</Label>
                  {isEditing ? (
                    <Input
                      id="name"
                      disabled={updateProfileMutation.isPending}
                      {...register('name')}
                    />
                  ) : (
                    <div className="px-3 py-2 border rounded-md bg-muted">
                      {user.name}
                    </div>
                  )}
                  {errors.name && (
                    <p className="text-sm text-red-600">{errors.name.message}</p>
                  )}
                </div>

                {/* 이메일 (읽기 전용) */}
                <div className="space-y-2">
                  <Label>이메일</Label>
                  <div className="px-3 py-2 border rounded-md bg-muted flex items-center gap-2">
                    <Mail className="h-4 w-4 text-muted-foreground" />
                    {user.email}
                  </div>
                </div>
              </div>

              {/* 버튼들 */}
              <div className="flex gap-2">
                {isEditing ? (
                  <>
                    <Button
                      type="submit"
                      disabled={updateProfileMutation.isPending}
                    >
                      {updateProfileMutation.isPending ? '저장 중...' : '저장'}
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      onClick={handleCancel}
                      disabled={updateProfileMutation.isPending}
                    >
                      취소
                    </Button>
                  </>
                ) : (
                  <Button onClick={() => setIsEditing(true)}>
                    수정
                  </Button>
                )}
              </div>
            </form>
          </CardContent>
        </Card>

        {/* 계정 정보 */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Shield className="h-5 w-5" />
              계정 정보
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid gap-4 md:grid-cols-2">
              {/* 역할 */}
              <div className="space-y-2">
                <Label>역할</Label>
                <div className="flex items-center gap-2">
                  <Badge variant={user.role === 'admin' ? 'default' : 'secondary'}>
                    {user.role === 'admin' ? '관리자' : '사용자'}
                  </Badge>
                </div>
              </div>

              {/* 가입일 */}
              <div className="space-y-2">
                <Label>가입일</Label>
                <div className="px-3 py-2 border rounded-md bg-muted flex items-center gap-2">
                  <Calendar className="h-4 w-4 text-muted-foreground" />
                  {new Date(user.createdAt).toLocaleDateString('ko-KR')}
                </div>
              </div>
            </div>

            <Separator />

            {/* 보안 설정 */}
            <div className="space-y-4">
              <h3 className="text-sm font-medium">보안 설정</h3>
              <div className="flex gap-2">
                <ChangePasswordDialog />
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};
```

---

## 🔐 **8단계: API 인터셉터 설정**

### `src/services/api/client.ts` 인터셉터 추가
```typescript
// 기존 코드에 추가

/**
 * 응답 인터셉터로 토큰 만료 처리
 */
export const setupAuthInterceptor = () => {
  const originalRequest = apiClient.request;
  
  apiClient.request = async function<T>(
    endpoint: string, 
    options: RequestOptions = {}
  ): Promise<ApiResponse<T>> {
    try {
      return await originalRequest.call(this, endpoint, options);
    } catch (error) {
      if (error instanceof ApiError && error.status === 401) {
        // 토큰 만료 시 자동 갱신 시도
        const { useAuthStore } = await import('@/stores/authStore');
        const { refreshToken, clearAuth } = useAuthStore.getState();
        
        if (refreshToken) {
          try {
            const { authAPI } = await import('./auth');
            const response = await authAPI.refreshToken(refreshToken);
            const { accessToken: newAccessToken, refreshToken: newRefreshToken } = response.data;
            
            // 새 토큰으로 업데이트
            useAuthStore.getState().setTokens(newAccessToken, newRefreshToken);
            
            // 원래 요청 재시도
            return await originalRequest.call(this, endpoint, options);
          } catch (refreshError) {
            // 리프레시 토큰도 만료된 경우 로그아웃
            clearAuth();
            window.location.href = '/login';
            throw refreshError;
          }
        } else {
          // 리프레시 토큰이 없으면 로그아웃
          clearAuth();
          window.location.href = '/login';
        }
      }
      
      throw error;
    }
  };
};
```

---

## 🚀 **9단계: 앱 초기화 및 통합**

### `src/App.tsx` 최종 업데이트
```typescript
import { useEffect } from 'react';
import { AppRouter } from '@/lib/router';
import { ErrorBoundary, ConnectionStatus } from '@/components/common';
import { InstallPrompt } from '@/components/common/InstallPrompt';
import { UpdatePrompt } from '@/components/common/UpdatePrompt';
import { OfflineIndicator } from '@/components/common/OfflineIndicator';
import { PWADebugPanel } from '@/components/dev/PWADebugPanel';
import { useTokenRefresh } from '@/hooks/useTokenRefresh';
import { useWebSocket } from '@/hooks/useWebSocket';
import { useRealtimeReservations } from '@/hooks/useRealtimeReservations';
import { useRealtimeRooms } from '@/hooks/useRealtimeRooms';
import { useOfflineSupport } from '@/hooks/useOfflineSupport';
import { useAuth } from '@/hooks/useAuth';
import { setupAuthInterceptor } from '@/services/api/client';
import '@/styles/globals.css';

function App() {
  // API 인터셉터 설정
  useEffect(() => {
    setupAuthInterceptor();
  }, []);

  // 토큰 자동 갱신
  useTokenRefresh();
  
  // WebSocket 연결 (인증된 사용자만)
  const { isAuthenticated } = useAuth();
  useWebSocket();
  
  // 실시간 업데이트 구독 (인증된 사용자만)
  if (isAuthenticated) {
    useRealtimeReservations();
    useRealtimeRooms();
  }
  
  // 오프라인 지원
  useOfflineSupport();

  return (
    <ErrorBoundary>
      {/* PWA 상태 표시 */}
      <ConnectionStatus />
      <OfflineIndicator />
      
      {/* 메인 앱 */}
      <AppRouter />
      
      {/* PWA 프롬프트들 */}
      <InstallPrompt />
      <UpdatePrompt />
      
      {/* 개발 도구 */}
      <PWADebugPanel />
    </ErrorBoundary>
  );
}

export default App;
```

### `src/lib/router.tsx` 인증 라우팅 업데이트
```typescript
import { createBrowserRouter, RouterProvider, Navigate } from 'react-router-dom';
import { ErrorBoundary } from '@/components/common';
import { ProtectedRoute, PublicRoute } from '@/components/features/auth';
import {
  LoginPage,
  DashboardPage,
  RoomsPage,
  RoomDetailPage,
  ReservationsPage,
  NewReservationPage,
  ReservationDetailPage,
  MyReservationsPage,
  ProfilePage,
  NotFoundPage,
} from '@/pages';

/**
 * 라우터 설정
 */
const router = createBrowserRouter([
  {
    path: '/',
    element: <Navigate to="/dashboard" replace />,
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/login',
    element: (
      <PublicRoute>
        <LoginPage />
      </PublicRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/dashboard',
    element: (
      <ProtectedRoute>
        <DashboardPage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/rooms',
    element: (
      <ProtectedRoute>
        <RoomsPage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/rooms/:id',
    element: (
      <ProtectedRoute>
        <RoomDetailPage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/reservations',
    element: (
      <ProtectedRoute requiredRole="admin">
        <ReservationsPage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/reservations/new',
    element: (
      <ProtectedRoute>
        <NewReservationPage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/reservations/:id',
    element: (
      <ProtectedRoute>
        <ReservationDetailPage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/my-reservations',
    element: (
      <ProtectedRoute>
        <MyReservationsPage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/profile',
    element: (
      <ProtectedRoute>
        <ProfilePage />
      </ProtectedRoute>
    ),
    errorElement: <ErrorBoundary />,
  },
  {
    path: '/404',
    element: <NotFoundPage />,
    errorElement: <ErrorBoundary />,
  },
  {
    path: '*',
    element: <Navigate to="/404" replace />,
  },
]);

/**
 * 앱 라우터 컴포넌트
 */
export const AppRouter: React.FC = () => {
  return <RouterProvider router={router} />;
};
```

---

## 🛡️ **10단계: 보안 고려사항**

### `src/utils/security.ts`
```typescript
/**
 * 보안 관련 유틸리티
 */

/**
 * JWT 토큰 유효성 검사
 */
export const isValidJWT = (token: string): boolean => {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return false;
    
    const payload = JSON.parse(atob(parts[1]));
    const now = Date.now() / 1000;
    
    return payload.exp > now;
  } catch {
    return false;
  }
};

/**
 * 토큰 만료 시간 확인
 */
export const getTokenExpiry = (token: string): number | null => {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload.exp * 1000; // 밀리초로 변환
  } catch {
    return null;
  }
};

/**
 * 비밀번호 강도 검사
 */
export const validatePasswordStrength = (password: string): {
  isValid: boolean;
  errors: string[];
} => {
  const errors: string[] = [];
  
  if (password.length < 8) {
    errors.push('최소 8자 이상이어야 합니다');
  }
  
  if (!/[a-z]/.test(password)) {
    errors.push('소문자를 포함해야 합니다');
  }
  
  if (!/[A-Z]/.test(password)) {
    errors.push('대문자를 포함해야 합니다');
  }
  
  if (!/\d/.test(password)) {
    errors.push('숫자를 포함해야 합니다');
  }
  
  if (!/[@$!%*?&]/.test(password)) {
    errors.push('특수문자를 포함해야 합니다');
  }
  
  return {
    isValid: errors.length === 0,
    errors,
  };
};

/**
 * XSS 방지를 위한 텍스트 이스케이프
 */
export const escapeHtml = (text: string): string => {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
};
```
